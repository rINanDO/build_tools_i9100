From cd22481a5ca8786c7446538e0191f3014525e9c3 Mon Sep 17 00:00:00 2001
From: Arulselvan M <arulselvan.m@intel.com>
Date: Mon, 3 Dec 2012 15:58:44 +0530
Subject: [PATCH 001/119] Can't play AAC file with ID3 tag.

When the file is scanned, the ID3 tag is found to have a
footer at the end of audio data. And getAdtsFrameLength
return zero after reading the footer. As a result, the
duration and mInitCheck are not set. The current change
considers the data till footer and sets the duration based
on no. of frames read till the footer/corrupt frame.

Change-Id: Ie8f898435f0d4ca31fdd355146c4db7b37c0b988
Signed-off-by: Arulselvan M <arulselvan.m@intel.com>
Signed-off-by: Jin Wei <wei.a.jin@intel.com>
---
 media/libstagefright/AACExtractor.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/AACExtractor.cpp b/media/libstagefright/AACExtractor.cpp
index 45e8a30..f6434b4 100644
--- a/media/libstagefright/AACExtractor.cpp
+++ b/media/libstagefright/AACExtractor.cpp
@@ -174,7 +174,7 @@ AACExtractor::AACExtractor(
     if (mDataSource->getSize(&streamSize) == OK) {
          while (offset < streamSize) {
             if ((frameSize = getAdtsFrameLength(source, offset, NULL)) == 0) {
-                return;
+                break;
             }
 
             mOffsetVector.push(offset);
-- 
2.7.4


From a7542ece783c734963e5cbad55e4605cb4c89d20 Mon Sep 17 00:00:00 2001
From: Sergii Doroshenko <x0163979@ti.com>
Date: Fri, 20 Jul 2012 16:46:23 -0500
Subject: [PATCH 002/119] AACExtractor: Added support for APE tag

To support aac audio with APE tag we need parse
this tag. Otherwise AACExtractor stops reading of
audio file.

DR: OMAPS00267689

Change-Id: Ic697b90dbc9f2b93aeb227411359c36c113cb71e
Signed-off-by: Daniel Levin <dendy@ti.com>
---
 media/libstagefright/AACExtractor.cpp       |  25 ++++--
 media/libstagefright/APE.cpp                | 125 ++++++++++++++++++++++++++++
 media/libstagefright/Android.mk             |   1 +
 media/libstagefright/include/AACExtractor.h |   4 +
 media/libstagefright/include/APE.h          |  43 ++++++++++
 5 files changed, 192 insertions(+), 6 deletions(-)
 create mode 100644 media/libstagefright/APE.cpp
 create mode 100644 media/libstagefright/include/APE.h

diff --git a/media/libstagefright/AACExtractor.cpp b/media/libstagefright/AACExtractor.cpp
index f6434b4..1353e3f 100644
--- a/media/libstagefright/AACExtractor.cpp
+++ b/media/libstagefright/AACExtractor.cpp
@@ -136,7 +136,8 @@ AACExtractor::AACExtractor(
         const sp<DataSource> &source, const sp<AMessage> &_meta)
     : mDataSource(source),
       mInitCheck(NO_INIT),
-      mFrameDurationUs(0) {
+      mFrameDurationUs(0),
+      mApeMeta(new MetaData) {
     sp<AMessage> meta = _meta;
 
     if (meta == NULL) {
@@ -170,9 +171,23 @@ AACExtractor::AACExtractor(
     off64_t streamSize, numFrames = 0;
     size_t frameSize = 0;
     int64_t duration = 0;
+    uint8_t apeTag[8];
 
     if (mDataSource->getSize(&streamSize) == OK) {
          while (offset < streamSize) {
+            mDataSource->readAt(offset, &apeTag, 8);
+            if (ape.isAPE(apeTag)) {
+                size_t apeSize = 0;
+                mDataSource->readAt(offset + 8 + 4, &apeSize, 1);
+
+                if (ape.parseAPE(source, offset, mApeMeta) == false) {
+                    break;
+                }
+
+                mOffsetVector.push(offset);
+                offset += apeSize;
+                continue;
+            }
             if ((frameSize = getAdtsFrameLength(source, offset, NULL)) == 0) {
                 break;
             }
@@ -196,15 +211,13 @@ AACExtractor::~AACExtractor() {
 }
 
 sp<MetaData> AACExtractor::getMetaData() {
-    sp<MetaData> meta = new MetaData;
 
     if (mInitCheck != OK) {
-        return meta;
+        return mApeMeta;
     }
+    mApeMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC_ADTS);
 
-    meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC_ADTS);
-
-    return meta;
+    return mApeMeta;
 }
 
 size_t AACExtractor::countTracks() {
diff --git a/media/libstagefright/APE.cpp b/media/libstagefright/APE.cpp
new file mode 100644
index 0000000..74ca7dc
--- /dev/null
+++ b/media/libstagefright/APE.cpp
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) Texas Instruments - http://www.ti.com/
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "APE_TAG"
+#include <utils/Log.h>
+
+#include "include/APE.h"
+
+namespace android {
+
+APE::APE(){
+
+}
+
+APE::~APE(){
+
+}
+
+bool APE::isAPE(uint8_t *apeTag) const {
+    if(apeTag[0] == 'A' && apeTag[1] == 'P' && apeTag[2] == 'E' &&
+        apeTag[3] == 'T' && apeTag[4] == 'A' && apeTag[5] == 'G' &&
+        apeTag[6] == 'E' && apeTag[7] == 'X'){
+        return true;
+    }
+    return false;
+}
+
+size_t sizeItemKey(const sp<DataSource> &source, off64_t offset){
+    off64_t ItemKeyOffset = offset;
+    uint8_t keyTerminator = 0;
+    size_t keySize = 0;
+    while (keyTerminator != 0){
+        source->readAt(ItemKeyOffset, &keyTerminator, 1);
+        ItemKeyOffset++;
+        keySize++;
+    }
+    return keySize - 1;
+}
+
+bool APE::parseAPE(const sp<DataSource> &source, off64_t offset,
+        sp<MetaData> &meta){
+
+    struct Map {
+            int key;
+            const char *tag;
+    } const kMap[] = {
+            { kKeyAlbum, "Album" },
+            { kKeyArtist, "Artist" },
+            { kKeyAlbumArtist, "Album" },
+            { kKeyComposer, "Composer" },
+            { kKeyGenre, "Genre" },
+            { kKeyTitle, "Title" },
+            { kKeyYear, "Year" },
+            { kKeyCDTrackNumber, "Track" },
+            { kKeyDate, "Record Date"},
+    };
+
+    static const size_t kNumMapEntries = sizeof(kMap) / sizeof(kMap[0]);
+
+    off64_t headerOffset = offset;
+    headerOffset += 16;
+    itemNumber = 0;
+    if (source->readAt(headerOffset, &itemNumber, 1) == 0)
+        return false;
+
+    headerOffset += 16;
+
+    for(uint32_t it = 0; it < itemNumber; it++){
+        lenValue = 0;
+        if (source->readAt(headerOffset, &lenValue, 1) == 0)
+            return false;
+
+        headerOffset += 4;
+
+        itemFlags = 0;
+        if (source->readAt(headerOffset, &itemFlags, 1) == 0)
+            return false;
+
+        headerOffset += 4;
+
+        size_t sizeKey = sizeItemKey(source, headerOffset);
+
+        char *key = new char[sizeKey];
+
+        if (source->readAt(headerOffset, key, sizeKey) == 0)
+            return false;
+
+        key[sizeKey] = '\0';
+        headerOffset += sizeKey + 1;
+
+        char *val = new char[lenValue + 1];
+
+        if (source->readAt(headerOffset, val, lenValue) == 0)
+            return false;
+
+        val[lenValue] = '\0';
+
+        for (size_t i = 0; i < kNumMapEntries; i++){
+            if (!strcmp(key, kMap[i].tag)){
+                if (itemFlags == 0)
+                    meta->setCString(kMap[i].key, (const char *)val);
+                break;
+            }
+        }
+        headerOffset += lenValue;
+        delete[] key;
+        delete[] val;
+    }
+
+    return true;
+}
+} //namespace android
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index c56634e..6c16311 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -88,6 +88,7 @@ LOCAL_SRC_FILES:=                         \
         WVMExtractor.cpp                  \
         XINGSeeker.cpp                    \
         avc_utils.cpp                     \
+        APE.cpp                           \
 
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/ \
diff --git a/media/libstagefright/include/AACExtractor.h b/media/libstagefright/include/AACExtractor.h
index e98ca82..9a0ba2f 100644
--- a/media/libstagefright/include/AACExtractor.h
+++ b/media/libstagefright/include/AACExtractor.h
@@ -21,6 +21,7 @@
 #include <media/stagefright/MediaExtractor.h>
 
 #include <utils/Vector.h>
+#include "include/APE.h"
 
 namespace android {
 
@@ -48,6 +49,9 @@ private:
     Vector<uint64_t> mOffsetVector;
     int64_t mFrameDurationUs;
 
+    APE ape;
+    sp<MetaData> mApeMeta;
+
     AACExtractor(const AACExtractor &);
     AACExtractor &operator=(const AACExtractor &);
 };
diff --git a/media/libstagefright/include/APE.h b/media/libstagefright/include/APE.h
new file mode 100644
index 0000000..db49bb0
--- /dev/null
+++ b/media/libstagefright/include/APE.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) Texas Instruments - http://www.ti.com/
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef APE_TAG_H_
+
+#define APE_TAG_H_
+
+#include <utils/RefBase.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MetaData.h>
+
+namespace android {
+
+class APE{
+public:
+    APE();
+    ~APE();
+    bool isAPE(uint8_t *apeTag) const;
+    bool parseAPE(const sp<DataSource> &source, off64_t offset,
+            sp<MetaData> &meta);
+
+private:
+    uint32_t itemNumber;
+    uint32_t itemFlags;
+    size_t lenValue;
+};
+
+} //namespace android
+
+#endif //APE_TAG_H_
-- 
2.7.4


From 59960565998a4fd8af3ad0abfa09f66bfa17c887 Mon Sep 17 00:00:00 2001
From: Suresh Choudhary <sureshc@nvidia.com>
Date: Tue, 18 Mar 2014 17:24:15 +0530
Subject: [PATCH 003/119] libstagefright: Handle unsupported codec metaData

Modification done in StagefrightMetadataRetriver
to handle NULL return for meta data if codec is
unsupported by extractor.

Change-Id: I905cec5ee91b098d99e1935437b562d2d9206381
---
 media/libstagefright/StagefrightMetadataRetriever.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
index 45d22d5..7384c7b 100644
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -461,6 +461,10 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
     for (i = 0; i < n; ++i) {
         sp<MetaData> meta = mExtractor->getTrackMetaData(i);
 
+        if (meta == NULL) {
+            continue;
+        }
+
         const char *mime;
         CHECK(meta->findCString(kKeyMIMEType, &mime));
 
@@ -631,6 +635,10 @@ void StagefrightMetadataRetriever::parseMetaData() {
 
     size_t numTracks = mExtractor->countTracks();
 
+    if (numTracks == 0) {      //If no tracks available, corrupt or not valid stream
+        return;
+    }
+
     char tmp[32];
     sprintf(tmp, "%zu", numTracks);
 
@@ -654,6 +662,9 @@ void StagefrightMetadataRetriever::parseMetaData() {
     String8 timedTextLang;
     for (size_t i = 0; i < numTracks; ++i) {
         sp<MetaData> trackMeta = mExtractor->getTrackMetaData(i);
+        if (trackMeta == NULL) {
+            continue;
+        }
 
         int64_t durationUs;
         if (trackMeta->findInt64(kKeyDuration, &durationUs)) {
-- 
2.7.4


From 1b43f2bb8324022575ffda360dcb26caa55f273b Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Wed, 8 Jul 2015 09:56:01 -0700
Subject: [PATCH 004/119] stagefright: Add support for loading a custom
 OMXPlugin

 * To facilitate moving the stagefright-plugins glue out of the
   framework, support is added to OMXMaster to load multiple
   external plugins besides internal/vendor versions.
 * This is currently limited to one plugin, defined by the
   "mm.sf.omx-plugin" system property. The code will allow any
   number of libraries to be loaded, though.
 * Should also be useful for nonstandard vendor implementations too.

Change-Id: I27d7e16ad56baa17754d8ea47a8c608a0d73d6f1
---
 media/libstagefright/omx/OMXMaster.cpp     | 67 +++++++++++++++++++-----------
 media/libstagefright/omx/OMXMaster.h       |  7 ++--
 media/libstagefright/omx/SoftOMXPlugin.cpp |  6 ++-
 3 files changed, 50 insertions(+), 30 deletions(-)

diff --git a/media/libstagefright/omx/OMXMaster.cpp b/media/libstagefright/omx/OMXMaster.cpp
index ae3cb33..f7bb733 100644
--- a/media/libstagefright/omx/OMXMaster.cpp
+++ b/media/libstagefright/omx/OMXMaster.cpp
@@ -25,52 +25,58 @@
 #include <dlfcn.h>
 
 #include <media/stagefright/foundation/ADebug.h>
+#include <cutils/properties.h>
 
 namespace android {
 
-OMXMaster::OMXMaster()
-    : mVendorLibHandle(NULL) {
+OMXMaster::OMXMaster() {
     addVendorPlugin();
     addPlugin(new SoftOMXPlugin);
+    addUserPlugin();
 }
 
 OMXMaster::~OMXMaster() {
     clearPlugins();
-
-    if (mVendorLibHandle != NULL) {
-        dlclose(mVendorLibHandle);
-        mVendorLibHandle = NULL;
-    }
 }
 
 void OMXMaster::addVendorPlugin() {
     addPlugin("libstagefrighthw.so");
 }
 
+void OMXMaster::addUserPlugin() {
+    char plugin[PROPERTY_VALUE_MAX];
+    if (property_get("media.sf.omx-plugin", plugin, NULL)) {
+        addPlugin(plugin);
+    }
+}
+
 void OMXMaster::addPlugin(const char *libname) {
-    mVendorLibHandle = dlopen(libname, RTLD_NOW);
+    void* handle = dlopen(libname, RTLD_NOW);
 
-    if (mVendorLibHandle == NULL) {
+    if (handle == NULL) {
         return;
     }
 
     typedef OMXPluginBase *(*CreateOMXPluginFunc)();
     CreateOMXPluginFunc createOMXPlugin =
         (CreateOMXPluginFunc)dlsym(
-                mVendorLibHandle, "createOMXPlugin");
+                handle, "createOMXPlugin");
     if (!createOMXPlugin)
         createOMXPlugin = (CreateOMXPluginFunc)dlsym(
-                mVendorLibHandle, "_ZN7android15createOMXPluginEv");
+                handle, "_ZN7android15createOMXPluginEv");
 
     if (createOMXPlugin) {
-        addPlugin((*createOMXPlugin)());
+        addPlugin((*createOMXPlugin)(), handle);
     }
 }
 
-void OMXMaster::addPlugin(OMXPluginBase *plugin) {
+void OMXMaster::addPlugin(OMXPluginBase *plugin, void *handle) {
+    if (plugin == 0) {
+       return;
+    }
     Mutex::Autolock autoLock(mLock);
 
-    mPlugins.push_back(plugin);
+    mPlugins.add(plugin, handle);
 
     OMX_U32 index = 0;
 
@@ -100,21 +106,32 @@ void OMXMaster::clearPlugins() {
     Mutex::Autolock autoLock(mLock);
 
     typedef void (*DestroyOMXPluginFunc)(OMXPluginBase*);
-    DestroyOMXPluginFunc destroyOMXPlugin =
-        (DestroyOMXPluginFunc)dlsym(
-                mVendorLibHandle, "destroyOMXPlugin");
 
-    mPluginByComponentName.clear();
+    for (unsigned int i = 0; i < mPlugins.size(); i++) {
+        OMXPluginBase *plugin = mPlugins.keyAt(i);
+        if (plugin != NULL) {
+            void *handle = mPlugins.valueAt(i);
+
+            if (handle != NULL) {
+                DestroyOMXPluginFunc destroyOMXPlugin =
+                    (DestroyOMXPluginFunc)dlsym(
+                            handle, "destroyOMXPlugin");
+
+                if (destroyOMXPlugin)
+                    destroyOMXPlugin(plugin);
+                else
+                    delete plugin;
 
-    for (List<OMXPluginBase *>::iterator it = mPlugins.begin();
-            it != mPlugins.end(); ++it) {
-        if (destroyOMXPlugin)
-            destroyOMXPlugin(*it);
-        else
-            delete *it;
-        *it = NULL;
+                dlclose(handle);
+            } else {
+                delete plugin;
+            }
+
+            plugin = NULL;
+        }
     }
 
+    mPluginByComponentName.clear();
     mPlugins.clear();
 }
 
diff --git a/media/libstagefright/omx/OMXMaster.h b/media/libstagefright/omx/OMXMaster.h
index 6069741..c07fed3 100644
--- a/media/libstagefright/omx/OMXMaster.h
+++ b/media/libstagefright/omx/OMXMaster.h
@@ -51,15 +51,14 @@ struct OMXMaster : public OMXPluginBase {
 
 private:
     Mutex mLock;
-    List<OMXPluginBase *> mPlugins;
+    KeyedVector<OMXPluginBase *, void *> mPlugins;
     KeyedVector<String8, OMXPluginBase *> mPluginByComponentName;
     KeyedVector<OMX_COMPONENTTYPE *, OMXPluginBase *> mPluginByInstance;
 
-    void *mVendorLibHandle;
-
     void addVendorPlugin();
+    void addUserPlugin();
     void addPlugin(const char *libname);
-    void addPlugin(OMXPluginBase *plugin);
+    void addPlugin(OMXPluginBase *plugin, void *handle = NULL);
     void clearPlugins();
 
     OMXMaster(const OMXMaster &);
diff --git a/media/libstagefright/omx/SoftOMXPlugin.cpp b/media/libstagefright/omx/SoftOMXPlugin.cpp
index 13605a7..3ee4bf8 100755
--- a/media/libstagefright/omx/SoftOMXPlugin.cpp
+++ b/media/libstagefright/omx/SoftOMXPlugin.cpp
@@ -122,6 +122,7 @@ OMX_ERRORTYPE SoftOMXPlugin::makeComponentInstance(
         OMX_COMPONENTTYPE **component) {
     ALOGV("makeComponentInstance '%s'", name);
 
+    dlerror(); // clear any existing error
     for (size_t i = 0; i < kNumComponents; ++i) {
         if (strcmp(name, kComponents[i].mName)) {
             continue;
@@ -139,6 +140,8 @@ OMX_ERRORTYPE SoftOMXPlugin::makeComponentInstance(
             return OMX_ErrorComponentNotFound;
         }
 
+        ALOGV("load component %s for %s", libName.c_str(), name);
+
         typedef SoftOMXComponent *(*CreateSoftOMXComponentFunc)(
                 const char *, const OMX_CALLBACKTYPE *,
                 OMX_PTR, OMX_COMPONENTTYPE **);
@@ -149,7 +152,8 @@ OMX_ERRORTYPE SoftOMXPlugin::makeComponentInstance(
                     "_Z22createSoftOMXComponentPKcPK16OMX_CALLBACKTYPE"
                     "PvPP17OMX_COMPONENTTYPE");
 
-        if (createSoftOMXComponent == NULL) {
+        if (const char *error = dlerror()) {
+            ALOGE("unable to dlsym %s: %s", libName.c_str(), error);
             dlclose(libHandle);
             libHandle = NULL;
 
-- 
2.7.4


From f94a36353d4538e1deed6eb3165e87c2987f548b Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Fri, 28 Nov 2014 23:26:30 -0800
Subject: [PATCH 005/119] stagefright: Improve FLAC and WAV support for 24-bit

 * Forward-port changes from CM11
 * Remove truncation support as AudioFlinger handles
   rebuffering in case it can't go to the hardware.

Change-Id: Iad30d04ee051050e444c3d665fa8bb7a1cfef348
---
 media/libstagefright/FLACExtractor.cpp | 182 ++++++++++-----------------------
 media/libstagefright/WAVExtractor.cpp  |  56 +++++-----
 2 files changed, 88 insertions(+), 150 deletions(-)

diff --git a/media/libstagefright/FLACExtractor.cpp b/media/libstagefright/FLACExtractor.cpp
index c79180b..87345e1 100644
--- a/media/libstagefright/FLACExtractor.cpp
+++ b/media/libstagefright/FLACExtractor.cpp
@@ -32,6 +32,13 @@
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MediaBuffer.h>
 
+#ifdef ENABLE_AV_ENHANCEMENTS
+#include "QCMediaDefs.h"
+#include "QCMetaData.h"
+#endif
+
+#include <system/audio.h>
+
 namespace android {
 
 class FLACParser;
@@ -72,6 +79,8 @@ private:
 
 class FLACParser : public RefBase {
 
+friend class FLACSource;
+
 public:
     FLACParser(
         const sp<DataSource> &dataSource,
@@ -103,6 +112,8 @@ public:
     // media buffers
     void allocateBuffers();
     void releaseBuffers();
+    void copyBuffer(short *dst, const int *const *src, unsigned nSamples);
+
     MediaBuffer *readBuffer() {
         return readBuffer(false, 0LL);
     }
@@ -113,6 +124,7 @@ public:
 protected:
     virtual ~FLACParser();
 
+
 private:
     sp<DataSource> mDataSource;
     sp<MetaData> mFileMetadata;
@@ -122,7 +134,6 @@ private:
     // media buffers
     size_t mMaxBufferSize;
     MediaBufferGroup *mGroup;
-    void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);
 
     // handle to underlying libFLAC parser
     FLAC__StreamDecoder *mDecoder;
@@ -377,109 +388,41 @@ void FLACParser::errorCallback(FLAC__StreamDecoderErrorStatus status)
     mErrorStatus = status;
 }
 
-// Copy samples from FLAC native 32-bit non-interleaved to 16-bit interleaved.
-// These are candidates for optimization if needed.
-
-static void copyMono8(
-        short *dst,
-        const int *const *src,
-        unsigned nSamples,
-        unsigned /* nChannels */) {
-    for (unsigned i = 0; i < nSamples; ++i) {
-        *dst++ = src[0][i] << 8;
-    }
-}
-
-static void copyStereo8(
-        short *dst,
-        const int *const *src,
-        unsigned nSamples,
-        unsigned /* nChannels */) {
-    for (unsigned i = 0; i < nSamples; ++i) {
-        *dst++ = src[0][i] << 8;
-        *dst++ = src[1][i] << 8;
-    }
-}
-
-static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
+void FLACParser::copyBuffer(short *dst, const int *const *src, unsigned nSamples)
 {
-    for (unsigned i = 0; i < nSamples; ++i) {
-        for (unsigned c = 0; c < nChannels; ++c) {
-            *dst++ = src[c][i] << 8;
-        }
-    }
-}
-
-static void copyMono16(
-        short *dst,
-        const int *const *src,
-        unsigned nSamples,
-        unsigned /* nChannels */) {
-    for (unsigned i = 0; i < nSamples; ++i) {
-        *dst++ = src[0][i];
-    }
-}
-
-static void copyStereo16(
-        short *dst,
-        const int *const *src,
-        unsigned nSamples,
-        unsigned /* nChannels */) {
-    for (unsigned i = 0; i < nSamples; ++i) {
-        *dst++ = src[0][i];
-        *dst++ = src[1][i];
-    }
-}
-
-static void copyMultiCh16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
-{
-    for (unsigned i = 0; i < nSamples; ++i) {
-        for (unsigned c = 0; c < nChannels; ++c) {
-            *dst++ = src[c][i];
-        }
-    }
-}
-
-// 24-bit versions should do dithering or noise-shaping, here or in AudioFlinger
-
-static void copyMono24(
-        short *dst,
-        const int *const *src,
-        unsigned nSamples,
-        unsigned /* nChannels */) {
-    for (unsigned i = 0; i < nSamples; ++i) {
-        *dst++ = src[0][i] >> 8;
-    }
-}
-
-static void copyStereo24(
-        short *dst,
-        const int *const *src,
-        unsigned nSamples,
-        unsigned /* nChannels */) {
-    for (unsigned i = 0; i < nSamples; ++i) {
-        *dst++ = src[0][i] >> 8;
-        *dst++ = src[1][i] >> 8;
-    }
-}
-
-static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
-{
-    for (unsigned i = 0; i < nSamples; ++i) {
-        for (unsigned c = 0; c < nChannels; ++c) {
-            *dst++ = src[c][i] >> 8;
+    unsigned int nChannels = getChannels();
+    unsigned int nBits = getBitsPerSample();
+    switch (nBits) {
+        case 8:
+            for (unsigned i = 0; i < nSamples; ++i) {
+                for (unsigned c = 0; c < nChannels; ++c) {
+                    *dst++ = src[c][i] << 8;
+                }
+            }
+            break;
+        case 16:
+            for (unsigned i = 0; i < nSamples; ++i) {
+                for (unsigned c = 0; c < nChannels; ++c) {
+                    *dst++ = src[c][i];
+                }
+            }
+            break;
+        case 24:
+        case 32:
+        {
+            int32_t *out = (int32_t *)dst;
+            for (unsigned i = 0; i < nSamples; ++i) {
+                for (unsigned c = 0; c < nChannels; ++c) {
+                    *out++ = src[c][i] << 8;
+                }
+            }
+            break;
         }
+        default:
+            TRESPASS();
     }
 }
 
-static void copyTrespass(
-        short * /* dst */,
-        const int *const * /* src */,
-        unsigned /* nSamples */,
-        unsigned /* nChannels */) {
-    TRESPASS();
-}
-
 // FLACParser
 
 FLACParser::FLACParser(
@@ -492,7 +435,6 @@ FLACParser::FLACParser(
       mInitCheck(false),
       mMaxBufferSize(0),
       mGroup(NULL),
-      mCopy(copyTrespass),
       mDecoder(NULL),
       mCurrentPos(0LL),
       mEOF(false),
@@ -571,6 +513,8 @@ status_t FLACParser::init()
         }
         // check sample rate
         switch (getSampleRate()) {
+        case   100:
+        case  1000:
         case  8000:
         case 11025:
         case 12000:
@@ -578,38 +522,18 @@ status_t FLACParser::init()
         case 22050:
         case 24000:
         case 32000:
+        case 42000:
         case 44100:
+        case 46000:
         case 48000:
         case 88200:
         case 96000:
+        case 192000:
             break;
         default:
             ALOGE("unsupported sample rate %u", getSampleRate());
             return NO_INIT;
         }
-        // configure the appropriate copy function, defaulting to trespass
-        static const struct {
-            unsigned mChannels;
-            unsigned mBitsPerSample;
-            void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);
-        } table[] = {
-            { 1,  8, copyMono8    },
-            { 2,  8, copyStereo8  },
-            { 8,  8, copyMultiCh8  },
-            { 1, 16, copyMono16   },
-            { 2, 16, copyStereo16 },
-            { 8, 16, copyMultiCh16 },
-            { 1, 24, copyMono24   },
-            { 2, 24, copyStereo24 },
-            { 8, 24, copyMultiCh24 },
-        };
-        for (unsigned i = 0; i < sizeof(table)/sizeof(table[0]); ++i) {
-            if (table[i].mChannels >= getChannels() &&
-                    table[i].mBitsPerSample == getBitsPerSample()) {
-                mCopy = table[i].mCopy;
-                break;
-            }
-        }
         // populate track metadata
         if (mTrackMetadata != 0) {
             mTrackMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
@@ -618,6 +542,7 @@ status_t FLACParser::init()
             // sample rate is non-zero, so division by zero not possible
             mTrackMetadata->setInt64(kKeyDuration,
                     (getTotalSamples() * 1000000LL) / getSampleRate());
+            mTrackMetadata->setInt32(kKeyBitsPerSample, getBitsPerSample());
         }
     } else {
         ALOGE("missing STREAMINFO");
@@ -633,7 +558,9 @@ void FLACParser::allocateBuffers()
 {
     CHECK(mGroup == NULL);
     mGroup = new MediaBufferGroup;
-    mMaxBufferSize = getMaxBlockSize() * getChannels() * sizeof(short);
+    // allocate enough to hold 24-bits (packed in 32 bits)
+    unsigned int bytesPerSample = getBitsPerSample() > 16 ? 4 : 2;
+    mMaxBufferSize = getMaxBlockSize() * getChannels() * bytesPerSample;
     mGroup->add_buffer(new MediaBuffer(mMaxBufferSize));
 }
 
@@ -686,12 +613,12 @@ MediaBuffer *FLACParser::readBuffer(bool doSeek, FLAC__uint64 sample)
     if (err != OK) {
         return NULL;
     }
-    size_t bufferSize = blocksize * getChannels() * sizeof(short);
+    size_t bufferSize = blocksize * getChannels() * (getBitsPerSample() > 16 ? 4 : 2);
     CHECK(bufferSize <= mMaxBufferSize);
     short *data = (short *) buffer->data();
     buffer->set_range(0, bufferSize);
     // copy PCM from FLAC write buffer to our media buffer, with interleaving
-    (*mCopy)(data, mWriteBuffer, blocksize, getChannels());
+    copyBuffer(data, mWriteBuffer, blocksize);
     // fill in buffer metadata
     CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
     FLAC__uint64 sampleNumber = mWriteHeader.number.sample_number;
@@ -726,9 +653,10 @@ FLACSource::~FLACSource()
 
 status_t FLACSource::start(MetaData * /* params */)
 {
+    CHECK(!mStarted);
+
     ALOGV("FLACSource::start");
 
-    CHECK(!mStarted);
     mParser->allocateBuffers();
     mStarted = true;
 
diff --git a/media/libstagefright/WAVExtractor.cpp b/media/libstagefright/WAVExtractor.cpp
index 51d639d..858d91c 100644
--- a/media/libstagefright/WAVExtractor.cpp
+++ b/media/libstagefright/WAVExtractor.cpp
@@ -29,6 +29,7 @@
 #include <media/stagefright/MetaData.h>
 #include <utils/String8.h>
 #include <cutils/bitops.h>
+#include <system/audio.h>
 
 #define CHANNEL_MASK_USE_CHANNEL_ORDER 0
 
@@ -286,6 +287,7 @@ status_t WAVExtractor::init() {
                     case WAVE_FORMAT_PCM:
                         mTrackMeta->setCString(
                                 kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+                        mTrackMeta->setInt32(kKeyBitsPerSample, mBitsPerSample);
                         break;
                     case WAVE_FORMAT_ALAW:
                         mTrackMeta->setCString(
@@ -369,15 +371,16 @@ WAVSource::~WAVSource() {
 }
 
 status_t WAVSource::start(MetaData * /* params */) {
-    ALOGV("WAVSource::start");
 
-    CHECK(!mStarted);
+    if (mStarted) {
+        return OK;
+    }
 
     mGroup = new MediaBufferGroup;
     mGroup->add_buffer(new MediaBuffer(kMaxFrameSize));
 
-    if (mBitsPerSample == 8) {
-        // As a temporary buffer for 8->16 bit conversion.
+    if (mBitsPerSample == 8 || mBitsPerSample == 24) {
+        // As a temporary buffer for 8->16/24->32 bit conversion.
         mGroup->add_buffer(new MediaBuffer(kMaxFrameSize));
     }
 
@@ -437,9 +440,15 @@ status_t WAVSource::read(
     }
 
     // make sure that maxBytesToRead is multiple of 3, in 24-bit case
-    size_t maxBytesToRead =
-        mBitsPerSample == 8 ? kMaxFrameSize / 2 : 
-        (mBitsPerSample == 24 ? 3*(kMaxFrameSize/3): kMaxFrameSize);
+    size_t maxBytesToRead;
+    if(8 == mBitsPerSample)
+        maxBytesToRead = kMaxFrameSize / 2;
+    else if (24 == mBitsPerSample) {
+        maxBytesToRead = 3*(kMaxFrameSize/4);
+    } else
+        maxBytesToRead = kMaxFrameSize;
+    ALOGV("%s mBitsPerSample %d, kMaxFrameSize %d, ",
+          __func__, mBitsPerSample, kMaxFrameSize);
 
     size_t maxBytesAvailable =
         (mCurrentPos - mOffset >= (off64_t)mSize)
@@ -498,23 +507,24 @@ status_t WAVSource::read(
             buffer->release();
             buffer = tmp;
         } else if (mBitsPerSample == 24) {
-            // Convert 24-bit signed samples to 16-bit signed.
-
-            const uint8_t *src =
-                (const uint8_t *)buffer->data() + buffer->range_offset();
-            int16_t *dst = (int16_t *)src;
-
-            size_t numSamples = buffer->range_length() / 3;
-            for (size_t i = 0; i < numSamples; ++i) {
-                int32_t x = (int32_t)(src[0] | src[1] << 8 | src[2] << 16);
-                x = (x << 8) >> 8;  // sign extension
-
-                x = x >> 8;
-                *dst++ = (int16_t)x;
-                src += 3;
+            // Padding done here to convert to 32-bit samples
+            MediaBuffer *tmp;
+            CHECK_EQ(mGroup->acquire_buffer(&tmp), (status_t)OK);
+            ssize_t numBytes = buffer->range_length() / 3;
+            tmp->set_range(0, 4 * numBytes);
+            int8_t *dst = (int8_t *)tmp->data();
+            const uint8_t *src = (const uint8_t *)buffer->data();
+            ALOGV("numBytes = %d", numBytes);
+            while(numBytes-- > 0) {
+               *dst++ = 0x0;
+               *dst++ = src[0];
+               *dst++ = src[1];
+               *dst++ = src[2];
+               src += 3;
             }
-
-            buffer->set_range(buffer->range_offset(), 2 * numSamples);
+            buffer->release();
+            buffer = tmp;
+            ALOGV("length = %d", buffer->range_length());
         }
     }
 
-- 
2.7.4


From ba48915267253f3ba6b942354a0bc4a20c019e9e Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 17 Oct 2015 19:30:49 -0700
Subject: [PATCH 006/119] stagefright: Support MP3 in MPEG4 containers

Change-Id: I8e13a68cc10fafc43dd8f7d350644c7638d5d5e3
---
 media/libstagefright/MPEG4Extractor.cpp | 30 +++++++++++++++++++++---------
 1 file changed, 21 insertions(+), 9 deletions(-)

diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 8e6ec14..34e60db 100755
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -363,6 +363,9 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('m', 'p', '4', 'a'):
             return MEDIA_MIMETYPE_AUDIO_AAC;
 
+        case FOURCC('.', 'm', 'p', '3'):
+            return MEDIA_MIMETYPE_AUDIO_MPEG;
+
         case FOURCC('s', 'a', 'm', 'r'):
             return MEDIA_MIMETYPE_AUDIO_AMR_NB;
 
@@ -919,7 +922,7 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             && chunk_type != FOURCC('c', 'o', 'v', 'r')
             && mPath.size() == 5 && underMetaDataPath(mPath)) {
         off64_t stop_offset = *offset + chunk_size;
-        *offset = data_offset;
+        *offset = stop_offset;
         while (*offset < stop_offset) {
             status_t err = parseChunk(offset, depth + 1);
             if (err != OK) {
@@ -1461,7 +1464,14 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);
 
             off64_t stop_offset = *offset + chunk_size;
-            *offset = data_offset + sizeof(buffer);
+            if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_MPEG, FourCC2MIME(chunk_type)) ||
+                !strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_WB, FourCC2MIME(chunk_type))) {
+                // ESD is not required in mp3
+                // amr wb with damr atom corrupted can cause the clip to not play
+               *offset = stop_offset;
+            } else {
+               *offset = data_offset + sizeof(buffer);
+            }
             while (*offset < stop_offset) {
                 status_t err = parseChunk(offset, depth + 1);
                 if (err != OK) {
@@ -3196,12 +3206,12 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         return OK;
     }
 
-    if (objectTypeIndication  == 0x6b) {
-        // The media subtype is MP3 audio
-        // Our software MP3 audio decoder may not be able to handle
-        // packetized MP3 audio; for now, lets just return ERROR_UNSUPPORTED
-        ALOGE("MP3 track in MP4/3GPP file is not supported");
-        return ERROR_UNSUPPORTED;
+    if (objectTypeIndication  == 0x6b
+         || objectTypeIndication  == 0x69) {
+         // This is mpeg1/2 audio content, set mimetype to mpeg
+         mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
+         ALOGD("objectTypeIndication:0x%x, set mimetype to mpeg ",objectTypeIndication);
+         return OK;
     }
 
     const uint8_t *csd;
@@ -4850,7 +4860,9 @@ static bool LegacySniffMPEG4(
         return false;
     }
 
-    if (!memcmp(header, "ftyp3gp", 7) || !memcmp(header, "ftypmp42", 8)
+    if (!memcmp(header, "ftyp3g2a", 8) || !memcmp(header, "ftyp3g2b", 8)
+        || !memcmp(header, "ftyp3g2c", 8)
+        || !memcmp(header, "ftyp3gp", 7) || !memcmp(header, "ftypmp42", 8)
         || !memcmp(header, "ftyp3gr6", 8) || !memcmp(header, "ftyp3gs6", 8)
         || !memcmp(header, "ftyp3ge6", 8) || !memcmp(header, "ftyp3gg6", 8)
         || !memcmp(header, "ftypisom", 8) || !memcmp(header, "ftypM4V ", 8)
-- 
2.7.4


From ce9333f7a90d828271ab33caced7e6955b6f08fa Mon Sep 17 00:00:00 2001
From: Surajit Podder <spodder@codeaurora.org>
Date: Thu, 23 Jan 2014 13:24:34 +0530
Subject: [PATCH 007/119] DataSource: Remove global variables in DataSource
 related to sniff

Remove global variables related to sniff, and added Sniffer class
to implement the sniff functionality with non-static members.

Change-Id: I6fbd0ba5b686e09fda11d78cdd687a69c81a6bdf
CRs-Fixed: 567753
---
 include/media/stagefright/DataSource.h | 38 +++++++++++++--
 media/libstagefright/DataSource.cpp    | 86 +++++++++++++++++++---------------
 2 files changed, 80 insertions(+), 44 deletions(-)

diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index a48d26e..4032793 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -36,6 +36,37 @@ class  IDataSource;
 struct IMediaHTTPService;
 class String8;
 struct HTTPBase;
+class DataSource;
+
+class Sniffer : public RefBase {
+public:
+    Sniffer();
+
+    ////////////////////////////////////////////////////////////////////////////
+
+    bool sniff(DataSource *source, String8 *mimeType, float *confidence, sp<AMessage> *meta);
+
+    // The sniffer can optionally fill in "meta" with an AMessage containing
+    // a dictionary of values that helps the corresponding extractor initialize
+    // its state without duplicating effort already exerted by the sniffer.
+    typedef bool (*SnifferFunc)(
+            const sp<DataSource> &source, String8 *mimeType,
+            float *confidence, sp<AMessage> *meta);
+
+    //if isExtendedExtractor = true, store the location of the sniffer to register
+    void registerSniffer_l(SnifferFunc func);
+    void registerDefaultSniffers();
+
+    virtual ~Sniffer() {}
+
+private:
+    Mutex mSnifferMutex;
+    List<SnifferFunc> mSniffers;
+    List<SnifferFunc>::iterator extendedSnifferPosition;
+
+    Sniffer(const Sniffer &);
+    Sniffer &operator=(const Sniffer &);
+};
 
 class DataSource : public RefBase {
 public:
@@ -57,7 +88,7 @@ public:
     static sp<DataSource> CreateMediaHTTP(const sp<IMediaHTTPService> &httpService);
     static sp<DataSource> CreateFromIDataSource(const sp<IDataSource> &source);
 
-    DataSource() {}
+    DataSource() : mSniffer(new Sniffer()) {}
 
     virtual status_t initCheck() const = 0;
 
@@ -125,10 +156,7 @@ public:
 protected:
     virtual ~DataSource() {}
 
-private:
-    static Mutex gSnifferMutex;
-    static List<SnifferFunc> gSniffers;
-    static bool gSniffersRegistered;
+    sp<Sniffer> mSniffer;
 
     static void RegisterSniffer_l(SnifferFunc func);
 
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index b5e7a6e..f650ea2 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -112,29 +112,42 @@ status_t DataSource::getSize(off64_t *size) {
 
 ////////////////////////////////////////////////////////////////////////////////
 
-Mutex DataSource::gSnifferMutex;
-List<DataSource::SnifferFunc> DataSource::gSniffers;
-bool DataSource::gSniffersRegistered = false;
-
 bool DataSource::sniff(
         String8 *mimeType, float *confidence, sp<AMessage> *meta) {
+
+    return  mSniffer->sniff(this, mimeType, confidence, meta);
+}
+
+// static
+void DataSource::RegisterSniffer_l(SnifferFunc func) {
+    return;
+}
+
+// static
+void DataSource::RegisterDefaultSniffers() {
+    return;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+Sniffer::Sniffer() {
+    registerDefaultSniffers();
+}
+
+bool Sniffer::sniff(
+        DataSource *source, String8 *mimeType, float *confidence, sp<AMessage> *meta) {
+
     *mimeType = "";
     *confidence = 0.0f;
     meta->clear();
 
-    {
-        Mutex::Autolock autoLock(gSnifferMutex);
-        if (!gSniffersRegistered) {
-            return false;
-        }
-    }
-
-    for (List<SnifferFunc>::iterator it = gSniffers.begin();
-         it != gSniffers.end(); ++it) {
+    Mutex::Autolock autoLock(mSnifferMutex);
+    for (List<SnifferFunc>::iterator it = mSniffers.begin();
+         it != mSniffers.end(); ++it) {
         String8 newMimeType;
         float newConfidence;
         sp<AMessage> newMeta;
-        if ((*it)(this, &newMimeType, &newConfidence, &newMeta)) {
+        if ((*it)(source, &newMimeType, &newConfidence, &newMeta)) {
             if (newConfidence > *confidence) {
                 *mimeType = newMimeType;
                 *confidence = newConfidence;
@@ -146,45 +159,40 @@ bool DataSource::sniff(
     return *confidence > 0.0;
 }
 
-// static
-void DataSource::RegisterSniffer_l(SnifferFunc func) {
-    for (List<SnifferFunc>::iterator it = gSniffers.begin();
-         it != gSniffers.end(); ++it) {
+void Sniffer::registerSniffer_l(SnifferFunc func) {
+
+    for (List<SnifferFunc>::iterator it = mSniffers.begin();
+         it != mSniffers.end(); ++it) {
         if (*it == func) {
             return;
         }
     }
 
-    gSniffers.push_back(func);
+    mSniffers.push_back(func);
 }
 
-// static
-void DataSource::RegisterDefaultSniffers() {
-    Mutex::Autolock autoLock(gSnifferMutex);
-    if (gSniffersRegistered) {
-        return;
-    }
-
-    RegisterSniffer_l(SniffMPEG4);
-    RegisterSniffer_l(SniffMatroska);
-    RegisterSniffer_l(SniffOgg);
-    RegisterSniffer_l(SniffWAV);
-    RegisterSniffer_l(SniffFLAC);
-    RegisterSniffer_l(SniffAMR);
-    RegisterSniffer_l(SniffMPEG2TS);
-    RegisterSniffer_l(SniffMP3);
-    RegisterSniffer_l(SniffAAC);
-    RegisterSniffer_l(SniffMPEG2PS);
-    RegisterSniffer_l(SniffWVM);
+void Sniffer::registerDefaultSniffers() {
+    Mutex::Autolock autoLock(mSnifferMutex);
+
+    registerSniffer_l(SniffMPEG4);
+    registerSniffer_l(SniffMatroska);
+    registerSniffer_l(SniffOgg);
+    registerSniffer_l(SniffWAV);
+    registerSniffer_l(SniffFLAC);
+    registerSniffer_l(SniffAMR);
+    registerSniffer_l(SniffMPEG2TS);
+    registerSniffer_l(SniffMP3);
+    registerSniffer_l(SniffAAC);
+    registerSniffer_l(SniffMPEG2PS);
+    registerSniffer_l(SniffWVM);
     RegisterSniffer_l(SniffMidi);
     RegisterSniffer_l(AVUtils::get()->getExtendedSniffer());
 
     char value[PROPERTY_VALUE_MAX];
     if (property_get("drm.service.enabled", value, NULL)
             && (!strcmp(value, "1") || !strcasecmp(value, "true"))) {
-        RegisterSniffer_l(SniffDRM);
+        registerSniffer_l(SniffDRM);
     }
-    gSniffersRegistered = true;
 }
 
 // static
-- 
2.7.4


From a2df9c4f7541f21267dc1f0b571f4c3eda72e285 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 29 Nov 2014 11:43:23 -0800
Subject: [PATCH 008/119] stagefright: Support HEVC tracks in Matroska
 containers

 * Pass the HVCC atom to Stagefright.

Change-Id: I7fdca25e20b9051925936a34e594808b18a3a3bd
---
 media/libstagefright/matroska/MatroskaExtractor.cpp | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
index 7202282..5746203 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -244,13 +244,12 @@ MatroskaSource::MatroskaSource(
         mType = HEVC;
 
         uint32_t type;
-        const void *data;
+        const uint8_t *data;
         size_t size;
-        CHECK(meta->findData(kKeyHVCC, &type, &data, &size));
+        CHECK(meta->findData(kKeyHVCC, &type, (const void **)&data, &size));
 
-        const uint8_t *ptr = (const uint8_t *)data;
         CHECK(size >= 7);
-        mNALSizeLen = 1 + (ptr[14 + 7] & 3);
+        mNALSizeLen = 1 + (data[14 + 7] & 3);
         ALOGV("mNALSizeLen = %zu", mNALSizeLen);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
         mType = AAC;
@@ -1041,7 +1040,7 @@ void MatroskaExtractor::addTracks() {
                     }
                 } else if (!strcmp("V_MPEGH/ISO/HEVC", codecID)) {
                     meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_HEVC);
-                    meta->setData(kKeyHVCC, 0, codecPrivate, codecPrivateSize);
+                    meta->setData(kKeyHVCC, kTypeHVCC, codecPrivate, codecPrivateSize);
 
                 } else if (!strcmp("V_VP8", codecID)) {
                     meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_VP8);
@@ -1064,7 +1063,9 @@ void MatroskaExtractor::addTracks() {
 
                 if (!strcmp("A_AAC", codecID)) {
                     meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC);
-                    CHECK(codecPrivateSize >= 2);
+                    if (codecPrivateSize < 2) {
+                        return;
+                    }
 
                     addESDSFromCodecPrivate(
                             meta, true, codecPrivate, codecPrivateSize);
-- 
2.7.4


From 4c5f6e285df0be84282689563816e19bc3929e4c Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 25 Jul 2013 17:33:47 +0800
Subject: [PATCH 009/119] libstagefright: Extended media support via FFMPEG

 * Original work by Michael Chen - https://github.com/omxcodec
 * Kitkat port by Chih-Wei Huang / Android X86 project
 * Additional fixes by Arcee and Cyanogen
 * High resolution support by Cyanogen
 * Lollipop port and refactoring by Cyanogen
 * Marshmallow port and refactoring by Cyanogen

------

libstagefright: add null checking to addPlugin

libstagefright: fix error handling of dlsym()

According 'man dlsym', a NULL return from dlsym() doesn't indicate an error.
The correct way to test for an error is to call dlerror() to clear any old
error conditions, then call dlsym(), and then call dlerror() again to check
whether its return value is not NULL.

libstagefright: add more media mimetypes

This is the first step to add the ffmpeg plugins.

libstagefright: add ExtractorPlugin

The patch allows to load an ExtractorPlugin to extend the functions of
DataSource::sniff and MediaExtractor. A plugin has to implement a C
function getExtractorPlugin to fill the MediaExtractor::Plugin struct.

The filename of the plugin could be specified by the
media.stagefright.extractor-plugin property.

Change-Id: I995a37a4f1ab4bba6ca3c24c7001a27a1e3ccb90

FLACExtractor: Add more sample rates support

In FLACExtractor.cpp, it has function to check file's sample rate.
If the input sample rate is not in its list, it will return "unsupported
sample rate" issue. Modify code to make other sample rates (100,1k,42k,46k)
pass the check

Issue: AXIA-1441
Change-Id: I48f91119275560ec6d00feb0dedc70d10aa55262
Signed-off-by: Xiaobing Feng <xiaobing.feng@windriver.com>
Signed-off-by: Matt Gumbel <matthew.k.gumbel@intel.com>

libstagefright: add ffmpeg components

libstagefright: add more decoders

Add support for wma, wmv, ra, ape, dts decoders.

Change-Id: Iaf48a806aa0cef7d9bcb848383fc3d778c8bd248

libstagefright: allow to use the extended extractor in priority

If the meta contains the string "extended-extractor-use",
use the extended extractor first.

add support for rv20, rv30

add ffmpeg heuristic decoder

Change-Id: I5eed11b563ca7f15d44bacfb795d6f3da08ab883

add HEVC(H.265) decoder and cleanup

Squashed the following commits of branch cm_maguro-10.1 from
https://github.com/omxcodec/android_frameworks_av.git
by Michael Chen <omxcodec@gmail.com>

defb904 remove MEDIA_MIMETYPE_AUDIO_MP2
8036958 add fetchUriFromFd func to get file name
91bc7d5 fix videoCompressionFormatString and audioCodingTypeString funcs
f03069f reset FRAME_DROP_FREQ to 0
718b99a add HEVC(H.265) decoder
84f8bf6 cleanup
f026c93 cleanup
440614a add debug info

Change-Id: Ie75db0778f633357e2280aef6d47a0fa3beb823e

AwesomePlayer: use AwesomeLocalRenderer for OMX.ffmpeg.* components

stagefright: Remove duplicate types from QC media defs

Change-Id: I50ecafe79a2985d0868a1ac82464d6ca448aa2c5
Signed-off-by: Josue Rivera <prbassplayer@gmail.com>

Conflicts:
	media/libstagefright/ExtendedMediaDefs.cpp
	media/libstagefright/OMXCodec.cpp

libstagefright: Re-introduce a QCOM_HARDWARE ifdef after the FFMPEG commit

Fixes a build error on non QCOM hardware.

Change-Id: I4a4268b351d0d8bf748dd03ccea0fbab20ed4314

DataSource: Split off ffmpeg sniffer to a second pass, and only if necessary

ffmpeg's sniffer is intended as a grab-all-that-doesn't-work-elsewhere
extractor. Unfortunately, this causes two issues:

- As written, it requires ffmpeg to whitelist any extractors supported
by stagefright, or else it will blindly override them. This has codebase
sync issues, as shown by the VP9 and WAV accidental overrides
- It imposes an in-depth analysis of _all_ media, even that which we
want to be processed quickly by shipping stagefright plugins (hardware
or not). This is mostly noticeable in network streams and thumbnail
generation.

This patch moves FFmpegExtractor to an independent sniffer queue, and
it only invokes it when the regular MediaExtractor hits 1 of 3 conditions:

1 - The confidence in the identified container type is low
2 - No container is identified at all
3 - A video container was found by other extractors, but only 1 stream
(audio or video) was identified.

Change-Id: Ib96ff4f6bc06223fe0e819a57560d3c872a79ddd

stagefright: OMX.ffmpeg.* are software decoders, ensure they're treated as such

Wherever the component name for OMX.google soft decoders is used to identify
a software-based component, do the same for ffmpeg. Things like memory management
and window buffers care about this.

Change-Id: Ib83561936c7383e8726edb073cea9d78f7d1312f

libstagefright: Don't invoke FFMPEG for MP3

Change-Id: Ia30d25d1a994328827f14a286661cd2e1eaa1181

stagefright: Fix audio codec fallthru

 * We shouldn't return an error from setAudioFormat unless it's
   really an error since fallthru is necessary.
 * We don't even need to do this, since the component name is
   checked before calling into mm-parser or FFMPEG.
 * Fixes Vorbis decoding after FFMPEG patch.

Change-Id: I4871c62044c6693e5698119dee3a10c20c26e2c7

stagefright: Fix codec lookup bugs on NuPlayer

 * Fix use of WMA/WMV software codecs
 * Fix mpeg2 software codec name
 * Don't override the component name in ACodec. This actually breaks
   stuff because the format isn't available in the kInit message.

Change-Id: I93c292e039de5f24c2ccbd6ae2242b06d28fe518

stagefright: Cleanup and improve format parsing

 * Move FFMPEG-specific exceptions to FFMPEGSoftCodec
 * Add handling for AAC MAIN profile
 * Use the new OMX_AUDIO_CodingAndroidAC3 to handle AC3

Change-Id: Ibb806cd2b9dd23dc1e1b2c862fcde40605023a49

stagefright: Keep track of the bit width in the RAW codec

 * We need this to push 24-bit PCM around Stagefright and OMX

Change-Id: Ic94ec972162a01545d5dd0ad0bf3eb6c6731f42e

stagefright: Adjust confidence threshold for extended sniffers

 * Some sniffers return 0.2 for cases where they only find an audio
   track in some containers.
 * Change the comparison to also examine files right on this threshold.
 * This allows us to score ONE FUCKING HUNDRED PERCENT on the Antutu
   Video Test \o/

Change-Id: I78b6ab8a634771e0e290f669801f5b08d6a32a51

stagefright: Fix FFMPEG catchall decoders

 * Get this metadata properly flowing
 * Allows us to play tracks such as Apple Lossless :)

Change-Id: I2990b30eef5b672da339d24444424c61a43b85c2

stagefright: Fix metadata/message conversion issues

 * Remove duplication of code between ExtendedCodec and FFMPEGSoftCodec,
   just call into ExtendedCodec and properly ifdef QCOM-only parts.
 * Fix CSD not being converted when AV_ENHANCEMENTS wasn't set- this
   was breaking the software video codecs on Hammerhead.

Change-Id: I9cd4316ce19b15baabf12b78b992498ce48e2697

Fix compile error after I9cd4316ce19b15baabf12b78b992498ce48e2697

frameworks/av/media/libstagefright/ExtendedCodec.cpp:1187:1: error:
expected '}' at end of input

Change-Id: I7d75e69160f794b177f4235f4a6bb5a188dc0d08

stagefright: Fix AC3 playback

 * Skip setupAC3Codec in ACodec for non-Google components.

Change-Id: I5090485ba020f7ad1c0962fc977e38675b4c8314

stagefright: Guard against crash with mismatched codecs

 * Return unsupported error if WMV file can't be scanned.

Change-Id: Ia4a1ac7a299990f8b9c05a93736cb2fa9d0ee965

stagefright: Correct ifdeffage of some QC codecs

Change-Id: Ie8cc7287967b84e09941283559ca542efd928d91

stagefright: Create native window for FFMPEG software codecs

Change-Id: I178f334f1fa1ea9edc6898fb61e72902c2cb2651

stagefright: Don't ever try to use extended sniffers on DRM

 * This can cause long retry intervals during key exchange. Don't do it!

Change-Id: Id9a87dcbe43cd0cc9919fe07f0a963e087baccad

stagefright: Be more tolerant of missing metadata for FFMPEG codecs

 * If these codecs are instantiated programatically and required
   metadata isn't sent, just set some defaults instead of crashing on
   an assert.
 * This fixes testAllNonTunneledVideoCodecsSupportFlexibleYUV in MR1 CTS

Change-Id: I69bf6105a1be529298de574bd5d3b6813e7a4e8f

stagefright: Fix issues with software decoders

 * Fix MKV thumbnails
 * Fix VC1 thumbnails
 * Fix FFMPEG thumbnails
 * Fix trial decoder
 * Fix edge cases with WMV3/VC1 playback
 * Fix a state issue which caused some codecs to get wrong configuration

Change-Id: I09599166aa24bcff53f91e43de096c4fad8ca7ad

stagefright: ffmpeg: Slightly raise the threshold for the ffmpeg scanner

0.2 is the success value for the OMX.google soft audio sniffers, which
was making ffmpeg own the unpacking of those streams needlessly.

Fixes CYNGNOS-282

Change-Id: I75f50ed838cb8af9acdf99aa284b80a070555284

stagefright: Add support for loading a custom OMXPlugin

 * To facilitate moving the stagefright-plugins glue out of the
   framework, support is added to OMXMaster to load multiple
   external plugins besides internal/vendor versions.
 * This is currently limited to one plugin, defined by the
   "mm.sf.omx-plugin" system property. The code will allow any
   number of libraries to be loaded, though.
 * Should also be useful for nonstandard vendor implementations too.

Change-Id: I27d7e16ad56baa17754d8ea47a8c608a0d73d6f1

stagefright: Move a bunch of FFMPEG stuff out of here

 * Get rid of some of the glue code for stagefright-plugins
   and use the new extension header and plugin.
 * Still a bunch of TODOs on this, but it works.

Change-Id: If07d3213952b624d48035e5f58ad883b2a4049b0

stagefright: Remove deprecated FFMPEG config

Change-Id: I1fcdb4eeba72e2420493b89ddd6fc718d170ced7

stagefright: Support for 24-bit audio in StageFright

 * Plumb bit depth thru ACodec and OMX
 * Add support for 24-bit PCM offload in NuPlayer on QC devices
 * Use new AudioFlinger features for mixing multi formats without offload
 * Clean up a bunch of code

Change-Id: I018d3a995b63450a38c6c43eaa37c86be30fd893

nuplayer: Fix PCM offload turning on all the time

 * Remove the extra condition, since this will be set even if
   PCM offload was denied.

Change-Id: I8f33ef68562d8e057e7a86c5ae6187d0049bf3aa

stagefright: Cleanup of PCM offload checks

 * Put the checks in a single place.

Change-Id: I2d0d5b542593896e78bf989296de1a1d1e3a4963

stagefright: Add bit-depth plumbing for new formats

Change-Id: I13cfd75e4b4819543b64babf20cc9af57ea2978f

nuplayer: Fix bitrate propagation

 * We use "bitrate" rather than "bit-rate".

Change-Id: I4699194e3e3f7ef55b4eb554f5de7a6b5f6b80ce

libstagefright: Implement fallback mechanism to SW decoder

Implement fallback mechanism to software decoder
when hardware decoder configuration fails in ACodec

Change-Id: Idf4c445942b03e28b264c91a20e69d52224727bd
---
 include/media/stagefright/ACodec.h                 |   11 +-
 include/media/stagefright/DataSource.h             |    4 +
 include/media/stagefright/FFMPEGSoftCodec.h        |  133 +++
 include/media/stagefright/FileSource.h             |    6 +
 include/media/stagefright/MediaDefs.h              |   35 +
 include/media/stagefright/MediaExtractor.h         |   15 +-
 include/media/stagefright/MetaData.h               |   50 +
 .../mediaplayerservice/AVNuUtils.cpp               |   60 +-
 media/libavextensions/stagefright/AVUtils.cpp      |    6 +-
 media/libmediaplayerservice/nuplayer/Android.mk    |    3 +-
 .../nuplayer/NuPlayerDecoder.cpp                   |   10 +-
 .../nuplayer/NuPlayerRenderer.cpp                  |   15 +-
 media/libstagefright/ACodec.cpp                    |  168 ++-
 media/libstagefright/Android.mk                    |    4 +
 media/libstagefright/DataSource.cpp                |   68 +-
 media/libstagefright/FFMPEGSoftCodec.cpp           | 1149 ++++++++++++++++++++
 media/libstagefright/FileSource.cpp                |   16 +
 media/libstagefright/MediaCodec.cpp                |    3 +-
 media/libstagefright/MediaDefs.cpp                 |   28 +
 media/libstagefright/MediaExtractor.cpp            |   26 +-
 media/libstagefright/OMXClient.cpp                 |    1 +
 media/libstagefright/StagefrightMediaScanner.cpp   |    6 +-
 media/libstagefright/Utils.cpp                     |   27 +-
 media/libstagefright/codecs/raw/SoftRaw.cpp        |    6 +-
 media/libstagefright/codecs/raw/SoftRaw.h          |    1 +
 media/libstagefright/include/AwesomePlayer.h       |    1 +
 services/audioflinger/AudioMixer.h                 |    1 +
 27 files changed, 1792 insertions(+), 61 deletions(-)
 create mode 100644 include/media/stagefright/FFMPEGSoftCodec.h
 create mode 100644 media/libstagefright/FFMPEGSoftCodec.cpp

diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index ebfdc7b..8f524ef 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -47,6 +47,8 @@
 #include <media/stagefright/SkipCutBuffer.h>
 #include <OMX_Audio.h>
 
+#include <system/audio.h>
+
 #define TRACK_BUFFER_TIMING     0
 
 namespace android {
@@ -364,9 +366,11 @@ protected:
             int32_t maxOutputChannelCount, const drcParams_t& drc,
             int32_t pcmLimiterEnable);
 
-    status_t setupAC3Codec(bool encoder, int32_t numChannels, int32_t sampleRate);
+    status_t setupAC3Codec(bool encoder, int32_t numChannels, int32_t sampleRate,
+            int32_t bitsPerSample = 16);
 
-    status_t setupEAC3Codec(bool encoder, int32_t numChannels, int32_t sampleRate);
+    status_t setupEAC3Codec(bool encoder, int32_t numChannels, int32_t sampleRate,
+            int32_t bitsPerSample = 16);
 
     status_t selectAudioPortFormat(
             OMX_U32 portIndex, OMX_AUDIO_CODINGTYPE desiredFormat);
@@ -378,7 +382,8 @@ protected:
             bool encoder, int32_t numChannels, int32_t sampleRate, int32_t compressionLevel);
 
     status_t setupRawAudioFormat(
-            OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels);
+            OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels,
+            int32_t bitsPerSample = 16);
 
     status_t setPriority(int32_t priority);
     status_t setOperatingRate(float rateFloat, bool isVideo);
diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index 4032793..82f75bd 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -62,8 +62,11 @@ public:
 private:
     Mutex mSnifferMutex;
     List<SnifferFunc> mSniffers;
+    List<SnifferFunc> mExtraSniffers;
     List<SnifferFunc>::iterator extendedSnifferPosition;
 
+    void registerSnifferPlugin();
+
     Sniffer(const Sniffer &);
     Sniffer &operator=(const Sniffer &);
 };
@@ -159,6 +162,7 @@ protected:
     sp<Sniffer> mSniffer;
 
     static void RegisterSniffer_l(SnifferFunc func);
+    static void RegisterSnifferPlugin();
 
     DataSource(const DataSource &);
     DataSource &operator=(const DataSource &);
diff --git a/include/media/stagefright/FFMPEGSoftCodec.h b/include/media/stagefright/FFMPEGSoftCodec.h
new file mode 100644
index 0000000..83373d0
--- /dev/null
+++ b/include/media/stagefright/FFMPEGSoftCodec.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef FFMPEG_SOFT_CODEC_H_
+#define FFMPEG_SOFT_CODEC_H_
+
+#include <media/IOMX.h>
+#include <media/MediaCodecInfo.h>
+
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/AString.h>
+
+#include <media/stagefright/MetaData.h>
+
+#include <OMX_Audio.h>
+#include <OMX_Video.h>
+
+namespace android {
+
+struct FFMPEGSoftCodec {
+
+    enum {
+        kPortIndexInput  = 0,
+        kPortIndexOutput = 1
+    };
+
+    static void convertMessageToMetaDataFF(
+            const sp<AMessage> &msg, sp<MetaData> &meta);
+
+    static void convertMetaDataToMessageFF(
+        const sp<MetaData> &meta, sp<AMessage> *format);
+
+    static const char* overrideComponentName(
+            uint32_t quirks, const sp<MetaData> &meta,
+            const char *mime, bool isEncoder);
+
+    static void overrideComponentName(
+            uint32_t quirks, const sp<AMessage> &msg,
+            AString* componentName, AString* mime,
+            int32_t isEncoder);
+
+    static status_t setSupportedRole(
+            const sp<IOMX> &omx, IOMX::node_id node,
+            bool isEncoder, const char *mime);
+
+    static status_t setAudioFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID);
+
+    static status_t setVideoFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle,IOMX::node_id nodeID,
+            bool isEncoder, OMX_VIDEO_CODINGTYPE *compressionFormat);
+
+    static status_t getAudioPortFormat(
+            OMX_U32 portIndex, int coding,
+            sp<AMessage> &notify, sp<IOMX> OMXhandle, IOMX::node_id nodeID);
+
+    static status_t getVideoPortFormat(
+            OMX_U32 portIndex, int coding,
+            sp<AMessage> &notify, sp<IOMX> OMXhandle, IOMX::node_id nodeID);
+
+private:
+    static const char* getMsgKey(int key);
+
+    static status_t setWMVFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setRVFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setFFmpegVideoFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setRawAudioFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setWMAFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setVORBISFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setRAFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setFLACFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setMP2Format(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setAC3Format(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setAPEFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setDTSFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setFFmpegAudioFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+};
+
+}
+#endif
diff --git a/include/media/stagefright/FileSource.h b/include/media/stagefright/FileSource.h
index a981d1c..21844ca 100644
--- a/include/media/stagefright/FileSource.h
+++ b/include/media/stagefright/FileSource.h
@@ -39,6 +39,10 @@ public:
 
     virtual status_t getSize(off64_t *size);
 
+    virtual String8 getUri() {
+        return mUri;
+    }
+
     virtual sp<DecryptHandle> DrmInitialization(const char *mime);
 
     virtual void getDrmInfo(sp<DecryptHandle> &handle, DrmManagerClient **client);
@@ -48,6 +52,7 @@ protected:
 
 private:
     int mFd;
+    String8 mUri;
     int64_t mOffset;
     int64_t mLength;
     Mutex mLock;
@@ -60,6 +65,7 @@ private:
     unsigned char *mDrmBuf;
 
     ssize_t readAtDRM(off64_t offset, void *data, size_t size);
+    void fetchUriFromFd(int fd);
 
     FileSource(const FileSource &);
     FileSource &operator=(const FileSource &);
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 21e7704..57165d0 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -88,6 +88,41 @@ extern const char *MEDIA_MIMETYPE_TEXT_VTT;
 extern const char *MEDIA_MIMETYPE_TEXT_CEA_608;
 extern const char *MEDIA_MIMETYPE_DATA_TIMED_ID3;
 
+extern const char *MEDIA_MIMETYPE_AUDIO_EAC3_JOC;
+extern const char *MEDIA_MIMETYPE_AUDIO_EAC3;
+
+extern const char *MEDIA_MIMETYPE_VIDEO_FLV1;
+extern const char *MEDIA_MIMETYPE_VIDEO_MJPEG;
+extern const char *MEDIA_MIMETYPE_VIDEO_RV;
+extern const char *MEDIA_MIMETYPE_VIDEO_VC1;
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV;
+extern const char *MEDIA_MIMETYPE_VIDEO_HEVC;
+extern const char *MEDIA_MIMETYPE_VIDEO_FFMPEG;
+
+extern const char *MEDIA_MIMETYPE_AUDIO_AC3;
+extern const char *MEDIA_MIMETYPE_AUDIO_PCM;
+extern const char *MEDIA_MIMETYPE_AUDIO_RA;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMA;
+extern const char *MEDIA_MIMETYPE_AUDIO_FFMPEG;
+
+extern const char *MEDIA_MIMETYPE_CONTAINER_APE;
+extern const char *MEDIA_MIMETYPE_CONTAINER_DIVX;
+extern const char *MEDIA_MIMETYPE_CONTAINER_DTS;
+extern const char *MEDIA_MIMETYPE_CONTAINER_FLAC;
+extern const char *MEDIA_MIMETYPE_CONTAINER_FLV;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MOV;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MP2;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MPG;
+extern const char *MEDIA_MIMETYPE_CONTAINER_RA;
+extern const char *MEDIA_MIMETYPE_CONTAINER_RM;
+extern const char *MEDIA_MIMETYPE_CONTAINER_TS;
+extern const char *MEDIA_MIMETYPE_CONTAINER_WEBM;
+extern const char *MEDIA_MIMETYPE_CONTAINER_VC1;
+extern const char *MEDIA_MIMETYPE_CONTAINER_HEVC;
+extern const char *MEDIA_MIMETYPE_CONTAINER_WMA;
+extern const char *MEDIA_MIMETYPE_CONTAINER_WMV;
+extern const char *MEDIA_MIMETYPE_CONTAINER_FFMPEG;
+
 }  // namespace android
 
 #include <media/stagefright/ExtendedMediaDefs.h>
diff --git a/include/media/stagefright/MediaExtractor.h b/include/media/stagefright/MediaExtractor.h
index 32925ca..2f2057f 100644
--- a/include/media/stagefright/MediaExtractor.h
+++ b/include/media/stagefright/MediaExtractor.h
@@ -19,15 +19,27 @@
 #define MEDIA_EXTRACTOR_H_
 
 #include <utils/RefBase.h>
+#include <media/stagefright/DataSource.h>
 
 namespace android {
 
-class DataSource;
 class MediaSource;
 class MetaData;
 
 class MediaExtractor : public RefBase {
 public:
+    typedef MediaExtractor *(*CreateFunc)(const sp<DataSource> &source,
+            const char *mime, const sp<AMessage> &meta);
+
+    struct Plugin {
+        DataSource::SnifferFunc sniff;
+        CreateFunc create;
+    };
+
+    static Plugin *getPlugin() {
+        return &sPlugin;
+    }
+
     static sp<MediaExtractor> Create(
             const sp<DataSource> &source, const char *mime = NULL,
             const uint32_t flags = 0);
@@ -76,6 +88,7 @@ protected:
 
 private:
     bool mIsDrm;
+    static Plugin sPlugin;
 
     MediaExtractor(const MediaExtractor &);
     MediaExtractor &operator=(const MediaExtractor &);
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index 8d4e15a..275ef55 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -50,6 +50,10 @@ enum {
     kKeySampleRate        = 'srte',  // int32_t (audio sampling rate Hz)
     kKeyFrameRate         = 'frmR',  // int32_t (video frame rate fps)
     kKeyBitRate           = 'brte',  // int32_t (bps)
+    kKeyCodecId           = 'cdid',  // int32_t
+    kKeyBitsPerSample     = 'sbit',  // int32_t (DUPE of kKeySampleBits)
+    kKeyCodedSampleBits   = 'cosb',  // int32_t
+    kKeySampleFormat      = 'sfmt',  // int32_t
     kKeyESDS              = 'esds',  // raw data
     kKeyAACProfile        = 'aacp',  // int32_t
     kKeyAVCC              = 'avcc',  // raw data
@@ -131,6 +135,23 @@ enum {
 
     kKeyIsUnreadable      = 'unre',  // bool (int32_t)
 
+    kKeyRawCodecSpecificData = 'rcsd',  // raw data - added to support mmParser
+    kKeyDivXVersion       = 'DivX',  // int32_t
+    kKeyDivXDrm           = 'QDrm',  // void *
+    kKeyWMAEncodeOpt      = 'eopt',  // int32_t
+    kKeyWMABlockAlign     = 'blka',  // int32_t
+    kKeyWMAVersion        = 'wmav',  // int32_t
+    kKeyWMAAdvEncOpt1     = 'ade1',  // int16_t
+    kKeyWMAAdvEncOpt2     = 'ade2',  // int32_t
+    kKeyWMAFormatTag      = 'fmtt',  // int64_t
+    kKeyWMABitspersample  = 'bsps',  // int64_t
+    kKeyWMAVirPktSize     = 'vpks',  // int64_t
+    kKeyWMVProfile        = 'wmvp',  // int32_t
+
+    kKeyWMVVersion        = 'wmvv',  // int32_t
+    kKeyRVVersion         = '#rvv',  // int32_t
+    kKeyBlockAlign        = 'blk',   // int32_t , should be different from kKeyWMABlockAlign
+
     // An indication that a video buffer has been rendered.
     kKeyRendered          = 'rend',  // bool (int32_t)
 
@@ -181,6 +202,9 @@ enum {
 
     // H264 supplemental enhancement information offsets/sizes
     kKeySEI               = 'sei ', // raw data
+
+    kKeyPCMFormat         = 'pfmt',
+    kKeyArbitraryMode     = 'ArbM',
 };
 
 enum {
@@ -190,6 +214,32 @@ enum {
     kTypeD263        = 'd263',
 };
 
+enum {
+    kTypeDivXVer_3_11,
+    kTypeDivXVer_4,
+    kTypeDivXVer_5,
+    kTypeDivXVer_6,
+};
+
+enum {
+    kTypeWMA,
+    kTypeWMAPro,
+    kTypeWMALossLess,
+};
+
+enum {
+    kTypeWMVVer_7, // WMV1
+    kTypeWMVVer_8, // WMV2
+    kTypeWMVVer_9, // WMV3
+};
+
+// http://en.wikipedia.org/wiki/RealVideo
+enum {
+    kTypeRVVer_G2, // rv20: RealVideo G2
+    kTypeRVVer_8,  // rv30: RealVideo 8
+    kTypeRVVer_9,  // rv40: RealVideo 9
+};
+
 class MetaData : public RefBase {
 public:
     MetaData();
diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index 68b6ad3..77d2b0f 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -33,6 +33,8 @@
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/foundation/AMessage.h>
 
+#include <media/stagefright/MediaDefs.h>
+
 #include <nuplayer/NuPlayer.h>
 #include <nuplayer/NuPlayerDecoderBase.h>
 #include <nuplayer/NuPlayerDecoderPassThrough.h>
@@ -52,12 +54,29 @@ bool AVNuUtils::pcmOffloadException(const sp<MetaData> &) {
     return true;
 }
 
-bool AVNuUtils::isRAWFormat(const sp<MetaData> &) {
-    return false;
+bool AVNuUtils::isRAWFormat(const sp<MetaData> &meta) {
+    const char *mime = {0};
+    if (meta == NULL) {
+        return false;
+    }
+    CHECK(meta->findCString(kKeyMIMEType, &mime));
+    if (!strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW, 9))
+        return true;
+    else
+        return false;
 }
 
-bool AVNuUtils::isRAWFormat(const sp<AMessage> &) {
-    return false;
+bool AVNuUtils::isRAWFormat(const sp<AMessage> &format) {
+    AString mime;
+    if (format == NULL) {
+        return false;
+    }
+    CHECK(format->findString("mime", &mime));
+    if (!strncasecmp(mime.c_str(), MEDIA_MIMETYPE_AUDIO_RAW, 9))
+        return true;
+    else
+        return false;
+
 }
 
 bool AVNuUtils::isVorbisFormat(const sp<MetaData> &) {
@@ -69,20 +88,39 @@ int AVNuUtils::updateAudioBitWidth(audio_format_t /*audioFormat*/,
     return 16;
 }
 
-audio_format_t AVNuUtils::getKeyPCMFormat(const sp<MetaData> &) {
-    return AUDIO_FORMAT_INVALID;
-}
+audio_format_t AVNuUtils::getKeyPCMFormat(const sp<MetaData> &meta) {
+    int32_t pcmFormat = 0;
+    if (meta->findInt32('pfmt', &pcmFormat))
+        return (audio_format_t)pcmFormat;
 
-void AVNuUtils::setKeyPCMFormat(const sp<MetaData> &, audio_format_t /*audioFormat*/) {
+    return AUDIO_FORMAT_PCM_16_BIT;
+}
 
+void AVNuUtils::setKeyPCMFormat(const sp<MetaData> &meta, audio_format_t audioFormat) {
+    if (audio_is_linear_pcm(audioFormat))
+        meta->setInt32('pfmt', audioFormat);
 }
 
-audio_format_t AVNuUtils::getPCMFormat(const sp<AMessage> &) {
+audio_format_t AVNuUtils::getPCMFormat(const sp<AMessage> &format) {
+    int32_t pcmFormat = 0;
+    if (format->findInt32("pcm-format", &pcmFormat))
+        return (audio_format_t)pcmFormat;
+
+    int32_t bits = 16;
+    if (format->findInt32("bit-width", &bits)) {
+        if (bits == 8)
+            return AUDIO_FORMAT_PCM_8_BIT;
+        if (bits == 24)
+            return AUDIO_FORMAT_PCM_32_BIT;
+        if (bits == 32)
+            return AUDIO_FORMAT_PCM_FLOAT;
+    }
     return AUDIO_FORMAT_PCM_16_BIT;
 }
 
-void AVNuUtils::setPCMFormat(const sp<AMessage> &, audio_format_t /*audioFormat*/) {
-
+void AVNuUtils::setPCMFormat(const sp<AMessage> &format, audio_format_t audioFormat) {
+    if (audio_is_linear_pcm(audioFormat))
+        format->setInt32("pcm-format", audioFormat);
 }
 
 void AVNuUtils::setSourcePCMFormat(const sp<MetaData> &) {
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index a1ecbae..8c69f68 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -66,8 +66,10 @@ int AVUtils::getAudioSampleBits(const sp<MetaData> &) {
     return 16;
 }
 
-int AVUtils::getAudioSampleBits(const sp<AMessage> &) {
-    return 16;
+int AVUtils::getAudioSampleBits(const sp<AMessage> &format) {
+    int32_t bits = 16;
+    format->findInt32("bit-width", &bits);
+    return bits;
 }
 
 void AVUtils::setPcmSampleBits(const sp<AMessage> &, int32_t /*bitWidth*/) {
diff --git a/media/libmediaplayerservice/nuplayer/Android.mk b/media/libmediaplayerservice/nuplayer/Android.mk
index 6fd0f9c..7a60d2c 100644
--- a/media/libmediaplayerservice/nuplayer/Android.mk
+++ b/media/libmediaplayerservice/nuplayer/Android.mk
@@ -24,7 +24,8 @@ LOCAL_C_INCLUDES := \
 	$(TOP)/frameworks/av/media/libstagefright/timedtext           \
 	$(TOP)/frameworks/av/media/libmediaplayerservice              \
 	$(TOP)/frameworks/native/include/media/openmax                \
-        $(TOP)/frameworks/av/media/libavextensions                    \
+	$(TOP)/frameworks/av/media/libavextensions                    \
+	$(TOP)/frameworks/av/include/media                            \
 
 LOCAL_CFLAGS += -Werror -Wall
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index 282686f..da308f6 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -54,6 +54,7 @@
 #include <media/stagefright/MediaErrors.h>
 
 #include <stagefright/AVExtensions.h>
+#include <stagefright/FFMPEGSoftCodec.h>
 #include <gui/Surface.h>
 
 #include "avc_utils.h"
@@ -277,9 +278,16 @@ void NuPlayer::Decoder::onConfigure(const sp<AMessage> &format) {
     ALOGV("[%s] onConfigure (surface=%p)", mComponentName.c_str(), mSurface.get());
 
     mCodec = AVUtils::get()->createCustomComponentByName(mCodecLooper, mime.c_str(), false /* encoder */, format);
+    FFMPEGSoftCodec::overrideComponentName(0, format, &mComponentName, &mime, false);
+
     if (mCodec == NULL) {
-        mCodec = MediaCodec::CreateByType(mCodecLooper, mime.c_str(), false /* encoder */);
+        if (!mComponentName.startsWith(mime.c_str())) {
+            mCodec = MediaCodec::CreateByComponentName(mCodecLooper, mComponentName.c_str());
+        } else {
+            mCodec = MediaCodec::CreateByType(mCodecLooper, mime.c_str(), false /* encoder */);
+        }
     }
+
     int32_t secure = 0;
     if (format->findInt32("secure", &secure) && secure != 0) {
         if (mCodec != NULL) {
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index a60a8b4..4b03200 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -26,6 +26,7 @@
 #include <media/stagefright/foundation/AUtils.h>
 #include <media/stagefright/foundation/AWakeLock.h>
 #include <media/stagefright/MediaClock.h>
+#include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/Utils.h>
@@ -1730,13 +1731,17 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
         channelMask = CHANNEL_MASK_USE_CHANNEL_ORDER;
     }
 
+    int32_t bitWidth = 16;
+    format->findInt32("bit-width", &bitWidth);
+
     int32_t sampleRate;
     CHECK(format->findInt32("sample-rate", &sampleRate));
 
+    AString mime;
+    CHECK(format->findString("mime", &mime));
+
     if (offloadingAudio()) {
         audio_format_t audioFormat = AUDIO_FORMAT_PCM_16_BIT;
-        AString mime;
-        CHECK(format->findString("mime", &mime));
         status_t err = mapMimeToAudioFormat(audioFormat, mime.c_str());
 
         if (err != OK) {
@@ -1744,15 +1749,11 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
                     "audio_format", mime.c_str());
             onDisableOffloadAudio();
         } else {
-            int32_t bitWidth = 16;
-            ALOGV("Mime \"%s\" mapped to audio_format 0x%x",
-                    mime.c_str(), audioFormat);
-
             audioFormat = AVUtils::get()->updateAudioFormat(audioFormat, format);
 
             bitWidth = AVUtils::get()->getAudioSampleBits(format);
             int avgBitRate = -1;
-            format->findInt32("bit-rate", &avgBitRate);
+            format->findInt32("bitrate", &avgBitRate);
 
             int32_t aacProfile = -1;
             if (audioFormat == AUDIO_FORMAT_AAC
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 2c79f29..c68971a 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -81,6 +81,8 @@
 #include <media/stagefright/OMXCodec.h>
 #include <media/stagefright/PersistentSurface.h>
 #include <media/stagefright/SurfaceUtils.h>
+#include <media/stagefright/FFMPEGSoftCodec.h>
+
 #include <media/hardware/HardwareAPI.h>
 
 #include <OMX_AudioExt.h>
@@ -586,7 +588,12 @@ ACodec::ACodec()
 ACodec::~ACodec() {
 }
 
-status_t ACodec::setupCustomCodec(status_t err, const char *, const sp<AMessage> &) {
+status_t ACodec::setupCustomCodec(status_t err, const char *mime, const sp<AMessage> &msg) {
+     if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11) && !mIsEncoder) {
+         return FFMPEGSoftCodec::setAudioFormat(
+               msg, mime, mOMX, mNode);
+     }
+
     return err;
 }
 
@@ -1662,7 +1669,11 @@ status_t ACodec::setComponentRole(
     }
 
     if (i == kNumMimeToRole) {
-        return ERROR_UNSUPPORTED;
+        status_t err = ERROR_UNSUPPORTED;
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
+        }
+        return err;
     }
 
     const char *role =
@@ -1983,7 +1994,8 @@ status_t ACodec::configureCodec(
     if (video) {
         // determine need for software renderer
         bool usingSwRenderer = false;
-        if (haveNativeWindow && mComponentName.startsWith("OMX.google.")) {
+        if (haveNativeWindow && (mComponentName.startsWith("OMX.google.") ||
+                                 mComponentName.startsWith("OMX.ffmpeg."))) {
             usingSwRenderer = true;
             haveNativeWindow = false;
         }
@@ -2068,10 +2080,12 @@ status_t ACodec::configureCodec(
             // and have the decoder figure it all out.
             err = OK;
         } else {
+            int32_t bitsPerSample = 16;
+            msg->findInt32("bit-width", &bitsPerSample);
             err = setupRawAudioFormat(
                     encoder ? kPortIndexInput : kPortIndexOutput,
                     sampleRate,
-                    numChannels);
+                    numChannels, bitsPerSample);
         }
 #ifdef DTS_CODEC_M_
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_DTS)) {
@@ -2165,11 +2179,7 @@ status_t ACodec::configureCodec(
             }
             err = setupG711Codec(encoder, sampleRate, numChannels);
         }
-#ifdef QTI_FLAC_DECODER
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC) && encoder) {
-#else
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
-#endif
         int32_t numChannels = 0, sampleRate = 0, compressionLevel = -1;
         if (encoder &&
                 (!msg->findInt32("channel-count", &numChannels)
@@ -2205,16 +2215,21 @@ status_t ACodec::configureCodec(
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             err = INVALID_OPERATION;
         } else {
-            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+            int32_t bitsPerSample = 16;
+            msg->findInt32("bit-width", &bitsPerSample);
+            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels, bitsPerSample);
         }
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) {
+    } else if (!strncmp(mComponentName.c_str(), "OMX.google.", 11)
+            && !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) {
         int32_t numChannels;
         int32_t sampleRate;
         if (!msg->findInt32("channel-count", &numChannels)
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             err = INVALID_OPERATION;
         } else {
-            err = setupAC3Codec(encoder, numChannels, sampleRate);
+            int32_t bitsPerSample = 16;
+            msg->findInt32("bit-width", &bitsPerSample);
+            err = setupAC3Codec(encoder, numChannels, sampleRate, bitsPerSample);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_EAC3)) {
         int32_t numChannels;
@@ -2223,7 +2238,9 @@ status_t ACodec::configureCodec(
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             err = INVALID_OPERATION;
         } else {
-            err = setupEAC3Codec(encoder, numChannels, sampleRate);
+            int32_t bitsPerSample = 16;
+            msg->findInt32("bit-width", &bitsPerSample);
+            err = setupEAC3Codec(encoder, numChannels, sampleRate, bitsPerSample);
         }
     } else {
         err = setupCustomCodec(err, mime, msg);
@@ -2541,9 +2558,9 @@ status_t ACodec::setupAACCodec(
 }
 
 status_t ACodec::setupAC3Codec(
-        bool encoder, int32_t numChannels, int32_t sampleRate) {
+        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t bitsPerSample) {
     status_t err = setupRawAudioFormat(
-            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels);
+            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels, bitsPerSample);
 
     if (err != OK) {
         return err;
@@ -2579,9 +2596,9 @@ status_t ACodec::setupAC3Codec(
 }
 
 status_t ACodec::setupEAC3Codec(
-        bool encoder, int32_t numChannels, int32_t sampleRate) {
+        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t bitsPerSample) {
     status_t err = setupRawAudioFormat(
-            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels);
+            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels, bitsPerSample);
 
     if (err != OK) {
         return err;
@@ -2727,7 +2744,7 @@ status_t ACodec::setupFlacCodec(
 }
 
 status_t ACodec::setupRawAudioFormat(
-        OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels) {
+        OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels, int32_t bitsPerSample) {
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
@@ -2762,7 +2779,7 @@ status_t ACodec::setupRawAudioFormat(
     pcmParams.nChannels = numChannels;
     pcmParams.eNumData = OMX_NumericalDataSigned;
     pcmParams.bInterleaved = OMX_TRUE;
-    pcmParams.nBitPerSample = 16;
+    pcmParams.nBitPerSample = bitsPerSample;
     pcmParams.nSamplingRate = sampleRate;
     pcmParams.ePCMMode = OMX_AUDIO_PCMModeLinear;
 
@@ -2989,7 +3006,13 @@ status_t ACodec::setupVideoDecoder(
     status_t err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
-        return err;
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
+            return err;
+        }
     }
 
     err = setVideoPortFormatType(
@@ -3139,7 +3162,14 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
     err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
-        return err;
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
+            ALOGE("Not a supported video mime type: %s", mime);
+            return err;
+        }
     }
 
     err = setVideoPortFormatType(
@@ -4247,6 +4277,14 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
 
                 default:
                 {
+                    if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+                        err = FFMPEGSoftCodec::getVideoPortFormat(portIndex,
+                                (int)videoDef->eCompressionFormat, notify, mOMX, mNode);
+                    }
+                    if (err == OK) {
+                        break;
+                    }
+
                     if (mIsEncoder ^ (portIndex == kPortIndexOutput)) {
                         // should be CodingUnused
                         ALOGE("Raw port video compression format is %s(%d)",
@@ -4293,7 +4331,9 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     if (params.nChannels <= 0
                             || (params.nChannels != 1 && !params.bInterleaved)
                             || (params.nBitPerSample != 16u
-                                    && params.nBitPerSample != 24u)// we support 16/24 bit s/w decoding
+                                    && params.nBitPerSample != 24u
+                                    && params.nBitPerSample != 32u
+                                    && params.nBitPerSample != 8u)// we support 8/16/24/32 bit s/w decoding
                             || params.eNumData != OMX_NumericalDataSigned
                             || params.ePCMMode != OMX_AUDIO_PCMModeLinear) {
                         ALOGE("unsupported PCM port: %u channels%s, %u-bit, %s(%d), %s(%d) mode ",
@@ -4309,6 +4349,7 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("channel-count", params.nChannels);
                     notify->setInt32("sample-rate", params.nSamplingRate);
                     notify->setInt32("bit-width", params.nBitPerSample);
+
                     if (mChannelMaskPresent) {
                         notify->setInt32("channel-mask", mChannelMask);
                     }
@@ -4358,6 +4399,7 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
 
                 case OMX_AUDIO_CodingFLAC:
                 {
+                    if (portIndex == kPortIndexInput) {
                     OMX_AUDIO_PARAM_FLACTYPE params;
                     InitOMXParams(&params);
                     params.nPortIndex = portIndex;
@@ -4372,6 +4414,7 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("channel-count", params.nChannels);
                     notify->setInt32("sample-rate", params.nSampleRate);
                     break;
+                    }
                 }
 
                 case OMX_AUDIO_CodingMP3:
@@ -4529,6 +4572,14 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
 #endif
 
                 default:
+                    if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+                        err = FFMPEGSoftCodec::getAudioPortFormat(portIndex,
+                                (int)audioDef->eEncoding, notify, mOMX, mNode);
+                    }
+                    if (err == OK) {
+                        break;
+                    }
+
                     ALOGE("Unsupported audio coding: %s(%d)\n",
                             asString(audioDef->eEncoding), audioDef->eEncoding);
                     return BAD_TYPE;
@@ -5834,8 +5885,79 @@ bool ACodec::LoadedState::onConfigureComponent(
         ALOGE("[%s] configureCodec returning error %d",
               mCodec->mComponentName.c_str(), err);
 
-        mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));
-        return false;
+        int32_t encoder;
+        if (!msg->findInt32("encoder", &encoder)) {
+            encoder = false;
+        }
+
+        if (!encoder && !strncmp(mime.c_str(), "video/", strlen("video/"))) {
+            Vector<OMXCodec::CodecNameAndQuirks> matchingCodecs;
+
+            OMXCodec::findMatchingCodecs(
+                mime.c_str(),
+                encoder, // createEncoder
+                NULL,  // matchComponentName
+                0,     // flags
+                &matchingCodecs);
+
+            status_t err = mCodec->mOMX->freeNode(mCodec->mNode);
+
+            if (err != OK) {
+                ALOGE("Failed to freeNode");
+                mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));
+                return false;
+            }
+
+            mCodec->mNode = 0;
+            AString componentName;
+            sp<CodecObserver> observer = new CodecObserver;
+
+            err = NAME_NOT_FOUND;
+            for (size_t matchIndex = 0; matchIndex < matchingCodecs.size();
+                    ++matchIndex) {
+                componentName = matchingCodecs.itemAt(matchIndex).mName.string();
+                if (!strcmp(mCodec->mComponentName.c_str(), componentName.c_str())) {
+                    continue;
+                }
+
+                pid_t tid = gettid();
+                int prevPriority = androidGetThreadPriority(tid);
+                androidSetThreadPriority(tid, ANDROID_PRIORITY_FOREGROUND);
+                err = mCodec->mOMX->allocateNode(componentName.c_str(), observer, &mCodec->mNode);
+                androidSetThreadPriority(tid, prevPriority);
+
+                if (err == OK) {
+                    break;
+                } else {
+                    ALOGW("Allocating component '%s' failed, try next one.", componentName.c_str());
+                }
+
+                mCodec->mNode = 0;
+            }
+
+            if (mCodec->mNode == 0) {
+                if (!mime.empty()) {
+                    ALOGE("Unable to instantiate a %scoder for type '%s' with err %#x.",
+                            encoder ? "en" : "de", mime.c_str(), err);
+                } else {
+                    ALOGE("Unable to instantiate codec '%s' with err %#x.", componentName.c_str(), err);
+                }
+
+                mCodec->signalError((OMX_ERRORTYPE)err, makeNoSideEffectStatus(err));
+                return false;
+            }
+
+            sp<AMessage> notify = new AMessage(kWhatOMXMessageList, mCodec);
+            observer->setNotificationMessage(notify);
+            mCodec->mComponentName = componentName;
+
+            err = mCodec->configureCodec(mime.c_str(), msg);
+
+            if (err != OK) {
+                mCodec->signalError((OMX_ERRORTYPE)err, makeNoSideEffectStatus(err));
+                return false;
+            }
+        }
     }
 
     {
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 6c16311..dcea5a9 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -89,6 +89,7 @@ LOCAL_SRC_FILES:=                         \
         XINGSeeker.cpp                    \
         avc_utils.cpp                     \
         APE.cpp                           \
+        FFMPEGSoftCodec.cpp               \
 
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/ \
@@ -186,6 +187,9 @@ ifeq ($(BOARD_USE_SAMSUNG_CAMERAFORMAT_NV21), true)
 LOCAL_CFLAGS += -DUSE_SAMSUNG_CAMERAFORMAT_NV21
 endif
 
+# FFMPEG plugin
+LOCAL_C_INCLUDES += $(TOP)/external/stagefright-plugins/include
+
 LOCAL_MODULE:= libstagefright
 
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index f650ea2..2df045f 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -47,11 +47,28 @@
 #include <utils/String8.h>
 
 #include <cutils/properties.h>
+#include <cutils/log.h>
+
+#include <dlfcn.h>
 
 #include <stagefright/AVExtensions.h>
 
 namespace android {
 
+static void *loadExtractorPlugin() {
+    void *ret = NULL;
+    char lib[PROPERTY_VALUE_MAX];
+    if (property_get("media.sf.extractor-plugin", lib, NULL)) {
+        if (void *extractorLib = ::dlopen(lib, RTLD_LAZY)) {
+            ret = ::dlsym(extractorLib, "getExtractorPlugin");
+            ALOGW_IF(!ret, "Failed to find symbol, dlerror: %s", ::dlerror());
+        } else {
+            ALOGV("Failed to load %s, dlerror: %s", lib, ::dlerror());
+        }
+    }
+    return ret;
+}
+
 bool DataSource::getUInt16(off64_t offset, uint16_t *x) {
     *x = 0;
 
@@ -119,7 +136,7 @@ bool DataSource::sniff(
 }
 
 // static
-void DataSource::RegisterSniffer_l(SnifferFunc func) {
+void DataSource::RegisterSniffer_l(SnifferFunc /* func */) {
     return;
 }
 
@@ -137,6 +154,13 @@ Sniffer::Sniffer() {
 bool Sniffer::sniff(
         DataSource *source, String8 *mimeType, float *confidence, sp<AMessage> *meta) {
 
+    bool forceExtraSniffers = false;
+
+    if (*confidence == 3.14f) {
+       // Magic value, as set by MediaExtractor when a video container looks incomplete
+       forceExtraSniffers = true;
+    }
+
     *mimeType = "";
     *confidence = 0.0f;
     meta->clear();
@@ -156,6 +180,23 @@ bool Sniffer::sniff(
         }
     }
 
+    /* Only do the deeper sniffers if the results are null or in doubt */
+    if (mimeType->length() == 0 || *confidence < 0.21f || forceExtraSniffers) {
+        for (List<SnifferFunc>::iterator it = mExtraSniffers.begin();
+                it != mExtraSniffers.end(); ++it) {
+            String8 newMimeType;
+            float newConfidence;
+            sp<AMessage> newMeta;
+            if ((*it)(source, &newMimeType, &newConfidence, &newMeta)) {
+                if (newConfidence > *confidence) {
+                    *mimeType = newMimeType;
+                    *confidence = newConfidence;
+                    *meta = newMeta;
+                }
+            }
+        }
+    }
+
     return *confidence > 0.0;
 }
 
@@ -171,6 +212,26 @@ void Sniffer::registerSniffer_l(SnifferFunc func) {
     mSniffers.push_back(func);
 }
 
+void Sniffer::registerSnifferPlugin() {
+    static void (*getExtractorPlugin)(MediaExtractor::Plugin *) =
+            (void (*)(MediaExtractor::Plugin *))loadExtractorPlugin();
+
+    MediaExtractor::Plugin *plugin = MediaExtractor::getPlugin();
+    if (!plugin->sniff && getExtractorPlugin) {
+        getExtractorPlugin(plugin);
+    }
+    if (plugin->sniff) {
+        for (List<SnifferFunc>::iterator it = mExtraSniffers.begin();
+             it != mExtraSniffers.end(); ++it) {
+            if (*it == plugin->sniff) {
+                return;
+            }
+        }
+
+        mExtraSniffers.push_back(plugin->sniff);
+    }
+}
+
 void Sniffer::registerDefaultSniffers() {
     Mutex::Autolock autoLock(mSnifferMutex);
 
@@ -185,8 +246,9 @@ void Sniffer::registerDefaultSniffers() {
     registerSniffer_l(SniffAAC);
     registerSniffer_l(SniffMPEG2PS);
     registerSniffer_l(SniffWVM);
-    RegisterSniffer_l(SniffMidi);
-    RegisterSniffer_l(AVUtils::get()->getExtendedSniffer());
+    registerSniffer_l(SniffMidi);
+    registerSniffer_l(AVUtils::get()->getExtendedSniffer());
+    registerSnifferPlugin();
 
     char value[PROPERTY_VALUE_MAX];
     if (property_get("drm.service.enabled", value, NULL)
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
new file mode 100644
index 0000000..3e6692b
--- /dev/null
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -0,0 +1,1149 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "FFMPEGSoftCodec"
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ABitReader.h>
+
+#include <media/stagefright/FFMPEGSoftCodec.h>
+
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaCodecList.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/OMXCodec.h>
+#include <media/stagefright/Utils.h>
+
+#include <OMX_Component.h>
+#include <OMX_AudioExt.h>
+#include <OMX_IndexExt.h>
+
+#include <OMX_FFMPEG_Extn.h>
+
+namespace android {
+
+enum MetaKeyType{
+    INT32, INT64, STRING, DATA, CSD
+};
+
+struct MetaKeyEntry{
+    int MetaKey;
+    const char* MsgKey;
+    MetaKeyType KeyType;
+};
+
+static const MetaKeyEntry MetaKeyTable[] {
+   {kKeyAACAOT               , "aac-profile"            , INT32},
+   {kKeyArbitraryMode        , "use-arbitrary-mode"     , INT32},
+   {kKeyBitRate              , "bitrate"                , INT32},
+   {kKeyBitsPerSample        , "bit-width"              , INT32},
+   {kKeyBlockAlign           , "block-align"            , INT32},
+   {kKeyChannelCount         , "channel-count"          , INT32},
+   {kKeyCodecId              , "codec-id"               , INT32},
+   {kKeyCodedSampleBits      , "coded-sample-bits"      , INT32},
+   {kKeyRawCodecSpecificData , "raw-codec-specific-data", CSD},
+   {kKeyRVVersion            , "rv-version"             , INT32},
+   {kKeySampleFormat         , "sample-format"          , INT32},
+   {kKeySampleRate           , "sample-rate"            , INT32},
+   {kKeyWMAVersion           , "wma-version"            , INT32},  // int32_t
+   {kKeyWMVVersion           , "wmv-version"            , INT32},
+   {kKeyPCMFormat            , "pcm-format"             , INT32},
+};
+
+const char* FFMPEGSoftCodec::getMsgKey(int key) {
+    static const size_t numMetaKeys =
+                     sizeof(MetaKeyTable) / sizeof(MetaKeyTable[0]);
+    size_t i;
+    for (i = 0; i < numMetaKeys; ++i) {
+        if (key == MetaKeyTable[i].MetaKey) {
+            return MetaKeyTable[i].MsgKey;
+        }
+    }
+    return "unknown";
+}
+
+void FFMPEGSoftCodec::convertMetaDataToMessageFF(
+        const sp<MetaData> &meta, sp<AMessage> *format) {
+    const char * str_val;
+    int32_t int32_val;
+    int64_t int64_val;
+    uint32_t data_type;
+    const void * data;
+    size_t size;
+    static const size_t numMetaKeys =
+                     sizeof(MetaKeyTable) / sizeof(MetaKeyTable[0]);
+    size_t i;
+    for (i = 0; i < numMetaKeys; ++i) {
+        if (MetaKeyTable[i].KeyType == INT32 &&
+            meta->findInt32(MetaKeyTable[i].MetaKey, &int32_val)) {
+            ALOGV("found metakey %s of type int32", MetaKeyTable[i].MsgKey);
+            format->get()->setInt32(MetaKeyTable[i].MsgKey, int32_val);
+        } else if (MetaKeyTable[i].KeyType == INT64 &&
+                 meta->findInt64(MetaKeyTable[i].MetaKey, &int64_val)) {
+            ALOGV("found metakey %s of type int64", MetaKeyTable[i].MsgKey);
+            format->get()->setInt64(MetaKeyTable[i].MsgKey, int64_val);
+        } else if (MetaKeyTable[i].KeyType == STRING &&
+                 meta->findCString(MetaKeyTable[i].MetaKey, &str_val)) {
+            ALOGV("found metakey %s of type string", MetaKeyTable[i].MsgKey);
+            format->get()->setString(MetaKeyTable[i].MsgKey, str_val);
+        } else if ( (MetaKeyTable[i].KeyType == DATA ||
+                   MetaKeyTable[i].KeyType == CSD) &&
+                   meta->findData(MetaKeyTable[i].MetaKey, &data_type, &data, &size)) {
+            ALOGV("found metakey %s of type data", MetaKeyTable[i].MsgKey);
+            if (MetaKeyTable[i].KeyType == CSD) {
+                const char *mime;
+                CHECK(meta->findCString(kKeyMIMEType, &mime));
+                if (strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) {
+                    sp<ABuffer> buffer = new ABuffer(size);
+                    memcpy(buffer->data(), data, size);
+                    buffer->meta()->setInt32("csd", true);
+                    buffer->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-0", buffer);
+                } else {
+                    const uint8_t *ptr = (const uint8_t *)data;
+                    CHECK(size >= 8);
+                    int seqLength = 0, picLength = 0;
+                    for (size_t i = 4; i < (size - 4); i++)
+                    {
+                        if ((*(ptr + i) == 0) && (*(ptr + i + 1) == 0) &&
+                           (*(ptr + i + 2) == 0) && (*(ptr + i + 3) == 1))
+                            seqLength = i;
+                    }
+                    sp<ABuffer> buffer = new ABuffer(seqLength);
+                    memcpy(buffer->data(), data, seqLength);
+                    buffer->meta()->setInt32("csd", true);
+                    buffer->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-0", buffer);
+                    picLength=size-seqLength;
+                    sp<ABuffer> buffer1 = new ABuffer(picLength);
+                    memcpy(buffer1->data(), (const uint8_t *)data + seqLength, picLength);
+                    buffer1->meta()->setInt32("csd", true);
+                    buffer1->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-1", buffer1);
+                }
+            } else {
+                sp<ABuffer> buffer = new ABuffer(size);
+                memcpy(buffer->data(), data, size);
+                format->get()->setBuffer(MetaKeyTable[i].MsgKey, buffer);
+            }
+        }
+
+    }
+}
+
+void FFMPEGSoftCodec::convertMessageToMetaDataFF(
+        const sp<AMessage> &msg, sp<MetaData> &meta) {
+    AString str_val;
+    int32_t int32_val;
+    int64_t int64_val;
+    static const size_t numMetaKeys =
+                     sizeof(MetaKeyTable) / sizeof(MetaKeyTable[0]);
+    size_t i;
+    for (i = 0; i < numMetaKeys; ++i) {
+        if (MetaKeyTable[i].KeyType == INT32 &&
+                msg->findInt32(MetaKeyTable[i].MsgKey, &int32_val)) {
+            ALOGV("found metakey %s of type int32", MetaKeyTable[i].MsgKey);
+            meta->setInt32(MetaKeyTable[i].MetaKey, int32_val);
+        } else if (MetaKeyTable[i].KeyType == INT64 &&
+                msg->findInt64(MetaKeyTable[i].MsgKey, &int64_val)) {
+            ALOGV("found metakey %s of type int64", MetaKeyTable[i].MsgKey);
+            meta->setInt64(MetaKeyTable[i].MetaKey, int64_val);
+        } else if (MetaKeyTable[i].KeyType == STRING &&
+                msg->findString(MetaKeyTable[i].MsgKey, &str_val)) {
+            ALOGV("found metakey %s of type string", MetaKeyTable[i].MsgKey);
+            meta->setCString(MetaKeyTable[i].MetaKey, str_val.c_str());
+        }
+    }
+}
+
+
+template<class T>
+static void InitOMXParams(T *params) {
+    params->nSize = sizeof(T);
+    params->nVersion.s.nVersionMajor = 1;
+    params->nVersion.s.nVersionMinor = 0;
+    params->nVersion.s.nRevision = 0;
+    params->nVersion.s.nStep = 0;
+}
+
+void FFMPEGSoftCodec::overrideComponentName(
+        uint32_t /*quirks*/, const sp<AMessage> &msg, AString* componentName, AString* mime, int32_t isEncoder) {
+
+    int32_t wmvVersion = 0;
+    if (!strncasecmp(mime->c_str(), MEDIA_MIMETYPE_VIDEO_WMV, strlen(MEDIA_MIMETYPE_VIDEO_WMV)) &&
+            msg->findInt32(getMsgKey(kKeyWMVVersion), &wmvVersion)) {
+        ALOGD("Found WMV version key %d", wmvVersion);
+        if (wmvVersion == 1) {
+            ALOGD("Use FFMPEG for unsupported WMV track");
+            componentName->setTo("OMX.ffmpeg.wmv.decoder");
+        }
+    }
+
+    int32_t encodeOptions = 0;
+    if (!isEncoder && !strncasecmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_WMA, strlen(MEDIA_MIMETYPE_AUDIO_WMA)) &&
+            !msg->findInt32(getMsgKey(kKeyWMAEncodeOpt), &encodeOptions)) {
+        ALOGD("Use FFMPEG for unsupported WMA track");
+        componentName->setTo("OMX.ffmpeg.wma.decoder");
+    }
+
+    // Google's decoder doesn't support MAIN profile
+    int32_t aacProfile = 0;
+    if (!isEncoder && !strncasecmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_AAC, strlen(MEDIA_MIMETYPE_AUDIO_AAC)) &&
+            msg->findInt32(getMsgKey(kKeyAACAOT), &aacProfile)) {
+        if (aacProfile == OMX_AUDIO_AACObjectMain) {
+            ALOGD("Use FFMPEG for AAC MAIN profile");
+            componentName->setTo("OMX.ffmpeg.aac.decoder");
+        }
+    }
+}
+
+status_t FFMPEGSoftCodec::setVideoFormat(
+        const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder,
+        OMX_VIDEO_CODINGTYPE *compressionFormat) {
+    status_t err = OK;
+
+    if (isEncoder) {
+        ALOGE("Encoding not supported");
+        err = BAD_VALUE;
+    
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)) {
+        err = setWMVFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setWMVFormat() failed (err = %d)", err);
+        } else {
+            *compressionFormat = OMX_VIDEO_CodingWMV;
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_RV, mime)) {
+        err = setRVFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setRVFormat() failed (err = %d)", err);
+        } else {
+            *compressionFormat = OMX_VIDEO_CodingRV;
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VC1, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVC1;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FLV1, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingFLV1;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingHEVC;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FFMPEG, mime)) {
+        ALOGV("Setting the OMX_VIDEO_PARAM_FFMPEGTYPE params");
+        err = setFFmpegVideoFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setFFmpegVideoFormat() failed (err = %d)", err);
+        } else {
+            *compressionFormat = OMX_VIDEO_CodingAutoDetect;
+        }
+    } else {
+        err = BAD_TYPE;
+    }
+
+    return err;
+}
+
+status_t FFMPEGSoftCodec::getVideoPortFormat(OMX_U32 portIndex, int coding,
+        sp<AMessage> &notify, sp<IOMX> OMXHandle, IOMX::node_id nodeId) {
+
+    status_t err = BAD_TYPE;
+    switch (coding) {
+        case OMX_VIDEO_CodingWMV:
+        {
+            OMX_VIDEO_PARAM_WMVTYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, OMX_IndexParamVideoWmv, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            int32_t version;
+            if (params.eFormat == OMX_VIDEO_WMVFormat7) {
+                version = kTypeWMVVer_7;
+            } else if (params.eFormat == OMX_VIDEO_WMVFormat8) {
+                version = kTypeWMVVer_8;
+            } else {
+                version = kTypeWMVVer_9;
+            }
+            notify->setString("mime", MEDIA_MIMETYPE_VIDEO_WMV);
+            notify->setInt32("wmv-version", version);
+            break;
+        }
+        case OMX_VIDEO_CodingAutoDetect:
+        {
+            OMX_VIDEO_PARAM_FFMPEGTYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, (OMX_INDEXTYPE)OMX_IndexParamVideoFFmpeg, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_VIDEO_FFMPEG);
+            notify->setInt32("codec-id", params.eCodecId);
+            break;
+        }
+        case OMX_VIDEO_CodingRV:
+        {
+            OMX_VIDEO_PARAM_RVTYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, (OMX_INDEXTYPE)OMX_IndexParamVideoRv, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            int32_t version;
+            if (params.eFormat == OMX_VIDEO_RVFormatG2) {
+                version = kTypeRVVer_G2;
+            } else if (params.eFormat == OMX_VIDEO_RVFormat8) {
+                version = kTypeRVVer_8;
+            } else {
+                version = kTypeRVVer_9;
+            }
+            notify->setString("mime", MEDIA_MIMETYPE_VIDEO_RV);
+            break;
+        }
+    }
+    return err;
+}
+
+status_t FFMPEGSoftCodec::getAudioPortFormat(OMX_U32 portIndex, int coding,
+        sp<AMessage> &notify, sp<IOMX> OMXHandle, IOMX::node_id nodeId) {
+
+    status_t err = BAD_TYPE;
+    switch (coding) {
+        case OMX_AUDIO_CodingRA:
+        {
+            OMX_AUDIO_PARAM_RATYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, OMX_IndexParamAudioRa, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_RA);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSamplingRate);
+            break;
+        }
+        case OMX_AUDIO_CodingMP2:
+        {
+            OMX_AUDIO_PARAM_MP2TYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, (OMX_INDEXTYPE)OMX_IndexParamAudioMp2, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSampleRate);
+            break;
+        }
+        case OMX_AUDIO_CodingWMA:
+        {
+            OMX_AUDIO_PARAM_WMATYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, OMX_IndexParamAudioWma, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_WMA);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSamplingRate);
+            break;
+        }
+        case OMX_AUDIO_CodingAPE:
+        {
+            OMX_AUDIO_PARAM_APETYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, (OMX_INDEXTYPE)OMX_IndexParamAudioApe, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_APE);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSamplingRate);
+            notify->setInt32("bit-width", params.nBitsPerSample);
+            break;
+        }
+        case OMX_AUDIO_CodingFLAC:
+        {
+            OMX_AUDIO_PARAM_FLACTYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, (OMX_INDEXTYPE)OMX_IndexParamAudioFlac, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_FLAC);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSampleRate);
+            notify->setInt32("bit-width", params.nCompressionLevel); // piggyback
+            break;
+        }
+
+        case OMX_AUDIO_CodingDTS:
+        {
+            OMX_AUDIO_PARAM_DTSTYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, (OMX_INDEXTYPE)OMX_IndexParamAudioDts, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_DTS);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSamplingRate);
+            break;
+        }
+        case OMX_AUDIO_CodingAC3:
+        {
+            OMX_AUDIO_PARAM_ANDROID_AC3TYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAc3, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_AC3);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSampleRate);
+            break;
+        }
+
+        case OMX_AUDIO_CodingAutoDetect:
+        {
+            OMX_AUDIO_PARAM_FFMPEGTYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = portIndex;
+
+            err = OMXHandle->getParameter(
+                    nodeId, (OMX_INDEXTYPE)OMX_IndexParamAudioFFmpeg, &params, sizeof(params));
+            if (err != OK) {
+                return err;
+            }
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_FFMPEG);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSampleRate);
+            break;
+        }
+    }
+    return err;
+}
+
+status_t FFMPEGSoftCodec::setAudioFormat(
+        const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID) {
+    ALOGV("setAudioFormat called");
+    status_t err = OK;
+
+    ALOGV("setAudioFormat: %s", msg->debugString(0).c_str());
+
+    if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_WMA, mime))  {
+        err = setWMAFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setWMAFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_VORBIS, mime))  {
+        err = setVORBISFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setVORBISFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_RA, mime))  {
+        err = setRAFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setRAFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_FLAC, mime))  {
+        err = setFLACFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setFLACFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II, mime))  {
+        err = setMP2Format(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setMP2Format() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AC3, mime)) {
+        err = setAC3Format(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setAC3Format() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_APE, mime))  {
+        err = setAPEFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setAPEFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_DTS, mime))  {
+        err = setDTSFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setDTSFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_FFMPEG, mime))  {
+        err = setFFmpegAudioFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setFFmpegAudioFormat() failed (err = %d)", err);
+        }
+    }
+
+    return err;
+}
+
+status_t FFMPEGSoftCodec::setSupportedRole(
+        const sp<IOMX> &omx, IOMX::node_id node,
+        bool isEncoder, const char *mime) {
+
+    ALOGV("setSupportedRole Called %s", mime);
+
+    struct MimeToRole {
+        const char *mime;
+        const char *decoderRole;
+        const char *encoderRole;
+    };
+
+    static const MimeToRole kFFMPEGMimeToRole[] = {
+        { MEDIA_MIMETYPE_AUDIO_AAC,
+          "audio_decoder.aac", NULL },
+        { MEDIA_MIMETYPE_AUDIO_MPEG,
+          "audio_decoder.mp3", NULL },
+        { MEDIA_MIMETYPE_AUDIO_VORBIS,
+          "audio_decoder.vorbis", NULL },
+        { MEDIA_MIMETYPE_AUDIO_WMA,
+          "audio_decoder.wma", NULL },
+        { MEDIA_MIMETYPE_AUDIO_RA,
+          "audio_decoder.ra" , NULL },
+        { MEDIA_MIMETYPE_AUDIO_FLAC,
+          "audio_decoder.flac", NULL },
+        { MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II,
+          "audio_decoder.mp2", NULL },
+        { MEDIA_MIMETYPE_AUDIO_AC3,
+          "audio_decoder.ac3", NULL },
+        { MEDIA_MIMETYPE_AUDIO_APE,
+          "audio_decoder.ape", NULL },
+        { MEDIA_MIMETYPE_AUDIO_DTS,
+          "audio_decoder.dts", NULL },
+        { MEDIA_MIMETYPE_VIDEO_MPEG2,
+          "video_decoder.mpeg2", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX4,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX311,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_WMV,
+          "video_decoder.wmv",  NULL },
+        { MEDIA_MIMETYPE_VIDEO_VC1,
+          "video_decoder.vc1", NULL },
+        { MEDIA_MIMETYPE_VIDEO_RV,
+          "video_decoder.rv", NULL },
+        { MEDIA_MIMETYPE_VIDEO_FLV1,
+          "video_decoder.flv1", NULL },
+        { MEDIA_MIMETYPE_VIDEO_HEVC,
+          "video_decoder.hevc", NULL },
+        { MEDIA_MIMETYPE_AUDIO_FFMPEG,
+          "audio_decoder.trial", NULL },
+        { MEDIA_MIMETYPE_VIDEO_FFMPEG,
+          "video_decoder.trial", NULL },
+        };
+    static const size_t kNumMimeToRole =
+                     sizeof(kFFMPEGMimeToRole) / sizeof(kFFMPEGMimeToRole[0]);
+
+    size_t i;
+    for (i = 0; i < kNumMimeToRole; ++i) {
+        if (!strcasecmp(mime, kFFMPEGMimeToRole[i].mime)) {
+            break;
+        }
+    }
+
+    if (i == kNumMimeToRole) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    const char *role =
+        isEncoder ? kFFMPEGMimeToRole[i].encoderRole
+                  : kFFMPEGMimeToRole[i].decoderRole;
+
+    if (role != NULL) {
+        OMX_PARAM_COMPONENTROLETYPE roleParams;
+        InitOMXParams(&roleParams);
+
+        strncpy((char *)roleParams.cRole,
+                role, OMX_MAX_STRINGNAME_SIZE - 1);
+
+        roleParams.cRole[OMX_MAX_STRINGNAME_SIZE - 1] = '\0';
+
+        status_t err = omx->setParameter(
+                node, OMX_IndexParamStandardComponentRole,
+                &roleParams, sizeof(roleParams));
+
+        if (err != OK) {
+            ALOGW("Failed to set standard component role '%s'.", role);
+            return err;
+        }
+    }
+    return OK;
+}
+
+//video
+status_t FFMPEGSoftCodec::setWMVFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t version = -1;
+    OMX_VIDEO_PARAM_WMVTYPE paramWMV;
+
+    if (!msg->findInt32(getMsgKey(kKeyWMVVersion), &version)) {
+        ALOGE("WMV version not detected");
+    }
+
+    InitOMXParams(&paramWMV);
+    paramWMV.nPortIndex = kPortIndexInput;
+
+    status_t err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamVideoWmv, &paramWMV, sizeof(paramWMV));
+    if (err != OK) {
+        return err;
+    }
+
+    if (version == kTypeWMVVer_7) {
+        paramWMV.eFormat = OMX_VIDEO_WMVFormat7;
+    } else if (version == kTypeWMVVer_8) {
+        paramWMV.eFormat = OMX_VIDEO_WMVFormat8;
+    } else if (version == kTypeWMVVer_9) {
+        paramWMV.eFormat = OMX_VIDEO_WMVFormat9;
+    }
+
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamVideoWmv, &paramWMV, sizeof(paramWMV));
+    return err;
+}
+
+status_t FFMPEGSoftCodec::setRVFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t version = kTypeRVVer_G2;
+    OMX_VIDEO_PARAM_RVTYPE paramRV;
+
+    if (!msg->findInt32(getMsgKey(kKeyRVVersion), &version)) {
+        ALOGE("RV version not detected");
+    }
+
+    InitOMXParams(&paramRV);
+    paramRV.nPortIndex = kPortIndexInput;
+
+    status_t err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamVideoRv, &paramRV, sizeof(paramRV));
+    if (err != OK)
+        return err;
+
+    if (version == kTypeRVVer_G2) {
+        paramRV.eFormat = OMX_VIDEO_RVFormatG2;
+    } else if (version == kTypeRVVer_8) {
+        paramRV.eFormat = OMX_VIDEO_RVFormat8;
+    } else if (version == kTypeRVVer_9) {
+        paramRV.eFormat = OMX_VIDEO_RVFormat9;
+    }
+
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamVideoRv, &paramRV, sizeof(paramRV));
+    return err;
+}
+
+status_t FFMPEGSoftCodec::setFFmpegVideoFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t codec_id = 0;
+    int32_t width = 0;
+    int32_t height = 0;
+    OMX_VIDEO_PARAM_FFMPEGTYPE param;
+
+    ALOGD("setFFmpegVideoFormat");
+
+    if (msg->findInt32(getMsgKey(kKeyWidth), &width)) {
+        ALOGE("No video width specified");
+    }
+    if (msg->findInt32(getMsgKey(kKeyHeight), &height)) {
+        ALOGE("No video height specified");
+    }
+    if (!msg->findInt32(getMsgKey(kKeyCodecId), &codec_id)) {
+        ALOGE("No codec id sent for FFMPEG catch-all codec!");
+    }
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    status_t err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamVideoFFmpeg, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.eCodecId = codec_id;
+    param.nWidth   = width;
+    param.nHeight  = height;
+
+    err = OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamVideoFFmpeg, &param, sizeof(param));
+    return err;
+}
+
+//audio
+status_t FFMPEGSoftCodec::setRawAudioFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    int32_t bitsPerSample = 16;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+    if (!msg->findInt32(getMsgKey(kKeyBitsPerSample), &bitsPerSample)) {
+        ALOGD("No PCM format specified, using 16 bit");
+    }
+
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexOutput;
+
+    status_t err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+    if (err != OK) {
+        return err;
+    }
+
+    def.format.audio.eEncoding = OMX_AUDIO_CodingPCM;
+
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+    if (err != OK) {
+        return err;
+    }
+
+    OMX_AUDIO_PARAM_PCMMODETYPE pcmParams;
+    InitOMXParams(&pcmParams);
+    pcmParams.nPortIndex = kPortIndexOutput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioPcm, &pcmParams, sizeof(pcmParams));
+
+    if (err != OK) {
+        return err;
+    }
+
+    pcmParams.nChannels = numChannels;
+    pcmParams.eNumData = OMX_NumericalDataSigned;
+    pcmParams.bInterleaved = OMX_TRUE;
+    pcmParams.nBitPerSample = bitsPerSample;
+    pcmParams.nSamplingRate = sampleRate;
+    pcmParams.ePCMMode = OMX_AUDIO_PCMModeLinear;
+
+    if (getOMXChannelMapping(numChannels, pcmParams.eChannelMapping) != OK) {
+        return OMX_ErrorNone;
+    }
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioPcm, &pcmParams, sizeof(pcmParams));
+}
+
+status_t FFMPEGSoftCodec::setWMAFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t version = 0;
+    int32_t numChannels = 0;
+    int32_t bitRate = 0;
+    int32_t sampleRate = 0;
+    int32_t blockAlign = 0;
+    int32_t bitsPerSample = 0;
+
+    OMX_AUDIO_PARAM_WMATYPE paramWMA;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+    CHECK(msg->findInt32(getMsgKey(kKeyBitRate), &bitRate));
+    if (!msg->findInt32(getMsgKey(kKeyBlockAlign), &blockAlign)) {
+        // we should be last on the codec list, but another sniffer may
+        // have handled it and there is no hardware codec.
+        if (!msg->findInt32(getMsgKey(kKeyWMABlockAlign), &blockAlign)) {
+            return ERROR_UNSUPPORTED;
+        }
+    }
+
+    // mm-parser may want a different bit depth
+    if (msg->findInt32(getMsgKey(kKeyWMABitspersample), &bitsPerSample)) {
+        msg->setInt32("bit-width", bitsPerSample);
+    }
+
+    ALOGV("Channels: %d, SampleRate: %d, BitRate: %d, blockAlign: %d",
+            numChannels, sampleRate, bitRate, blockAlign);
+
+    CHECK(msg->findInt32(getMsgKey(kKeyWMAVersion), &version));
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&paramWMA);
+    paramWMA.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+    if (err != OK)
+        return err;
+
+    paramWMA.nChannels = numChannels;
+    paramWMA.nSamplingRate = sampleRate;
+    paramWMA.nBitRate = bitRate;
+    paramWMA.nBlockAlign = blockAlign;
+
+    // http://msdn.microsoft.com/en-us/library/ff819498(v=vs.85).aspx
+    if (version == kTypeWMA) {
+        paramWMA.eFormat = OMX_AUDIO_WMAFormat7;
+    } else if (version == kTypeWMAPro) {
+        paramWMA.eFormat = OMX_AUDIO_WMAFormat8;
+    } else if (version == kTypeWMALossLess) {
+        paramWMA.eFormat = OMX_AUDIO_WMAFormat9;
+    }
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+}
+
+status_t FFMPEGSoftCodec::setVORBISFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    OMX_AUDIO_PARAM_VORBISTYPE param;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioVorbis, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSampleRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioVorbis, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setRAFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t bitRate = 0;
+    int32_t sampleRate = 0;
+    int32_t blockAlign = 0;
+    OMX_AUDIO_PARAM_RATYPE paramRA;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+    msg->findInt32(getMsgKey(kKeyBitRate), &bitRate);
+    CHECK(msg->findInt32(getMsgKey(kKeyBlockAlign), &blockAlign));
+
+    ALOGV("Channels: %d, SampleRate: %d, BitRate: %d, blockAlign: %d",
+            numChannels, sampleRate, bitRate, blockAlign);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&paramRA);
+    paramRA.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioRa, &paramRA, sizeof(paramRA));
+    if (err != OK)
+        return err;
+
+    paramRA.eFormat = OMX_AUDIO_RAFormatUnused; // FIXME, cook only???
+    paramRA.nChannels = numChannels;
+    paramRA.nSamplingRate = sampleRate;
+    // FIXME, HACK!!!, I use the nNumRegions parameter pass blockAlign!!!
+    // the cook audio codec need blockAlign!
+    paramRA.nNumRegions = blockAlign;
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioRa, &paramRA, sizeof(paramRA));
+}
+
+status_t FFMPEGSoftCodec::setFLACFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    int32_t bitsPerSample = 16;
+    OMX_AUDIO_PARAM_FLACTYPE param;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+    CHECK(msg->findInt32(getMsgKey(kKeyBitsPerSample), &bitsPerSample));
+
+    ALOGV("Channels: %d, SampleRate: %d BitsPerSample: %d",
+            numChannels, sampleRate, bitsPerSample);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioFlac, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSampleRate = sampleRate;
+    param.nCompressionLevel = bitsPerSample; // piggyback hax!
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioFlac, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setMP2Format(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    OMX_AUDIO_PARAM_MP2TYPE param;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioMp2, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSampleRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioMp2, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setAC3Format(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    OMX_AUDIO_PARAM_ANDROID_AC3TYPE param;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAc3, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSampleRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAc3, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setAPEFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    int32_t bitsPerSample = 0;
+    OMX_AUDIO_PARAM_APETYPE param;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+    CHECK(msg->findInt32(getMsgKey(kKeyBitsPerSample), &bitsPerSample));
+
+    ALOGV("Channels:%d, SampleRate:%d, bitsPerSample:%d",
+            numChannels, sampleRate, bitsPerSample);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioApe, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSamplingRate = sampleRate;
+    param.nBitsPerSample = bitsPerSample;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioApe, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setDTSFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    OMX_AUDIO_PARAM_DTSTYPE param;
+
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioDts, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSamplingRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioDts, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setFFmpegAudioFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t codec_id = 0;
+    int32_t numChannels = 0;
+    int32_t bitRate = 0;
+    int32_t bitsPerSample = 16;
+    int32_t sampleRate = 0;
+    int32_t blockAlign = 0;
+    int32_t sampleFormat = 0;
+    int32_t codedSampleBits = 0;
+    OMX_AUDIO_PARAM_FFMPEGTYPE param;
+
+    ALOGD("setFFmpegAudioFormat");
+
+    CHECK(msg->findInt32(getMsgKey(kKeyCodecId), &codec_id));
+    CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(getMsgKey(kKeySampleFormat), &sampleFormat));
+    msg->findInt32(getMsgKey(kKeyBitRate), &bitRate);
+    msg->findInt32(getMsgKey(kKeyBitsPerSample), &bitsPerSample);
+    msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate);
+    msg->findInt32(getMsgKey(kKeyBlockAlign), &blockAlign);
+    msg->findInt32(getMsgKey(kKeyBitsPerSample), &bitsPerSample);
+    msg->findInt32(getMsgKey(kKeyCodedSampleBits), &codedSampleBits);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioFFmpeg, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.eCodecId       = codec_id;
+    param.nChannels      = numChannels;
+    param.nBitRate       = bitRate;
+    param.nBitsPerSample = codedSampleBits;
+    param.nSampleRate    = sampleRate;
+    param.nBlockAlign    = blockAlign;
+    param.eSampleFormat  = sampleFormat;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioFFmpeg, &param, sizeof(param));
+}
+
+}
diff --git a/media/libstagefright/FileSource.cpp b/media/libstagefright/FileSource.cpp
index 565f156..f7b1a02 100644
--- a/media/libstagefright/FileSource.cpp
+++ b/media/libstagefright/FileSource.cpp
@@ -30,6 +30,7 @@ namespace android {
 
 FileSource::FileSource(const char *filename)
     : mFd(-1),
+      mUri(filename),
       mOffset(0),
       mLength(-1),
       mDecryptHandle(NULL),
@@ -58,6 +59,7 @@ FileSource::FileSource(int fd, int64_t offset, int64_t length)
       mDrmBuf(NULL){
     CHECK(offset >= 0);
     CHECK(length >= 0);
+    fetchUriFromFd(fd);
 }
 
 FileSource::~FileSource() {
@@ -188,4 +190,18 @@ ssize_t FileSource::readAtDRM(off64_t offset, void *data, size_t size) {
         return mDrmManagerClient->pread(mDecryptHandle, data, size, offset + mOffset);
     }
 }
+
+void FileSource::fetchUriFromFd(int fd) {
+    ssize_t len = 0;
+    char path[PATH_MAX] = {0};
+    char link[PATH_MAX] = {0};
+
+    mUri.clear();
+
+    snprintf(path, PATH_MAX, "/proc/%d/fd/%d", getpid(), fd);
+    if ((len = readlink(path, link, sizeof(link)-1)) != -1) {
+        link[len] = '\0';
+        mUri.setTo(link);
+    }
+}
 }  // namespace android
diff --git a/media/libstagefright/MediaCodec.cpp b/media/libstagefright/MediaCodec.cpp
index c4f4389..759bc24 100644
--- a/media/libstagefright/MediaCodec.cpp
+++ b/media/libstagefright/MediaCodec.cpp
@@ -1177,7 +1177,8 @@ void MediaCodec::onMessageReceived(const sp<AMessage> &msg) {
 
                     CHECK(msg->findString("componentName", &mComponentName));
 
-                    if (mComponentName.startsWith("OMX.google.")) {
+                    if (mComponentName.startsWith("OMX.google.") ||
+                            mComponentName.startsWith("OMX.ffmpeg.")) {
                         mFlags |= kFlagUsesSoftwareRenderer;
                     } else {
                         mFlags &= ~kFlagUsesSoftwareRenderer;
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index 4077bd3..e21d8f2 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -86,4 +86,32 @@ const char *MEDIA_MIMETYPE_TEXT_VTT = "text/vtt";
 const char *MEDIA_MIMETYPE_TEXT_CEA_608 = "text/cea-608";
 const char *MEDIA_MIMETYPE_DATA_TIMED_ID3 = "application/x-id3v4";
 
+const char *MEDIA_MIMETYPE_VIDEO_FLV1 = "video/x-flv";
+const char *MEDIA_MIMETYPE_VIDEO_MJPEG = "video/x-jpeg";
+const char *MEDIA_MIMETYPE_VIDEO_RV = "video/vnd.rn-realvideo";
+const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/vc1";
+const char *MEDIA_MIMETYPE_VIDEO_FFMPEG = "video/ffmpeg";
+
+const char *MEDIA_MIMETYPE_AUDIO_PCM = "audio/x-pcm";
+const char *MEDIA_MIMETYPE_AUDIO_RA = "audio/vnd.rn-realaudio";
+const char *MEDIA_MIMETYPE_AUDIO_FFMPEG = "audio/ffmpeg";
+
+const char *MEDIA_MIMETYPE_CONTAINER_APE = "audio/x-ape";
+const char *MEDIA_MIMETYPE_CONTAINER_DIVX = "video/divx";
+const char *MEDIA_MIMETYPE_CONTAINER_DTS = "audio/vnd.dts";
+const char *MEDIA_MIMETYPE_CONTAINER_FLAC = "audio/flac";
+const char *MEDIA_MIMETYPE_CONTAINER_FLV = "video/x-flv";
+const char *MEDIA_MIMETYPE_CONTAINER_MOV = "video/quicktime";
+const char *MEDIA_MIMETYPE_CONTAINER_MP2 = "audio/mpeg2";
+const char *MEDIA_MIMETYPE_CONTAINER_MPG = "video/mpeg";
+const char *MEDIA_MIMETYPE_CONTAINER_RA = "audio/vnd.rn-realaudio";
+const char *MEDIA_MIMETYPE_CONTAINER_RM = "video/vnd.rn-realvideo";
+const char *MEDIA_MIMETYPE_CONTAINER_TS = "video/mp2t";
+const char *MEDIA_MIMETYPE_CONTAINER_WEBM = "video/webm";
+const char *MEDIA_MIMETYPE_CONTAINER_WMA = "audio/x-ms-wma";
+const char *MEDIA_MIMETYPE_CONTAINER_WMV = "video/x-ms-wmv";
+const char *MEDIA_MIMETYPE_CONTAINER_VC1 = "video/vc1";
+const char *MEDIA_MIMETYPE_CONTAINER_HEVC = "video/hevc";
+const char *MEDIA_MIMETYPE_CONTAINER_FFMPEG = "video/ffmpeg";
+
 }  // namespace android
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index bfb2a16..fc96e2f 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -44,6 +44,8 @@
 
 namespace android {
 
+MediaExtractor::Plugin MediaExtractor::sPlugin;
+
 sp<MetaData> MediaExtractor::getMetaData() {
     return new MetaData;
 }
@@ -58,9 +60,15 @@ sp<MediaExtractor> MediaExtractor::Create(
         const uint32_t flags) {
     sp<AMessage> meta;
 
+    bool secondPass = false;
+
     String8 tmp;
-    if (mime == NULL) {
+retry:
+    if (secondPass || mime == NULL) {
         float confidence;
+        if (secondPass) {
+            confidence = 3.14f;
+        }
         if (!source->sniff(&tmp, &confidence, &meta)) {
             ALOGV("FAILED to autodetect media content.");
 
@@ -95,7 +103,12 @@ sp<MediaExtractor> MediaExtractor::Create(
     }
 
     sp<MediaExtractor> ret = NULL;
+    AString extractorName;
     if ((ret = AVFactory::get()->createExtendedExtractor(source, mime, meta, flags)) != NULL) {
+    } else if (meta.get() && meta->findString("extended-extractor-use", &extractorName)
+            && sPlugin.create) {
+        ALOGI("Use extended extractor for the special mime(%s) or codec", mime);
+        ret = sPlugin.create(source, mime, meta);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)
             || !strcasecmp(mime, "audio/mp4")) {
         ret = new MPEG4Extractor(source);
@@ -123,6 +136,8 @@ sp<MediaExtractor> MediaExtractor::Create(
         ret = new MPEG2PSExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MIDI)) {
         ret = new MidiExtractor(source);
+    } else if (!isDrm && sPlugin.create) {
+        ret = sPlugin.create(source, mime, meta);
     }
 
     ret = AVFactory::get()->updateExtractor(ret, source, mime, meta, flags);
@@ -134,6 +149,15 @@ sp<MediaExtractor> MediaExtractor::Create(
        }
     }
 
+    if (ret != NULL) {
+
+        if (!secondPass && ( ret->countTracks() == 0 ||
+                    (!strncasecmp("video/", mime, 6) && ret->countTracks() < 2) ) ) {
+            secondPass = true;
+            goto retry;
+        }
+    }
+
     return ret;
 }
 
diff --git a/media/libstagefright/OMXClient.cpp b/media/libstagefright/OMXClient.cpp
index e69890d..ac925f7 100644
--- a/media/libstagefright/OMXClient.cpp
+++ b/media/libstagefright/OMXClient.cpp
@@ -181,6 +181,7 @@ bool MuxOMX::isLocalNode_l(node_id node) const {
 }
 
 // static
+
 bool MuxOMX::CanLiveLocally(const char *name) {
 #ifdef __LP64__
     (void)name; // disable unused parameter warning
diff --git a/media/libstagefright/StagefrightMediaScanner.cpp b/media/libstagefright/StagefrightMediaScanner.cpp
index a757181..c5018ae 100644
--- a/media/libstagefright/StagefrightMediaScanner.cpp
+++ b/media/libstagefright/StagefrightMediaScanner.cpp
@@ -42,7 +42,11 @@ static bool FileHasAcceptableExtension(const char *extension) {
         ".mpeg", ".ogg", ".mid", ".smf", ".imy", ".wma", ".aac",
         ".wav", ".amr", ".midi", ".xmf", ".rtttl", ".rtx", ".ota",
         ".mkv", ".mka", ".webm", ".ts", ".fl", ".flac", ".mxmf",
-        ".avi", ".mpeg", ".mpg", ".awb", ".mpga"
+        ".adts", ".dm", ".m2ts", ".mp3d", ".wmv", ".asf", ".flv",
+        ".mov", ".ra", ".rm", ".rmvb", ".ac3", ".ape", ".dts",
+        ".mp1", ".mp2", ".f4v", "hlv", "nrg", "m2v", ".swf",
+        ".avi", ".mpg", ".mpeg", ".awb", ".vc1", ".vob", ".divx",
+        ".mpga", ".mov", ".qcp", ".ec3"
     };
     static const size_t kNumValidExtensions =
         sizeof(kValidExtensions) / sizeof(kValidExtensions[0]);
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index ea3fa8e..5c63392 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -55,6 +55,7 @@
 #include <media/AudioParameter.h>
 
 #include <stagefright/AVExtensions.h>
+#include <media/stagefright/FFMPEGSoftCodec.h>
 
 namespace android {
 
@@ -125,7 +126,7 @@ status_t convertMetaDataToMessage(
 
     int avgBitRate;
     if (meta->findInt32(kKeyBitRate, &avgBitRate)) {
-        msg->setInt32("bit-rate", avgBitRate);
+        msg->setInt32("bitrate", avgBitRate);
     }
 
     int32_t isSync;
@@ -224,6 +225,11 @@ status_t convertMetaDataToMessage(
         msg->setInt32("frame-rate", fps);
     }
 
+    int32_t bitsPerSample;
+    if (meta->findInt32(kKeyBitsPerSample, &bitsPerSample)) {
+        msg->setInt32("bit-width", bitsPerSample);
+    }
+
     uint32_t type;
     const void *data;
     size_t size;
@@ -333,6 +339,7 @@ status_t convertMetaDataToMessage(
             ALOGE("b/23680780");
             return BAD_VALUE;
         }
+
         uint8_t profile __unused = ptr[1] & 31;
         uint8_t level __unused = ptr[12];
         ptr += 22;
@@ -475,8 +482,14 @@ status_t convertMetaDataToMessage(
     }
 
     AVUtils::get()->convertMetaDataToMessage(meta, &msg);
+
+    FFMPEGSoftCodec::convertMetaDataToMessageFF(meta, &msg);
     *format = msg;
 
+    ALOGI("convertMetaDataToMessage from:");
+    meta->dumpToLog();
+    ALOGI("  to: %s", msg->debugString(0).c_str());
+
     return OK;
 }
 
@@ -668,6 +681,11 @@ void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {
         if (msg->findInt32("is-adts", &isADTS)) {
             meta->setInt32(kKeyIsADTS, isADTS);
         }
+
+        int32_t bitsPerSample;
+        if (msg->findInt32("bit-width", &bitsPerSample)) {
+            meta->setInt32(kKeyBitsPerSample, bitsPerSample);
+        }
     }
 
     int32_t maxInputSize;
@@ -727,10 +745,10 @@ void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {
 
     // XXX TODO add whatever other keys there are
 
-#if 0
-    ALOGI("converted %s to:", msg->debugString(0).c_str());
+    FFMPEGSoftCodec::convertMessageToMetaDataFF(msg, meta);
+
+    ALOGI("convertMessageToMetaData from %s to:", msg->debugString(0).c_str());
     meta->dumpToLog();
-#endif
 }
 
 AString MakeUserAgent() {
@@ -881,6 +899,7 @@ bool canOffloadStream(const sp<MetaData>& meta, bool hasVideo,
     if (AVUtils::get()->canOffloadAPE(meta) != true) {
         return false;
     }
+    ALOGV("Mime type \"%s\" mapped to audio_format %d", mime, info.format);
 
     // Redefine aac format according to its profile
     // Offloading depends on audio DSP capabilities.
diff --git a/media/libstagefright/codecs/raw/SoftRaw.cpp b/media/libstagefright/codecs/raw/SoftRaw.cpp
index 4067a1b..f90c1b3 100644
--- a/media/libstagefright/codecs/raw/SoftRaw.cpp
+++ b/media/libstagefright/codecs/raw/SoftRaw.cpp
@@ -42,7 +42,8 @@ SoftRaw::SoftRaw(
     : SimpleSoftOMXComponent(name, callbacks, appData, component),
       mSignalledError(false),
       mChannelCount(2),
-      mSampleRate(44100) {
+      mSampleRate(44100),
+      mBitsPerSample(16) {
     initPorts();
     CHECK_EQ(initDecoder(), (status_t)OK);
 }
@@ -114,7 +115,7 @@ OMX_ERRORTYPE SoftRaw::internalGetParameter(
             pcmParams->eNumData = OMX_NumericalDataSigned;
             pcmParams->eEndian = OMX_EndianBig;
             pcmParams->bInterleaved = OMX_TRUE;
-            pcmParams->nBitPerSample = 16;
+            pcmParams->nBitPerSample = mBitsPerSample;
             pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
             pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
             pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;
@@ -166,6 +167,7 @@ OMX_ERRORTYPE SoftRaw::internalSetParameter(
 
             mChannelCount = pcmParams->nChannels;
             mSampleRate = pcmParams->nSamplingRate;
+            mBitsPerSample = pcmParams->nBitPerSample;
 
             return OMX_ErrorNone;
         }
diff --git a/media/libstagefright/codecs/raw/SoftRaw.h b/media/libstagefright/codecs/raw/SoftRaw.h
index 94b0ef1..894889f 100644
--- a/media/libstagefright/codecs/raw/SoftRaw.h
+++ b/media/libstagefright/codecs/raw/SoftRaw.h
@@ -50,6 +50,7 @@ private:
 
     int32_t mChannelCount;
     int32_t mSampleRate;
+    int32_t mBitsPerSample;
 
     void initPorts();
     status_t initDecoder();
diff --git a/media/libstagefright/include/AwesomePlayer.h b/media/libstagefright/include/AwesomePlayer.h
index 9682159..1a8e6c8 100644
--- a/media/libstagefright/include/AwesomePlayer.h
+++ b/media/libstagefright/include/AwesomePlayer.h
@@ -196,6 +196,7 @@ private:
     uint32_t mFlags;
     uint32_t mExtractorFlags;
     uint32_t mSinceLastDropped;
+    bool mDropFramesDisable; // hevc test
 
     int64_t mTimeSourceDeltaUs;
     int64_t mVideoTimeUs;
diff --git a/services/audioflinger/AudioMixer.h b/services/audioflinger/AudioMixer.h
index 7165c6c..f0ae4ec 100644
--- a/services/audioflinger/AudioMixer.h
+++ b/services/audioflinger/AudioMixer.h
@@ -137,6 +137,7 @@ public:
         case AUDIO_FORMAT_PCM_8_BIT:
         case AUDIO_FORMAT_PCM_16_BIT:
         case AUDIO_FORMAT_PCM_24_BIT_PACKED:
+        case AUDIO_FORMAT_PCM_8_24_BIT:
         case AUDIO_FORMAT_PCM_32_BIT:
         case AUDIO_FORMAT_PCM_FLOAT:
             return true;
-- 
2.7.4


From f3b816c7e1464a356f7192539cdfb0f1c1054818 Mon Sep 17 00:00:00 2001
From: Scott Mertz <scott@cyngn.com>
Date: Thu, 29 Oct 2015 01:36:11 -0700
Subject: [PATCH 010/119] libstagefright: fix size_t printf format

size_t should use the portable %zu

Change-Id: I974d4be7d4921a8c3fc684d24721a231c5b91170
---
 media/libstagefright/WAVExtractor.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/media/libstagefright/WAVExtractor.cpp b/media/libstagefright/WAVExtractor.cpp
index 858d91c..16c16c1 100644
--- a/media/libstagefright/WAVExtractor.cpp
+++ b/media/libstagefright/WAVExtractor.cpp
@@ -447,7 +447,7 @@ status_t WAVSource::read(
         maxBytesToRead = 3*(kMaxFrameSize/4);
     } else
         maxBytesToRead = kMaxFrameSize;
-    ALOGV("%s mBitsPerSample %d, kMaxFrameSize %d, ",
+    ALOGV("%s mBitsPerSample %d, kMaxFrameSize %zu, ",
           __func__, mBitsPerSample, kMaxFrameSize);
 
     size_t maxBytesAvailable =
@@ -514,7 +514,7 @@ status_t WAVSource::read(
             tmp->set_range(0, 4 * numBytes);
             int8_t *dst = (int8_t *)tmp->data();
             const uint8_t *src = (const uint8_t *)buffer->data();
-            ALOGV("numBytes = %d", numBytes);
+            ALOGV("numBytes = %zd", numBytes);
             while(numBytes-- > 0) {
                *dst++ = 0x0;
                *dst++ = src[0];
@@ -524,7 +524,7 @@ status_t WAVSource::read(
             }
             buffer->release();
             buffer = tmp;
-            ALOGV("length = %d", buffer->range_length());
+            ALOGV("length = %zu", buffer->range_length());
         }
     }
 
-- 
2.7.4


From 3cd24db407a48e1dbb65e9d7107dc1f4f268f2e4 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 5 Nov 2015 02:43:05 -0800
Subject: [PATCH 011/119] stagefright: Unbreak video encoding

 * Fix logic for the FFMPEG video case- we should have only been
   checking for errors when actually calling into our extension.

Change-Id: Ic9fa6ad3913f259c09f0dd37b1720d996ecc386c
---
 media/libstagefright/ACodec.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index c68971a..d380ad5 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -4280,9 +4280,9 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
                         err = FFMPEGSoftCodec::getVideoPortFormat(portIndex,
                                 (int)videoDef->eCompressionFormat, notify, mOMX, mNode);
-                    }
-                    if (err == OK) {
-                        break;
+                        if (err == OK) {
+                            break;
+                        }
                     }
 
                     if (mIsEncoder ^ (portIndex == kPortIndexOutput)) {
-- 
2.7.4


From 9f67b3bc54fff4f54e0b9798ea37ef4e4dfde92c Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sun, 1 Nov 2015 02:54:47 -0800
Subject: [PATCH 012/119] stagefright: Fix size of metadata key

 * Causes build failure with Clang

Change-Id: I957c9ad2f1a46c784b38e284063b5310bf9cc7ed
---
 include/media/stagefright/MetaData.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index 275ef55..0dd5995 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -150,7 +150,7 @@ enum {
 
     kKeyWMVVersion        = 'wmvv',  // int32_t
     kKeyRVVersion         = '#rvv',  // int32_t
-    kKeyBlockAlign        = 'blk',   // int32_t , should be different from kKeyWMABlockAlign
+    kKeyBlockAlign        = 'ablk',   // int32_t , should be different from kKeyWMABlockAlign
 
     // An indication that a video buffer has been rendered.
     kKeyRendered          = 'rend',  // bool (int32_t)
-- 
2.7.4


From d78a83caeb1bec139728222958b3881950f9ac30 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 5 Nov 2015 12:39:08 -0800
Subject: [PATCH 013/119] stagefright: Reduce logspam

Change-Id: I316d82226ea5b8486e4aefae0d69a361ab115006
---
 media/libstagefright/FFMPEGSoftCodec.cpp | 2 +-
 media/libstagefright/Utils.cpp           | 4 ++++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 3e6692b..5c6a8ed 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_NDEBUG 0
+//#define LOG_NDEBUG 0
 #define LOG_TAG "FFMPEGSoftCodec"
 #include <utils/Log.h>
 
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 5c63392..60a5877 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -486,9 +486,11 @@ status_t convertMetaDataToMessage(
     FFMPEGSoftCodec::convertMetaDataToMessageFF(meta, &msg);
     *format = msg;
 
+#if 0
     ALOGI("convertMetaDataToMessage from:");
     meta->dumpToLog();
     ALOGI("  to: %s", msg->debugString(0).c_str());
+#endif
 
     return OK;
 }
@@ -747,8 +749,10 @@ void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {
 
     FFMPEGSoftCodec::convertMessageToMetaDataFF(msg, meta);
 
+#if 0
     ALOGI("convertMessageToMetaData from %s to:", msg->debugString(0).c_str());
     meta->dumpToLog();
+#endif
 }
 
 AString MakeUserAgent() {
-- 
2.7.4


From 578bbb6e4324882640fa60e38070e0beaa8d4b5c Mon Sep 17 00:00:00 2001
From: Ziyan <jaraidaniel@gmail.com>
Date: Sun, 12 Apr 2015 21:02:20 +0200
Subject: [PATCH 014/119] libstagefright: add missing TI color format case

Change-Id: Iaca45e6b15d3315a39b51bbf7f0cf3a1e912fee9
---
 media/libstagefright/ACodec.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index d380ad5..bba0982 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -3981,6 +3981,7 @@ bool ACodec::describeDefaultColorFormat(DescribeColorFormatParams &params) {
         fmt != OMX_COLOR_FormatYUV420PackedPlanar &&
         fmt != OMX_COLOR_FormatYUV420SemiPlanar &&
         fmt != OMX_COLOR_FormatYUV420PackedSemiPlanar &&
+        fmt != OMX_TI_COLOR_FormatYUV420PackedSemiPlanar &&
         fmt != HAL_PIXEL_FORMAT_YV12) {
         ALOGW("do not know color format 0x%x = %d", fmt, fmt);
         return false;
@@ -4053,6 +4054,7 @@ bool ACodec::describeDefaultColorFormat(DescribeColorFormatParams &params) {
         case OMX_COLOR_FormatYUV420SemiPlanar:
             // FIXME: NV21 for sw-encoder, NV12 for decoder and hw-encoder
         case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
             // NV12
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
             image.mPlane[image.U].mColInc = 2;
-- 
2.7.4


From 3202aae848444d442b60511d295ea5961f22ed6c Mon Sep 17 00:00:00 2001
From: Michael Gernoth <michael@gernoth.net>
Date: Mon, 24 Nov 2014 21:25:28 +0100
Subject: [PATCH 015/119] libstagefright: Make it possible to skip OMX buffer
 reallocation

Some devices don't like the call to setParameter() at this point, so
skip this call if enough buffers are already allocated. This check
was present in KitKat but got removed when code to allocate extra-
buffers was introduced.

This is activated only for omap4 for now.

Squashed 2nd commit: which does same for OMXCodec.cpp

Change-Id: I9c1267c2a2a755bc16448a6049cb2e4aff0b65bb
Signed-off-by: Josue Rivera <prbassplayer@gmail.com>
---
 media/libstagefright/ACodec.cpp   |  9 +++++++++
 media/libstagefright/Android.mk   |  4 ++++
 media/libstagefright/OMXCodec.cpp | 10 +++++++++-
 3 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index bba0982..7642e93 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -1046,6 +1046,12 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
     // 2. try to allocate two (2) additional buffers to reduce starvation from
     //    the consumer
     //    plus an extra buffer to account for incorrect minUndequeuedBufs
+#ifdef BOARD_CANT_REALLOCATE_OMX_BUFFERS
+    // Some devices don't like to set OMX_IndexParamPortDefinition at this
+    // point (even with an unmodified def), so skip it if possible.
+    // This check was present in KitKat.
+    if (def.nBufferCountActual < def.nBufferCountMin + *minUndequeuedBuffers) {
+#endif
     for (OMX_U32 extraBuffers = 2 + 1; /* condition inside loop */; extraBuffers--) {
         OMX_U32 newBufferCount =
             def.nBufferCountMin + *minUndequeuedBuffers + extraBuffers;
@@ -1065,6 +1071,9 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
             return err;
         }
     }
+#ifdef BOARD_CANT_REALLOCATE_OMX_BUFFERS
+    }
+#endif
 
     err = native_window_set_buffer_count(
             mNativeWindow.get(), def.nBufferCountActual);
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index dcea5a9..866add5 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -166,6 +166,10 @@ ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
 LOCAL_CFLAGS += -DENABLE_STAGEFRIGHT_EXPERIMENTS
 endif
 
+ifeq ($(TARGET_BOARD_PLATFORM),omap4)
+LOCAL_CFLAGS += -DBOARD_CANT_REALLOCATE_OMX_BUFFERS
+endif
+
 ifeq ($(call is-vendor-board-platform,QCOM),true)
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_EXTN_FLAC_DECODER)),true)
     LOCAL_CFLAGS += -DQTI_FLAC_DECODER
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 0cb2d92..ba6bc67 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -1895,7 +1895,12 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     //    plus an extra buffer to account for incorrect minUndequeuedBufs
     CODEC_LOGI("OMX-buffers: min=%u actual=%u undeq=%d+1",
             def.nBufferCountMin, def.nBufferCountActual, minUndequeuedBufs);
-
+#ifdef BOARD_CANT_REALLOCATE_OMX_BUFFERS
+    // Some devices don't like to set OMX_IndexParamPortDefinition at this
+    // point (even with an unmodified def), so skip it if possible.
+    // This check was present in KitKat.
+    if (def.nBufferCountActual < def.nBufferCountMin + minUndequeuedBufs) {
+#endif
     for (OMX_U32 extraBuffers = 2 + 1; /* condition inside loop */; extraBuffers--) {
         OMX_U32 newBufferCount =
             def.nBufferCountMin + minUndequeuedBufs + extraBuffers;
@@ -1917,6 +1922,9 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     }
     CODEC_LOGI("OMX-buffers: min=%u actual=%u undeq=%d+1",
             def.nBufferCountMin, def.nBufferCountActual, minUndequeuedBufs);
+#ifdef BOARD_CANT_REALLOCATE_OMX_BUFFERS
+    }
+#endif
 
     err = native_window_set_buffer_count(
             mNativeWindow.get(), def.nBufferCountActual);
-- 
2.7.4


From 1a271f200def076db26bdd12d0e2ee52d6247b56 Mon Sep 17 00:00:00 2001
From: Marco Nelissen <marcone@google.com>
Date: Thu, 29 Oct 2015 14:10:48 -0700
Subject: [PATCH 016/119] MatroskaExtractor: don't use new buffer unless
 necessary

When the NAL size length is 4 bytes, we can store the start code in the space
occupied by the NAL size length and avoid allocating a new buffer and copying
the data into it.
Also fix potential memory leak.

Change-Id: I29dd72a0616dfae66ddd7b7f9478678e356df440
---
 .../libstagefright/matroska/MatroskaExtractor.cpp  | 23 ++++++++++++++++------
 1 file changed, 17 insertions(+), 6 deletions(-)

diff --git a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
index 5746203..9377b17 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -560,6 +560,7 @@ status_t MatroskaSource::readBlock() {
             mPendingFrames.clear();
 
             mBlockIter.advance();
+            mbuf->release();
             return ERROR_IO;
         }
 
@@ -680,9 +681,11 @@ status_t MatroskaSource::read(
             if (pass == 1) {
                 memcpy(&dstPtr[dstOffset], "\x00\x00\x00\x01", 4);
 
-                memcpy(&dstPtr[dstOffset + 4],
-                       &srcPtr[srcOffset + mNALSizeLen],
-                       NALsize);
+                if (frame != buffer) {
+                    memcpy(&dstPtr[dstOffset + 4],
+                           &srcPtr[srcOffset + mNALSizeLen],
+                           NALsize);
+                }
             }
 
             dstOffset += 4;  // 0x00 00 00 01
@@ -704,7 +707,13 @@ status_t MatroskaSource::read(
         if (pass == 0) {
             dstSize = dstOffset;
 
-            buffer = new MediaBuffer(dstSize);
+            if (dstSize == srcSize && mNALSizeLen == 4) {
+                // In this special case we can re-use the input buffer by substituting
+                // each 4-byte nal size with a 4-byte start code
+                buffer = frame;
+            } else {
+                buffer = new MediaBuffer(dstSize);
+            }
 
             int64_t timeUs;
             CHECK(frame->meta_data()->findInt64(kKeyTime, &timeUs));
@@ -718,8 +727,10 @@ status_t MatroskaSource::read(
         }
     }
 
-    frame->release();
-    frame = NULL;
+    if (frame != buffer) {
+        frame->release();
+        frame = NULL;
+    }
 
     if (targetSampleTimeUs >= 0ll) {
         buffer->meta_data()->setInt64(
-- 
2.7.4


From b34bdb67f3e051dc6eac53cf3e464650fdfb666a Mon Sep 17 00:00:00 2001
From: Ethan Chen <intervigil@gmail.com>
Date: Thu, 19 Nov 2015 15:33:02 -0800
Subject: [PATCH 017/119] stagefright: ACodec: Correctly handle FLAC port
 format

* Handle FFMPEG FLAC codecs correctly, otherwise do the default codec
  behavior.

Change-Id: Ib8c1c5037060ff1c5ea0a5317ab190ce2e306c1e
---
 media/libstagefright/ACodec.cpp | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 7642e93..49baf3c 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -4410,7 +4410,13 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
 
                 case OMX_AUDIO_CodingFLAC:
                 {
-                    if (portIndex == kPortIndexInput) {
+                    if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+                        err = FFMPEGSoftCodec::getAudioPortFormat(portIndex,
+                                (int)audioDef->eEncoding, notify, mOMX, mNode);
+                        if (err != OK) {
+                            return err;
+                        }
+                    } else {
                     OMX_AUDIO_PARAM_FLACTYPE params;
                     InitOMXParams(&params);
                     params.nPortIndex = portIndex;
@@ -4424,8 +4430,8 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setString("mime", MEDIA_MIMETYPE_AUDIO_FLAC);
                     notify->setInt32("channel-count", params.nChannels);
                     notify->setInt32("sample-rate", params.nSampleRate);
-                    break;
                     }
+                    break;
                 }
 
                 case OMX_AUDIO_CodingMP3:
-- 
2.7.4


From a176124c69e1ddeb6a5e195558dbba120056d301 Mon Sep 17 00:00:00 2001
From: Diogo Ferreira <defer@cyngn.com>
Date: Thu, 19 Nov 2015 18:48:52 +0000
Subject: [PATCH 018/119] stagefright: ACodec: Don't return success when
 encoders fail to init

When configureCodec fails we try to fallback to another codec that
supports the mimeType. However, this fallback is only done for
decoders and, if encoders fail, they will always end up sending
a success notification and returning true, causing mediaserver to
crash.

Change-Id: I32bee3167a8b43243cd708258435174f90f21a1b
---
 media/libstagefright/ACodec.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 49baf3c..58d3e73 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -5969,11 +5969,11 @@ bool ACodec::LoadedState::onConfigureComponent(
             mCodec->mComponentName = componentName;
 
             err = mCodec->configureCodec(mime.c_str(), msg);
+        }
 
-            if (err != OK) {
-                mCodec->signalError((OMX_ERRORTYPE)err, makeNoSideEffectStatus(err));
-                return false;
-            }
+        if (err != OK) {
+            mCodec->signalError((OMX_ERRORTYPE)err, makeNoSideEffectStatus(err));
+            return false;
         }
     }
 
-- 
2.7.4


From 79a98954891ff0ddfd067fdd03a02f9da2815f30 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Wed, 18 Nov 2015 16:26:56 -0800
Subject: [PATCH 019/119] Revert "DataSource: Remove global variables in
 DataSource related to sniff"

 * Don't change the ABI.  Fun times.

This reverts commit 4440ef8efc77d1bd7838885e83d41e54deb5a3b8.

Change-Id: Ie9e0812f5e4ee700c29b76a413083858ec0255c9
---
 include/media/stagefright/DataSource.h |  42 ++-----------
 media/libstagefright/DataSource.cpp    | 106 ++++++++++++++++-----------------
 2 files changed, 56 insertions(+), 92 deletions(-)

diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index 82f75bd..c0401cf 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -36,40 +36,6 @@ class  IDataSource;
 struct IMediaHTTPService;
 class String8;
 struct HTTPBase;
-class DataSource;
-
-class Sniffer : public RefBase {
-public:
-    Sniffer();
-
-    ////////////////////////////////////////////////////////////////////////////
-
-    bool sniff(DataSource *source, String8 *mimeType, float *confidence, sp<AMessage> *meta);
-
-    // The sniffer can optionally fill in "meta" with an AMessage containing
-    // a dictionary of values that helps the corresponding extractor initialize
-    // its state without duplicating effort already exerted by the sniffer.
-    typedef bool (*SnifferFunc)(
-            const sp<DataSource> &source, String8 *mimeType,
-            float *confidence, sp<AMessage> *meta);
-
-    //if isExtendedExtractor = true, store the location of the sniffer to register
-    void registerSniffer_l(SnifferFunc func);
-    void registerDefaultSniffers();
-
-    virtual ~Sniffer() {}
-
-private:
-    Mutex mSnifferMutex;
-    List<SnifferFunc> mSniffers;
-    List<SnifferFunc> mExtraSniffers;
-    List<SnifferFunc>::iterator extendedSnifferPosition;
-
-    void registerSnifferPlugin();
-
-    Sniffer(const Sniffer &);
-    Sniffer &operator=(const Sniffer &);
-};
 
 class DataSource : public RefBase {
 public:
@@ -91,7 +57,7 @@ public:
     static sp<DataSource> CreateMediaHTTP(const sp<IMediaHTTPService> &httpService);
     static sp<DataSource> CreateFromIDataSource(const sp<IDataSource> &source);
 
-    DataSource() : mSniffer(new Sniffer()) {}
+    DataSource() {}
 
     virtual status_t initCheck() const = 0;
 
@@ -159,7 +125,11 @@ public:
 protected:
     virtual ~DataSource() {}
 
-    sp<Sniffer> mSniffer;
+private:
+    static Mutex gSnifferMutex;
+    static List<SnifferFunc> gSniffers;
+    static List<SnifferFunc> gExtraSniffers;
+    static bool gSniffersRegistered;
 
     static void RegisterSniffer_l(SnifferFunc func);
     static void RegisterSnifferPlugin();
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 2df045f..8b49d18 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -129,31 +129,14 @@ status_t DataSource::getSize(off64_t *size) {
 
 ////////////////////////////////////////////////////////////////////////////////
 
+Mutex DataSource::gSnifferMutex;
+List<DataSource::SnifferFunc> DataSource::gSniffers;
+List<DataSource::SnifferFunc> DataSource::gExtraSniffers;
+bool DataSource::gSniffersRegistered = false;
+
 bool DataSource::sniff(
         String8 *mimeType, float *confidence, sp<AMessage> *meta) {
 
-    return  mSniffer->sniff(this, mimeType, confidence, meta);
-}
-
-// static
-void DataSource::RegisterSniffer_l(SnifferFunc /* func */) {
-    return;
-}
-
-// static
-void DataSource::RegisterDefaultSniffers() {
-    return;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-Sniffer::Sniffer() {
-    registerDefaultSniffers();
-}
-
-bool Sniffer::sniff(
-        DataSource *source, String8 *mimeType, float *confidence, sp<AMessage> *meta) {
-
     bool forceExtraSniffers = false;
 
     if (*confidence == 3.14f) {
@@ -165,13 +148,19 @@ bool Sniffer::sniff(
     *confidence = 0.0f;
     meta->clear();
 
-    Mutex::Autolock autoLock(mSnifferMutex);
-    for (List<SnifferFunc>::iterator it = mSniffers.begin();
-         it != mSniffers.end(); ++it) {
+    {
+        Mutex::Autolock autoLock(gSnifferMutex);
+        if (!gSniffersRegistered) {
+            return false;
+        }
+    }
+
+    for (List<SnifferFunc>::iterator it = gSniffers.begin();
+         it != gSniffers.end(); ++it) {
         String8 newMimeType;
         float newConfidence;
         sp<AMessage> newMeta;
-        if ((*it)(source, &newMimeType, &newConfidence, &newMeta)) {
+        if ((*it)(this, &newMimeType, &newConfidence, &newMeta)) {
             if (newConfidence > *confidence) {
                 *mimeType = newMimeType;
                 *confidence = newConfidence;
@@ -182,12 +171,12 @@ bool Sniffer::sniff(
 
     /* Only do the deeper sniffers if the results are null or in doubt */
     if (mimeType->length() == 0 || *confidence < 0.21f || forceExtraSniffers) {
-        for (List<SnifferFunc>::iterator it = mExtraSniffers.begin();
-                it != mExtraSniffers.end(); ++it) {
+        for (List<SnifferFunc>::iterator it = gExtraSniffers.begin();
+                it != gExtraSniffers.end(); ++it) {
             String8 newMimeType;
             float newConfidence;
             sp<AMessage> newMeta;
-            if ((*it)(source, &newMimeType, &newConfidence, &newMeta)) {
+            if ((*it)(this, &newMimeType, &newConfidence, &newMeta)) {
                 if (newConfidence > *confidence) {
                     *mimeType = newMimeType;
                     *confidence = newConfidence;
@@ -200,19 +189,19 @@ bool Sniffer::sniff(
     return *confidence > 0.0;
 }
 
-void Sniffer::registerSniffer_l(SnifferFunc func) {
-
-    for (List<SnifferFunc>::iterator it = mSniffers.begin();
-         it != mSniffers.end(); ++it) {
+// static
+void DataSource::RegisterSniffer_l(SnifferFunc func) {
+    for (List<SnifferFunc>::iterator it = gSniffers.begin();
+         it != gSniffers.end(); ++it) {
         if (*it == func) {
             return;
         }
     }
 
-    mSniffers.push_back(func);
+    gSniffers.push_back(func);
 }
 
-void Sniffer::registerSnifferPlugin() {
+void DataSource::RegisterSnifferPlugin() {
     static void (*getExtractorPlugin)(MediaExtractor::Plugin *) =
             (void (*)(MediaExtractor::Plugin *))loadExtractorPlugin();
 
@@ -221,40 +210,45 @@ void Sniffer::registerSnifferPlugin() {
         getExtractorPlugin(plugin);
     }
     if (plugin->sniff) {
-        for (List<SnifferFunc>::iterator it = mExtraSniffers.begin();
-             it != mExtraSniffers.end(); ++it) {
+        for (List<SnifferFunc>::iterator it = gExtraSniffers.begin();
+             it != gExtraSniffers.end(); ++it) {
             if (*it == plugin->sniff) {
                 return;
             }
         }
 
-        mExtraSniffers.push_back(plugin->sniff);
+        gExtraSniffers.push_back(plugin->sniff);
     }
 }
 
-void Sniffer::registerDefaultSniffers() {
-    Mutex::Autolock autoLock(mSnifferMutex);
-
-    registerSniffer_l(SniffMPEG4);
-    registerSniffer_l(SniffMatroska);
-    registerSniffer_l(SniffOgg);
-    registerSniffer_l(SniffWAV);
-    registerSniffer_l(SniffFLAC);
-    registerSniffer_l(SniffAMR);
-    registerSniffer_l(SniffMPEG2TS);
-    registerSniffer_l(SniffMP3);
-    registerSniffer_l(SniffAAC);
-    registerSniffer_l(SniffMPEG2PS);
-    registerSniffer_l(SniffWVM);
-    registerSniffer_l(SniffMidi);
-    registerSniffer_l(AVUtils::get()->getExtendedSniffer());
-    registerSnifferPlugin();
+// static
+void DataSource::RegisterDefaultSniffers() {
+    Mutex::Autolock autoLock(gSnifferMutex);
+    if (gSniffersRegistered) {
+        return;
+    }
+
+    RegisterSniffer_l(SniffMPEG4);
+    RegisterSniffer_l(SniffMatroska);
+    RegisterSniffer_l(SniffOgg);
+    RegisterSniffer_l(SniffWAV);
+    RegisterSniffer_l(SniffFLAC);
+    RegisterSniffer_l(SniffAMR);
+    RegisterSniffer_l(SniffMPEG2TS);
+    RegisterSniffer_l(SniffMP3);
+    RegisterSniffer_l(SniffAAC);
+    RegisterSniffer_l(SniffMPEG2PS);
+    RegisterSniffer_l(SniffWVM);
+    RegisterSniffer_l(SniffMidi);
+    RegisterSniffer_l(AVUtils::get()->getExtendedSniffer());
+    RegisterSnifferPlugin();
 
     char value[PROPERTY_VALUE_MAX];
     if (property_get("drm.service.enabled", value, NULL)
             && (!strcmp(value, "1") || !strcasecmp(value, "true"))) {
-        registerSniffer_l(SniffDRM);
+        RegisterSniffer_l(SniffDRM);
     }
+    gSniffersRegistered = true;
 }
 
 // static
-- 
2.7.4


From e9b0eeae6500e5651051d809ea7423a2d8697024 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Wed, 18 Nov 2015 16:41:33 -0800
Subject: [PATCH 020/119] stagefright: Fix HEVC in MKV for most clips

 * configurationVersion is not always correct for clips in the wild.

Change-Id: I628a8bcf47f372844f05f912ed66aea6dad0aa86
Signed-off-by: Josue Rivera <prbassplayer@gmail.com>
---
 media/libstagefright/Utils.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 60a5877..610f9ff 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -335,7 +335,7 @@ status_t convertMetaDataToMessage(
     } else if (meta->findData(kKeyHVCC, &type, &data, &size)) {
         const uint8_t *ptr = (const uint8_t *)data;
 
-        if (size < 23 || ptr[0] > 1) {  // configurationVersion == 1
+        if (size < 23) {  // configurationVersion == 1
             ALOGE("b/23680780");
             return BAD_VALUE;
         }
-- 
2.7.4


From 05a061f0a1b0b3903c8155f9d787f56e2344478b Mon Sep 17 00:00:00 2001
From: sotaro <sotaro.ikeda.g@gmail.com>
Date: Mon, 22 Dec 2014 08:56:35 -0800
Subject: [PATCH 021/119] Bug 1113271 - Fix stagefright FLACParser

Change-Id: I993bbcdb276ea727c5088cff03cedb34e9a91c38
---
 media/libstagefright/FLACExtractor.cpp | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/media/libstagefright/FLACExtractor.cpp b/media/libstagefright/FLACExtractor.cpp
index 87345e1..91f0e65 100644
--- a/media/libstagefright/FLACExtractor.cpp
+++ b/media/libstagefright/FLACExtractor.cpp
@@ -150,7 +150,7 @@ private:
     bool mWriteRequested;
     bool mWriteCompleted;
     FLAC__FrameHeader mWriteHeader;
-    const FLAC__int32 * const *mWriteBuffer;
+    const FLAC__int32 * mWriteBuffer[FLAC__MAX_CHANNELS];
 
     // most recent error reported by libFLAC parser
     FLAC__StreamDecoderErrorStatus mErrorStatus;
@@ -334,7 +334,9 @@ FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
         mWriteRequested = false;
         // FLAC parser doesn't free or realloc buffer until next frame or finish
         mWriteHeader = frame->header;
-        mWriteBuffer = buffer;
+        for(unsigned channel = 0; channel < frame->header.channels; channel++) {
+            mWriteBuffer[channel] = buffer[channel];
+        }
         mWriteCompleted = true;
         return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
     } else {
@@ -441,7 +443,6 @@ FLACParser::FLACParser(
       mStreamInfoValid(false),
       mWriteRequested(false),
       mWriteCompleted(false),
-      mWriteBuffer(NULL),
       mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)
 {
     ALOGV("FLACParser::FLACParser");
@@ -618,7 +619,7 @@ MediaBuffer *FLACParser::readBuffer(bool doSeek, FLAC__uint64 sample)
     short *data = (short *) buffer->data();
     buffer->set_range(0, bufferSize);
     // copy PCM from FLAC write buffer to our media buffer, with interleaving
-    copyBuffer(data, mWriteBuffer, blocksize);
+    copyBuffer(data, (const FLAC__int32 * const *)(&mWriteBuffer), blocksize);
     // fill in buffer metadata
     CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
     FLAC__uint64 sampleNumber = mWriteHeader.number.sample_number;
-- 
2.7.4


From 3366d3378cb571d2e219647af52db9476013f744 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Fri, 20 Nov 2015 19:23:42 -0800
Subject: [PATCH 022/119] audioflinger: Fix compilation with debug enabled

Change-Id: I8c459fd5a6530d7fc253f96400208dc6911b68ec
---
 services/audioflinger/FastCapture.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/audioflinger/FastCapture.cpp b/services/audioflinger/FastCapture.cpp
index 1bba5f6..2493fb7 100644
--- a/services/audioflinger/FastCapture.cpp
+++ b/services/audioflinger/FastCapture.cpp
@@ -105,7 +105,7 @@ void FastCapture::onStateChange()
             mFormat = mInputSource->format();
             mSampleRate = Format_sampleRate(mFormat);
             unsigned channelCount = Format_channelCount(mFormat);
-            ALOG_ASSERT(channelCount >= 1 && channelCount <= FCC_8);
+            ALOG_ASSERT(channelCount >= 1 && channelCount <= 8);
         }
         dumpState->mSampleRate = mSampleRate;
         eitherChanged = true;
-- 
2.7.4


From df3d876b4334021fd0a4abb2cbe71102c937f0cb Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Wed, 18 Nov 2015 16:42:19 -0800
Subject: [PATCH 023/119] stagefright: Don't break the ABI in ACodec

 * Qualcomm's proprietary extension is doing some seriously bad stuff.
   This is not going to be fun to maintain.

Change-Id: I7d9d709e7a1dfb3107a4c3ae7b2f15ddaa0fab74
---
 include/media/stagefright/ACodec.h |  7 +++++--
 media/libstagefright/ACodec.cpp    | 13 +++++++++----
 2 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index 8f524ef..5b8e2ac 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -382,8 +382,7 @@ protected:
             bool encoder, int32_t numChannels, int32_t sampleRate, int32_t compressionLevel);
 
     status_t setupRawAudioFormat(
-            OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels,
-            int32_t bitsPerSample = 16);
+            OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels);
 
     status_t setPriority(int32_t priority);
     status_t setOperatingRate(float rateFloat, bool isVideo);
@@ -484,6 +483,10 @@ protected:
     status_t setDolbyParameterOnProcessedAudio(const sp<AMessage> &params);
 #endif // DOLBY_END
 
+    status_t setupRawAudioFormatInternal(
+            OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels,
+            int32_t bitsPerSample);
+
     DISALLOW_EVIL_CONSTRUCTORS(ACodec);
 };
 
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 58d3e73..0ec35d4 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -2091,7 +2091,7 @@ status_t ACodec::configureCodec(
         } else {
             int32_t bitsPerSample = 16;
             msg->findInt32("bit-width", &bitsPerSample);
-            err = setupRawAudioFormat(
+            err = setupRawAudioFormatInternal(
                     encoder ? kPortIndexInput : kPortIndexOutput,
                     sampleRate,
                     numChannels, bitsPerSample);
@@ -2226,7 +2226,7 @@ status_t ACodec::configureCodec(
         } else {
             int32_t bitsPerSample = 16;
             msg->findInt32("bit-width", &bitsPerSample);
-            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels, bitsPerSample);
+            err = setupRawAudioFormatInternal(kPortIndexInput, sampleRate, numChannels, bitsPerSample);
         }
     } else if (!strncmp(mComponentName.c_str(), "OMX.google.", 11)
             && !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) {
@@ -2568,7 +2568,7 @@ status_t ACodec::setupAACCodec(
 
 status_t ACodec::setupAC3Codec(
         bool encoder, int32_t numChannels, int32_t sampleRate, int32_t bitsPerSample) {
-    status_t err = setupRawAudioFormat(
+    status_t err = setupRawAudioFormatInternal(
             encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels, bitsPerSample);
 
     if (err != OK) {
@@ -2606,7 +2606,7 @@ status_t ACodec::setupAC3Codec(
 
 status_t ACodec::setupEAC3Codec(
         bool encoder, int32_t numChannels, int32_t sampleRate, int32_t bitsPerSample) {
-    status_t err = setupRawAudioFormat(
+    status_t err = setupRawAudioFormatInternal(
             encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels, bitsPerSample);
 
     if (err != OK) {
@@ -2753,6 +2753,11 @@ status_t ACodec::setupFlacCodec(
 }
 
 status_t ACodec::setupRawAudioFormat(
+        OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels) {
+    return setupRawAudioFormatInternal(portIndex, sampleRate, numChannels, 16);
+}
+
+status_t ACodec::setupRawAudioFormatInternal(
         OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels, int32_t bitsPerSample) {
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
-- 
2.7.4


From 4526a207237076edd5ef0aef67239674287f5d47 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 19 Nov 2015 00:29:37 -0800
Subject: [PATCH 024/119] stagefright: Welcome to my nightmare, act IV

 * Standardize parameter names, clean up stub calls
 * Attempting to make QC's blob work. We've entered
   our last days on earth. All is lost, all is lost.

Change-Id: Idef9aad100f414e64a737e0f0a8c9c112ad4cb46
---
 .../mediaplayerservice/AVNuUtils.cpp               |  2 +-
 media/libavextensions/stagefright/AVUtils.cpp      |  2 +-
 .../nuplayer/NuPlayerRenderer.cpp                  |  2 +-
 media/libstagefright/ACodec.cpp                    | 25 +++++++++++-----------
 media/libstagefright/FFMPEGSoftCodec.cpp           |  8 +++----
 media/libstagefright/Utils.cpp                     |  4 ++--
 6 files changed, 22 insertions(+), 21 deletions(-)

diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index 77d2b0f..6630614 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -107,7 +107,7 @@ audio_format_t AVNuUtils::getPCMFormat(const sp<AMessage> &format) {
         return (audio_format_t)pcmFormat;
 
     int32_t bits = 16;
-    if (format->findInt32("bit-width", &bits)) {
+    if (format->findInt32("bits-per-sample", &bits)) {
         if (bits == 8)
             return AUDIO_FORMAT_PCM_8_BIT;
         if (bits == 24)
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index 8c69f68..f3f2276 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -68,7 +68,7 @@ int AVUtils::getAudioSampleBits(const sp<MetaData> &) {
 
 int AVUtils::getAudioSampleBits(const sp<AMessage> &format) {
     int32_t bits = 16;
-    format->findInt32("bit-width", &bits);
+    format->findInt32("bits-per-sample", &bits);
     return bits;
 }
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 4b03200..25c2402 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1732,7 +1732,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
     }
 
     int32_t bitWidth = 16;
-    format->findInt32("bit-width", &bitWidth);
+    format->findInt32("bits-per-sample", &bitWidth);
 
     int32_t sampleRate;
     CHECK(format->findInt32("sample-rate", &sampleRate));
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 0ec35d4..ee6df20 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -588,12 +588,7 @@ ACodec::ACodec()
 ACodec::~ACodec() {
 }
 
-status_t ACodec::setupCustomCodec(status_t err, const char *mime, const sp<AMessage> &msg) {
-     if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11) && !mIsEncoder) {
-         return FFMPEGSoftCodec::setAudioFormat(
-               msg, mime, mOMX, mNode);
-     }
-
+status_t ACodec::setupCustomCodec(status_t err, const char * /*mime*/, const sp<AMessage> &/*msg*/) {
     return err;
 }
 
@@ -2090,7 +2085,7 @@ status_t ACodec::configureCodec(
             err = OK;
         } else {
             int32_t bitsPerSample = 16;
-            msg->findInt32("bit-width", &bitsPerSample);
+            msg->findInt32("bits-per-sample", &bitsPerSample);
             err = setupRawAudioFormatInternal(
                     encoder ? kPortIndexInput : kPortIndexOutput,
                     sampleRate,
@@ -2225,7 +2220,7 @@ status_t ACodec::configureCodec(
             err = INVALID_OPERATION;
         } else {
             int32_t bitsPerSample = 16;
-            msg->findInt32("bit-width", &bitsPerSample);
+            msg->findInt32("bits-per-sample", &bitsPerSample);
             err = setupRawAudioFormatInternal(kPortIndexInput, sampleRate, numChannels, bitsPerSample);
         }
     } else if (!strncmp(mComponentName.c_str(), "OMX.google.", 11)
@@ -2237,7 +2232,7 @@ status_t ACodec::configureCodec(
             err = INVALID_OPERATION;
         } else {
             int32_t bitsPerSample = 16;
-            msg->findInt32("bit-width", &bitsPerSample);
+            msg->findInt32("bits-per-sample", &bitsPerSample);
             err = setupAC3Codec(encoder, numChannels, sampleRate, bitsPerSample);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_EAC3)) {
@@ -2248,11 +2243,16 @@ status_t ACodec::configureCodec(
             err = INVALID_OPERATION;
         } else {
             int32_t bitsPerSample = 16;
-            msg->findInt32("bit-width", &bitsPerSample);
+            msg->findInt32("bits-per-sample", &bitsPerSample);
             err = setupEAC3Codec(encoder, numChannels, sampleRate, bitsPerSample);
         }
     } else {
-        err = setupCustomCodec(err, mime, msg);
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11) && !mIsEncoder) {
+            err = FFMPEGSoftCodec::setAudioFormat(
+                  msg, mime, mOMX, mNode);
+        } else {
+            err = setupCustomCodec(err, mime, msg);
+        }
     }
 
     if (err != OK) {
@@ -4364,7 +4364,7 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setString("mime", MEDIA_MIMETYPE_AUDIO_RAW);
                     notify->setInt32("channel-count", params.nChannels);
                     notify->setInt32("sample-rate", params.nSamplingRate);
-                    notify->setInt32("bit-width", params.nBitPerSample);
+                    notify->setInt32("bits-per-sample", params.nBitPerSample);
 
                     if (mChannelMaskPresent) {
                         notify->setInt32("channel-mask", mChannelMask);
@@ -5898,6 +5898,7 @@ bool ACodec::LoadedState::onConfigureComponent(
 
     status_t err = OK;
     AString mime;
+
     if (!msg->findString("mime", &mime)) {
         err = BAD_VALUE;
     } else {
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 5c6a8ed..6b12a41 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -53,7 +53,7 @@ static const MetaKeyEntry MetaKeyTable[] {
    {kKeyAACAOT               , "aac-profile"            , INT32},
    {kKeyArbitraryMode        , "use-arbitrary-mode"     , INT32},
    {kKeyBitRate              , "bitrate"                , INT32},
-   {kKeyBitsPerSample        , "bit-width"              , INT32},
+   {kKeyBitsPerSample        , "bits-per-sample"        , INT32},
    {kKeyBlockAlign           , "block-align"            , INT32},
    {kKeyChannelCount         , "channel-count"          , INT32},
    {kKeyCodecId              , "codec-id"               , INT32},
@@ -404,7 +404,7 @@ status_t FFMPEGSoftCodec::getAudioPortFormat(OMX_U32 portIndex, int coding,
             notify->setString("mime", MEDIA_MIMETYPE_AUDIO_APE);
             notify->setInt32("channel-count", params.nChannels);
             notify->setInt32("sample-rate", params.nSamplingRate);
-            notify->setInt32("bit-width", params.nBitsPerSample);
+            notify->setInt32("bits-per-sample", params.nBitsPerSample);
             break;
         }
         case OMX_AUDIO_CodingFLAC:
@@ -422,7 +422,7 @@ status_t FFMPEGSoftCodec::getAudioPortFormat(OMX_U32 portIndex, int coding,
             notify->setString("mime", MEDIA_MIMETYPE_AUDIO_FLAC);
             notify->setInt32("channel-count", params.nChannels);
             notify->setInt32("sample-rate", params.nSampleRate);
-            notify->setInt32("bit-width", params.nCompressionLevel); // piggyback
+            notify->setInt32("bits-per-sample", params.nCompressionLevel); // piggyback
             break;
         }
 
@@ -821,7 +821,7 @@ status_t FFMPEGSoftCodec::setWMAFormat(
 
     // mm-parser may want a different bit depth
     if (msg->findInt32(getMsgKey(kKeyWMABitspersample), &bitsPerSample)) {
-        msg->setInt32("bit-width", bitsPerSample);
+        msg->setInt32("bits-per-sample", bitsPerSample);
     }
 
     ALOGV("Channels: %d, SampleRate: %d, BitRate: %d, blockAlign: %d",
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 610f9ff..4c72ad0 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -227,7 +227,7 @@ status_t convertMetaDataToMessage(
 
     int32_t bitsPerSample;
     if (meta->findInt32(kKeyBitsPerSample, &bitsPerSample)) {
-        msg->setInt32("bit-width", bitsPerSample);
+        msg->setInt32("bits-per-sample", bitsPerSample);
     }
 
     uint32_t type;
@@ -685,7 +685,7 @@ void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {
         }
 
         int32_t bitsPerSample;
-        if (msg->findInt32("bit-width", &bitsPerSample)) {
+        if (msg->findInt32("bits-per-sample", &bitsPerSample)) {
             meta->setInt32(kKeyBitsPerSample, bitsPerSample);
         }
     }
-- 
2.7.4


From a9e4083c7cb8f257c6d9ff74ef75e4c55bb96f06 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 19 Nov 2015 00:33:58 -0800
Subject: [PATCH 025/119] stagefright: Act V: I am become death, the destroyer
 of worlds

 * In which our hero unites the legions of distant worlds together
   as one at last to fight anew until the segfaults boil the lands
   and the New Version cometh.

Change-Id: I869b2ab254968ed7a133827ea9e5ba6056f68a5c
---
 include/media/IMediaRecorder.h                            |  3 ++-
 include/media/MediaRecorderBase.h                         |  7 +++++--
 include/media/mediarecorder.h                             |  4 +++-
 include/media/stagefright/AudioSource.h                   |  6 ++++--
 include/media/stagefright/FileSource.h                    |  8 ++++----
 include/media/stagefright/Utils.h                         |  2 ++
 media/libavextensions/Android.mk                          |  4 ++++
 media/libavextensions/mediaplayerservice/AVNuExtensions.h |  7 ++++++-
 media/libavextensions/mediaplayerservice/AVNuUtils.cpp    | 15 +--------------
 media/libmediaplayerservice/Android.mk                    |  4 ++++
 media/libmediaplayerservice/MediaRecorderClient.h         |  6 ++++--
 media/libmediaplayerservice/StagefrightRecorder.h         |  4 +++-
 media/libmediaplayerservice/nuplayer/Android.mk           |  1 -
 media/libmediaplayerservice/nuplayer/GenericSource.cpp    |  9 ++++++++-
 media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp  |  2 ++
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp |  4 ++--
 media/libstagefright/ACodec.cpp                           |  2 ++
 media/libstagefright/Utils.cpp                            | 13 +++++++++++++
 18 files changed, 69 insertions(+), 32 deletions(-)

diff --git a/include/media/IMediaRecorder.h b/include/media/IMediaRecorder.h
index 339bd9e..7e6befd 100644
--- a/include/media/IMediaRecorder.h
+++ b/include/media/IMediaRecorder.h
@@ -51,7 +51,6 @@ public:
     virtual status_t prepare() = 0;
     virtual status_t getMaxAmplitude(int* max) = 0;
     virtual status_t start() = 0;
-    virtual status_t pause() = 0;
     virtual status_t stop() = 0;
     virtual status_t reset() = 0;
     virtual status_t init() = 0;
@@ -59,6 +58,8 @@ public:
     virtual status_t release() = 0;
     virtual status_t setInputSurface(const sp<IGraphicBufferConsumer>& surface) = 0;
     virtual sp<IGraphicBufferProducer> querySurfaceMediaSource() = 0;
+
+    virtual status_t pause() = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/media/MediaRecorderBase.h b/include/media/MediaRecorderBase.h
index 48d8b70..4290563 100644
--- a/include/media/MediaRecorderBase.h
+++ b/include/media/MediaRecorderBase.h
@@ -53,7 +53,6 @@ struct MediaRecorderBase {
     virtual status_t prepare() = 0;
     virtual status_t start() = 0;
     virtual status_t stop() = 0;
-    virtual status_t pause() = 0;
     virtual status_t close() = 0;
     virtual status_t reset() = 0;
     virtual status_t getMaxAmplitude(int *max) = 0;
@@ -61,13 +60,17 @@ struct MediaRecorderBase {
     virtual status_t setInputSurface(const sp<IGraphicBufferConsumer>& surface) = 0;
     virtual sp<IGraphicBufferProducer> querySurfaceMediaSource() const = 0;
 
-
 protected:
     String16 mOpPackageName;
 
 private:
     MediaRecorderBase(const MediaRecorderBase &);
     MediaRecorderBase &operator=(const MediaRecorderBase &);
+
+public:
+    virtual status_t pause() = 0;
+
+
 };
 
 }  // namespace android
diff --git a/include/media/mediarecorder.h b/include/media/mediarecorder.h
index 6bc0032..653e53a 100644
--- a/include/media/mediarecorder.h
+++ b/include/media/mediarecorder.h
@@ -246,7 +246,6 @@ public:
     status_t    getMaxAmplitude(int* max);
     virtual status_t    start();
     virtual status_t    stop();
-    virtual status_t    pause();
     status_t    reset();
     status_t    init();
     status_t    close();
@@ -275,6 +274,9 @@ protected:
     bool                        mIsOutputFileSet;
     Mutex                       mLock;
     Mutex                       mNotifyLock;
+
+public:
+    virtual status_t    pause();
 };
 
 };  // namespace android
diff --git a/include/media/stagefright/AudioSource.h b/include/media/stagefright/AudioSource.h
index e48765e..699b1b4 100644
--- a/include/media/stagefright/AudioSource.h
+++ b/include/media/stagefright/AudioSource.h
@@ -46,8 +46,6 @@ struct AudioSource : public MediaSource, public MediaBufferObserver {
     virtual status_t stop() { return reset(); }
     virtual sp<MetaData> getFormat();
 
-    virtual status_t pause();
-
     // Returns the maximum amplitude since last call.
     int16_t getMaxAmplitude();
 
@@ -113,6 +111,10 @@ protected:
 
     AudioSource(const AudioSource &);
     AudioSource &operator=(const AudioSource &);
+
+public:
+    virtual status_t pause();
+
 };
 
 }  // namespace android
diff --git a/include/media/stagefright/FileSource.h b/include/media/stagefright/FileSource.h
index 21844ca..7051b20 100644
--- a/include/media/stagefright/FileSource.h
+++ b/include/media/stagefright/FileSource.h
@@ -39,14 +39,14 @@ public:
 
     virtual status_t getSize(off64_t *size);
 
-    virtual String8 getUri() {
-        return mUri;
-    }
-
     virtual sp<DecryptHandle> DrmInitialization(const char *mime);
 
     virtual void getDrmInfo(sp<DecryptHandle> &handle, DrmManagerClient **client);
 
+    virtual String8 getUri() {
+        return mUri;
+    }
+
 protected:
     virtual ~FileSource();
 
diff --git a/include/media/stagefright/Utils.h b/include/media/stagefright/Utils.h
index 5e9d7d4..1e9de1a 100644
--- a/include/media/stagefright/Utils.h
+++ b/include/media/stagefright/Utils.h
@@ -85,6 +85,8 @@ void writeToAMessage(sp<AMessage> msg, const AVSyncSettings &sync, float videoFp
 void readFromAMessage(
         const sp<AMessage> &msg, AVSyncSettings *sync /* nonnull */, float *videoFps /* nonnull */);
 
+audio_format_t getPCMFormat(const sp<AMessage> &format);
+
 }  // namespace android
 
 #endif  // UTILS_H_
diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
index 776edcb..6b2a2eb 100644
--- a/media/libavextensions/Android.mk
+++ b/media/libavextensions/Android.mk
@@ -84,6 +84,10 @@ ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
        LOCAL_CFLAGS += -DENABLE_AV_ENHANCEMENTS
 endif
 
+ifeq ($(TARGET_BOARD_PLATFORM),msm8974)
+       LOCAL_CFLAGS += -DTARGET_8974
+endif
+
 LOCAL_MODULE:= libavmediaserviceextensions
 LOCAL_CLANG := false
 
diff --git a/media/libavextensions/mediaplayerservice/AVNuExtensions.h b/media/libavextensions/mediaplayerservice/AVNuExtensions.h
index 3fc77de..383bdb8 100644
--- a/media/libavextensions/mediaplayerservice/AVNuExtensions.h
+++ b/media/libavextensions/mediaplayerservice/AVNuExtensions.h
@@ -80,13 +80,18 @@ struct AVNuUtils {
     virtual void setDecodedPCMFormat(const sp<AMessage> &);
     virtual status_t convertToSinkFormatIfNeeded(const sp<ABuffer> &, sp<ABuffer> &,
             audio_format_t sinkFormat, bool isOffload);
+#ifndef TARGET_8974
     virtual uint32_t getFlags();
     virtual bool canUseSetBuffers(const sp<MetaData> &Meta);
-
+#endif
     virtual void printFileName(int fd);
     virtual void checkFormatChange(bool *formatChange, const sp<ABuffer> &accessUnit);
     virtual void overWriteAudioOutputFormat(sp <AMessage> &dst, const sp <AMessage> &src);
+#ifdef TARGET_8974
     virtual void addFlagsInMeta(const sp<ABuffer> &buffer, int32_t flags, bool isAudio);
+    virtual uint32_t getFlags();
+    virtual bool canUseSetBuffers(const sp<MetaData> &Meta);
+#endif
     virtual bool dropCorruptFrame();
 
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index 6630614..f78ca22 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -101,20 +101,7 @@ void AVNuUtils::setKeyPCMFormat(const sp<MetaData> &meta, audio_format_t audioFo
         meta->setInt32('pfmt', audioFormat);
 }
 
-audio_format_t AVNuUtils::getPCMFormat(const sp<AMessage> &format) {
-    int32_t pcmFormat = 0;
-    if (format->findInt32("pcm-format", &pcmFormat))
-        return (audio_format_t)pcmFormat;
-
-    int32_t bits = 16;
-    if (format->findInt32("bits-per-sample", &bits)) {
-        if (bits == 8)
-            return AUDIO_FORMAT_PCM_8_BIT;
-        if (bits == 24)
-            return AUDIO_FORMAT_PCM_32_BIT;
-        if (bits == 32)
-            return AUDIO_FORMAT_PCM_FLOAT;
-    }
+audio_format_t AVNuUtils::getPCMFormat(const sp<AMessage> &/*format*/) {
     return AUDIO_FORMAT_PCM_16_BIT;
 }
 
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index dca6bb3..7afc52a 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -65,6 +65,10 @@ LOCAL_MODULE:= libmediaplayerservice
 
 #LOCAL_32_BIT_ONLY := true
 
+ifeq ($(TARGET_BOARD_PLATFORM),msm8974)
+    LOCAL_CFLAGS += -DTARGET_8974
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/media/libmediaplayerservice/MediaRecorderClient.h b/media/libmediaplayerservice/MediaRecorderClient.h
index 2e77d21..cfe332c 100644
--- a/media/libmediaplayerservice/MediaRecorderClient.h
+++ b/media/libmediaplayerservice/MediaRecorderClient.h
@@ -49,7 +49,6 @@ public:
     virtual     status_t   prepare();
     virtual     status_t   getMaxAmplitude(int* max);
     virtual     status_t   start();
-    virtual     status_t   pause();
     virtual     status_t   stop();
     virtual     status_t   reset();
     virtual     status_t   init();
@@ -72,8 +71,11 @@ private:
     Mutex                  mLock;
     MediaRecorderBase      *mRecorder;
     sp<MediaPlayerService> mMediaPlayerService;
-};
 
+public:
+    virtual     status_t   pause();
+
+};
 }; // namespace android
 
 #endif // ANDROID_MEDIARECORDERCLIENT_H
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index 26c5582..6c14993 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -60,7 +60,6 @@ struct StagefrightRecorder : public MediaRecorderBase {
     virtual status_t setParameters(const String8& params);
     virtual status_t setListener(const sp<IMediaRecorderClient>& listener);
     virtual status_t setClientName(const String16& clientName);
-    virtual status_t setSourcePause(bool pause);
     virtual status_t prepare();
     virtual status_t start();
     virtual status_t pause();
@@ -199,6 +198,9 @@ protected:
 
     StagefrightRecorder(const StagefrightRecorder &);
     StagefrightRecorder &operator=(const StagefrightRecorder &);
+
+public:
+    virtual status_t setSourcePause(bool pause);
 };
 
 }  // namespace android
diff --git a/media/libmediaplayerservice/nuplayer/Android.mk b/media/libmediaplayerservice/nuplayer/Android.mk
index 7a60d2c..f4c000d 100644
--- a/media/libmediaplayerservice/nuplayer/Android.mk
+++ b/media/libmediaplayerservice/nuplayer/Android.mk
@@ -34,7 +34,6 @@ ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
 LOCAL_CFLAGS += -DENABLE_STAGEFRIGHT_EXPERIMENTS
 endif
 
-
 ifeq ($(TARGET_BOARD_PLATFORM),msm8974)
 LOCAL_CFLAGS += -DTARGET_8974
 endif
diff --git a/media/libmediaplayerservice/nuplayer/GenericSource.cpp b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
index e041ca8..75bde4f 100644
--- a/media/libmediaplayerservice/nuplayer/GenericSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
@@ -173,9 +173,14 @@ status_t NuPlayer::GenericSource::initFromDataSource() {
         }
         extractor = mWVMExtractor;
     } else {
+#ifndef TARGET_8974
+        int32_t flags = AVNuUtils::get()->getFlags();
+#else
+        int32_t flags = 0;
+#endif
         extractor = MediaExtractor::Create(mDataSource,
                 mimeType.isEmpty() ? NULL : mimeType.string(),
-                mIsStreaming ? 0 : AVNuUtils::get()->getFlags());
+                mIsStreaming ? 0 : flags);
     }
 
     if (extractor == NULL) {
@@ -205,10 +210,12 @@ status_t NuPlayer::GenericSource::initFromDataSource() {
         }
     }
 
+#ifndef TARGET_8974
     if (AVNuUtils::get()->canUseSetBuffers(mFileMeta)) {
         mUseSetBuffers = true;
         ALOGI("setBuffers mode enabled");
     }
+#endif
 
     int32_t totalBitrate = 0;
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index da308f6..68d23dd 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -620,7 +620,9 @@ bool NuPlayer::Decoder::handleAnOutputBuffer(
     buffer->meta()->clear();
     buffer->meta()->setInt64("timeUs", timeUs);
     setPcmFormat(buffer->meta());
+#ifdef TARGET_8974
     AVNuUtils::get()->addFlagsInMeta(buffer, flags, mIsAudio);
+#endif
 
     bool eos = flags & MediaCodec::BUFFER_FLAG_EOS;
     // we do not expect CODECCONFIG or SYNCFRAME for decoder
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 25c2402..7bf1771 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1852,7 +1852,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
         const PcmInfo info = {
                 (audio_channel_mask_t)channelMask,
                 (audio_output_flags_t)pcmFlags,
-                AVNuUtils::get()->getPCMFormat(format),
+                getPCMFormat(format),
                 numChannels,
                 sampleRate
         };
@@ -1887,7 +1887,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
                     sampleRate,
                     numChannels,
                     (audio_channel_mask_t)channelMask,
-                    AVNuUtils::get()->getPCMFormat(format),
+                    getPCMFormat(format),
                     0 /* bufferCount - unused */,
                     mUseAudioCallback ? &NuPlayer::Renderer::AudioSinkCallback : NULL,
                     mUseAudioCallback ? this : NULL,
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index ee6df20..b6f5e8d 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -82,6 +82,7 @@
 #include <media/stagefright/PersistentSurface.h>
 #include <media/stagefright/SurfaceUtils.h>
 #include <media/stagefright/FFMPEGSoftCodec.h>
+#include <media/stagefright/Utils.h>
 
 #include <media/hardware/HardwareAPI.h>
 
@@ -4365,6 +4366,7 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("channel-count", params.nChannels);
                     notify->setInt32("sample-rate", params.nSamplingRate);
                     notify->setInt32("bits-per-sample", params.nBitPerSample);
+                    notify->setInt32("pcm-format", getPCMFormat(notify));
 
                     if (mChannelMaskPresent) {
                         notify->setInt32("channel-mask", mChannelMask);
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 4c72ad0..6a4b0d3 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -1077,5 +1077,18 @@ void readFromAMessage(
     *sync = settings;
 }
 
+audio_format_t getPCMFormat(const sp<AMessage> &format) {
+    int32_t bits = 16;
+    if (format->findInt32("bits-per-sample", &bits)) {
+        if (bits == 8)
+            return AUDIO_FORMAT_PCM_8_BIT;
+        if (bits == 24)
+            return AUDIO_FORMAT_PCM_32_BIT;
+        if (bits == 32)
+            return AUDIO_FORMAT_PCM_FLOAT;
+    }
+    return AUDIO_FORMAT_PCM_16_BIT;
+}
+
 }  // namespace android
 
-- 
2.7.4


From 264462b08ef5c113b2f85d941145e175a4199731 Mon Sep 17 00:00:00 2001
From: Manikanta Kanamarlapudi <kmanikan@codeaurora.org>
Date: Fri, 6 Nov 2015 19:16:31 +0530
Subject: [PATCH 026/119] Revert "GenericSource: Synchronize access to
 dataSource"

This reverts commit a5c3b990807732d1c4a7c1290cba06a605675973.

Change-Id: I1f267cf7ab90b1f5c38e0659df02c8ef518382ed
Signed-off-by: Josue Rivera <prbassplayer@gmail.com>
---
 media/libmediaplayerservice/nuplayer/GenericSource.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/GenericSource.cpp b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
index 75bde4f..b78bd6d 100644
--- a/media/libmediaplayerservice/nuplayer/GenericSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
@@ -564,11 +564,11 @@ void NuPlayer::GenericSource::disconnect() {
 
     if (dataSource != NULL) {
         // disconnect data source
-        if (dataSource->flags() & DataSource::kIsCachingDataSource) {
-            static_cast<NuCachedSource2 *>(dataSource.get())->disconnect();
+        if (mDataSource->flags() & DataSource::kIsCachingDataSource) {
+            static_cast<NuCachedSource2 *>(mDataSource.get())->disconnect();
         }
-    } else if (httpSource != NULL) {
-        static_cast<HTTPBase *>(httpSource.get())->disconnect();
+    } else if (mHttpSource != NULL) {
+        static_cast<HTTPBase *>(mHttpSource.get())->disconnect();
     }
 }
 
-- 
2.7.4


From 51d8e113f7e7691185a8dfc6f912a5a43a10f46c Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 23 Nov 2015 17:19:36 -0800
Subject: [PATCH 027/119] media: Require property to be set to use QC AV
 enhancements

 * Because of the wild divergence between branches and the fragility
   of this interface, we will disable it by default even if the
   library is in place. After thorough testing for a device it
   can then be enabled. At this point, these enhancements bring
   little value except on the very latest hardware.

Change-Id: I99147a466bfbb020d05ffbb6c2773414f2439755
---
 media/libavextensions/common/ExtensionsLoader.hpp | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/media/libavextensions/common/ExtensionsLoader.hpp b/media/libavextensions/common/ExtensionsLoader.hpp
index e03979c..48bcf3b 100644
--- a/media/libavextensions/common/ExtensionsLoader.hpp
+++ b/media/libavextensions/common/ExtensionsLoader.hpp
@@ -28,6 +28,7 @@
  */
 #include <dlfcn.h>
 #include <common/AVExtensionsCommon.h>
+#include <cutils/properties.h>
 
 namespace android {
 
@@ -52,9 +53,12 @@ T *ExtensionsLoader<T>::createInstance(const char *createFunctionName) {
         // create extended object if extensions-lib is available and
         // AV_ENHANCEMENTS is enabled
 #if ENABLE_AV_ENHANCEMENTS
-        createFunction_t createFunc = loadCreateFunction(createFunctionName);
-        if (createFunc) {
-            return reinterpret_cast<T *>((*createFunc)());
+        bool enabled = property_get_bool("media.avenhancements.enabled", false);
+        if (enabled) {
+            createFunction_t createFunc = loadCreateFunction(createFunctionName);
+            if (createFunc) {
+                return reinterpret_cast<T *>((*createFunc)());
+            }
         }
 #endif
         // Else, create the default object
-- 
2.7.4


From bcee8d3f68cfb19158a7a467aa79299619a5c4e8 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 24 Nov 2015 04:29:42 -0800
Subject: [PATCH 028/119] stagefright: Fix voodoo ifdefs

Change-Id: I192702dbbeb4966ee7e6b5ea90fa7dcc26254909
---
 media/libavextensions/mediaplayerservice/AVNuUtils.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index f78ca22..3e70c0a 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -132,9 +132,12 @@ void AVNuUtils::checkFormatChange(bool * /*formatChange*/,
 void AVNuUtils::overWriteAudioOutputFormat(
         sp <AMessage> & /*dst*/, const sp <AMessage> & /*src*/) {
 }
+
+#ifdef TARGET_8974
 void AVNuUtils::addFlagsInMeta(const sp<ABuffer> & /*buffer*/,
         int32_t /*flags*/, bool /*isAudio*/) {
 }
+#endif
 
 uint32_t AVNuUtils::getFlags() {
     return 0;
-- 
2.7.4


From 098e743fa4d889ea360a9774cb6c52953a4c1f9f Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Wed, 25 Nov 2015 16:54:19 -0800
Subject: [PATCH 029/119] stagefright: Support hardware codecs with FFMPEG
 extractor

 * Quite often we'll be using our custom extractor to handle
   container formats which aren't supported by any other means,
   but the codecs used inside the container are hardware supported.
 * For QC specifically we need to send a few magical incantations,
   so add support for this. Software codecs will be used if
   hardware support is unavailable.

Change-Id: I917b674142fdab0b009e066e9511648c2695ec4b
---
 include/media/stagefright/FFMPEGSoftCodec.h |  3 +-
 media/libstagefright/ACodec.cpp             | 20 +++----
 media/libstagefright/Android.mk             |  1 +
 media/libstagefright/FFMPEGSoftCodec.cpp    | 93 ++++++++++++++++++++++++++---
 4 files changed, 96 insertions(+), 21 deletions(-)

diff --git a/include/media/stagefright/FFMPEGSoftCodec.h b/include/media/stagefright/FFMPEGSoftCodec.h
index 83373d0..2f31e72 100644
--- a/include/media/stagefright/FFMPEGSoftCodec.h
+++ b/include/media/stagefright/FFMPEGSoftCodec.h
@@ -62,7 +62,8 @@ struct FFMPEGSoftCodec {
     static status_t setVideoFormat(
             const sp<AMessage> &msg, const char* mime,
             sp<IOMX> OMXhandle,IOMX::node_id nodeID,
-            bool isEncoder, OMX_VIDEO_CODINGTYPE *compressionFormat);
+            bool isEncoder, OMX_VIDEO_CODINGTYPE *compressionFormat,
+            const char* componentName);
 
     static status_t getAudioPortFormat(
             OMX_U32 portIndex, int coding,
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index b6f5e8d..79f1d46 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -1674,11 +1674,7 @@ status_t ACodec::setComponentRole(
     }
 
     if (i == kNumMimeToRole) {
-        status_t err = ERROR_UNSUPPORTED;
-        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
-        }
-        return err;
+        return FFMPEGSoftCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
     }
 
     const char *role =
@@ -3021,10 +3017,9 @@ status_t ACodec::setupVideoDecoder(
     status_t err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
-        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setVideoFormat(
-                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
-        }
+        err = FFMPEGSoftCodec::setVideoFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat,
+                    mComponentName.c_str());
         if (err != OK) {
             return err;
         }
@@ -3177,10 +3172,9 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
     err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
-        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setVideoFormat(
-                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
-        }
+        err = FFMPEGSoftCodec::setVideoFormat(
+                msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat,
+                mComponentName.c_str());
         if (err != OK) {
             ALOGE("Not a supported video mime type: %s", mime);
             return err;
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 866add5..497997f 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -194,6 +194,7 @@ endif
 # FFMPEG plugin
 LOCAL_C_INCLUDES += $(TOP)/external/stagefright-plugins/include
 
+#LOCAL_CFLAGS += -DLOG_NDEBUG=0
 LOCAL_MODULE:= libstagefright
 
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 6b12a41..6a842e7 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -37,6 +37,10 @@
 
 #include <OMX_FFMPEG_Extn.h>
 
+#ifdef QCOM_HARDWARE
+#include <OMX_QCOMExtns.h>
+#endif
+
 namespace android {
 
 enum MetaKeyType{
@@ -217,7 +221,8 @@ void FFMPEGSoftCodec::overrideComponentName(
 status_t FFMPEGSoftCodec::setVideoFormat(
         const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
         IOMX::node_id nodeID, bool isEncoder,
-        OMX_VIDEO_CODINGTYPE *compressionFormat) {
+        OMX_VIDEO_CODINGTYPE *compressionFormat,
+        const char* componentName) {
     status_t err = OK;
 
     if (isEncoder) {
@@ -225,12 +230,13 @@ status_t FFMPEGSoftCodec::setVideoFormat(
         err = BAD_VALUE;
     
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)) {
-        err = setWMVFormat(msg, OMXhandle, nodeID);
-        if (err != OK) {
-            ALOGE("setWMVFormat() failed (err = %d)", err);
-        } else {
-            *compressionFormat = OMX_VIDEO_CodingWMV;
+        if (strncmp(componentName, "OMX.ffmpeg.", 11) == 0) {
+            err = setWMVFormat(msg, OMXhandle, nodeID);
+            if (err != OK) {
+                ALOGE("setWMVFormat() failed (err = %d)", err);
+            }
         }
+        *compressionFormat = OMX_VIDEO_CodingWMV;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_RV, mime)) {
         err = setRVFormat(msg, OMXhandle, nodeID);
         if (err != OK) {
@@ -258,6 +264,79 @@ status_t FFMPEGSoftCodec::setVideoFormat(
         err = BAD_TYPE;
     }
 
+#ifdef QCOM_HARDWARE
+    // We need to do a few extra steps if FFMPEGExtractor is in control
+    // and we want to talk to the hardware codecs. This logic is taken
+    // from the CAF L release. It was unfortunately moved to a proprietary
+    // blob and an architecture which is hellish for OEMs who wish to
+    // customize the platform.
+    if (err != BAD_TYPE && (strncmp(componentName, "OMX.qcom.", 9) == 0)) {
+        status_t xerr = OK;
+
+        int32_t mode = 0;
+        OMX_QCOM_PARAM_PORTDEFINITIONTYPE portFmt;
+        portFmt.nPortIndex = kPortIndexInput;
+
+        if (msg->findInt32("use-arbitrary-mode", &mode) && mode) {
+            ALOGI("Decoder will be in arbitrary mode");
+            portFmt.nFramePackingFormat = OMX_QCOM_FramePacking_Arbitrary;
+        } else {
+            ALOGI("Decoder will be in frame by frame mode");
+            portFmt.nFramePackingFormat = OMX_QCOM_FramePacking_OnlyOneCompleteFrame;
+        }
+        xerr = OMXhandle->setParameter(
+                nodeID, (OMX_INDEXTYPE)OMX_QcomIndexPortDefn,
+                (void *)&portFmt, sizeof(portFmt));
+        if (xerr != OK) {
+            ALOGW("Failed to set frame packing format on component");
+        }
+
+        // Enable timestamp reordering for mpeg4 and vc1 codec types, the AVI file
+        // type, and hevc content in the ts container
+        bool tsReorder = false;
+        const char* roleVC1 = "OMX.qcom.video.decoder.vc1";
+        const char* roleMPEG4 = "OMX.qcom.video.decoder.mpeg4";
+        if (!strncmp(componentName, roleVC1, strlen(roleVC1)) ||
+                !strncmp(componentName, roleMPEG4, strlen(roleMPEG4))) {
+            // The codec requires timestamp reordering
+            tsReorder = true;
+        }
+
+        if (tsReorder) {
+            ALOGI("Enabling timestamp reordering");
+            QOMX_INDEXTIMESTAMPREORDER reorder;
+            InitOMXParams(&reorder);
+            reorder.nPortIndex = kPortIndexOutput;
+            reorder.bEnable = OMX_TRUE;
+            xerr = OMXhandle->setParameter(nodeID,
+                           (OMX_INDEXTYPE)OMX_QcomIndexParamEnableTimeStampReorder,
+                           (void *)&reorder, sizeof(reorder));
+
+            if (xerr != OK) {
+                ALOGW("Failed to enable timestamp reordering");
+            }
+        }
+
+        // MediaCodec clients can request decoder extradata by setting
+        // "enable-extradata-<type>" in MediaFormat.
+        // Following <type>s are supported:
+        //    "user" => user-extradata
+        int extraDataRequested = 0;
+        if (msg->findInt32("enable-extradata-user", &extraDataRequested) &&
+                extraDataRequested == 1) {
+            ALOGI("[%s] User-extradata requested", componentName);
+            QOMX_ENABLETYPE enableType;
+            enableType.bEnable = OMX_TRUE;
+
+            xerr = OMXhandle->setParameter(
+                    nodeID, (OMX_INDEXTYPE)OMX_QcomIndexEnableExtnUserData,
+                    (OMX_PTR)&enableType, sizeof(enableType));
+            if (xerr != OK) {
+                ALOGW("[%s] Failed to enable user-extradata", componentName);
+            }
+        }
+    }
+#endif
     return err;
 }
 
@@ -582,7 +661,7 @@ status_t FFMPEGSoftCodec::setSupportedRole(
         { MEDIA_MIMETYPE_VIDEO_DIVX311,
           "video_decoder.divx", NULL },
         { MEDIA_MIMETYPE_VIDEO_WMV,
-          "video_decoder.wmv",  NULL },
+          "video_decoder.vc1",  NULL }, // so we can still talk to hardware codec
         { MEDIA_MIMETYPE_VIDEO_VC1,
           "video_decoder.vc1", NULL },
         { MEDIA_MIMETYPE_VIDEO_RV,
-- 
2.7.4


From f7accc5c0e7097da532c8e880d64597f17bd7d74 Mon Sep 17 00:00:00 2001
From: Manikanta Kanamarlapudi <kmanikan@codeaurora.org>
Date: Thu, 28 Nov 2013 11:55:29 +0530
Subject: [PATCH 030/119] libstagefright: Added mime-types for enca/encv atoms

- enca/encv are encrypted audio and video atoms for
  mp4a and mp4v. Hence returning aac and mpeg4 mime-types
  for enca and encv.

CRs-Fixed: 578506

Change-Id: Ie568ea7eec73e110eef07e2b1b921afefc8c54a7
---
 media/libstagefright/MPEG4Extractor.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 34e60db..24daebc 100755
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -363,6 +363,9 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('m', 'p', '4', 'a'):
             return MEDIA_MIMETYPE_AUDIO_AAC;
 
+        case FOURCC('e', 'n', 'c', 'a'):
+            return MEDIA_MIMETYPE_AUDIO_AAC;
+
         case FOURCC('.', 'm', 'p', '3'):
             return MEDIA_MIMETYPE_AUDIO_MPEG;
 
@@ -389,6 +392,9 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('m', 'p', '4', 'v'):
             return MEDIA_MIMETYPE_VIDEO_MPEG4;
 
+        case FOURCC('e', 'n', 'c', 'v'):
+            return MEDIA_MIMETYPE_VIDEO_MPEG4;
+
         case FOURCC('s', '2', '6', '3'):
         case FOURCC('h', '2', '6', '3'):
         case FOURCC('H', '2', '6', '3'):
-- 
2.7.4


From e34246cf543d12621eb5f4221035fb8c989431da Mon Sep 17 00:00:00 2001
From: Sultanxda <sultanxda@gmail.com>
Date: Fri, 20 Nov 2015 13:10:13 -0800
Subject: [PATCH 031/119] Revert "adjust audio timestamp to account for
 AudioRecord latency"

Throws audio and video out of sync for video recordings.

This reverts commit fa4303dcbeac79452f35c078c8008f5c2e7622b7.

Change-Id: I6207cbb8d2dffec9743b734b8180406506c0d041
---
 media/libstagefright/AudioSource.cpp | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/media/libstagefright/AudioSource.cpp b/media/libstagefright/AudioSource.cpp
index 9cc2cde..77a7d1c 100644
--- a/media/libstagefright/AudioSource.cpp
+++ b/media/libstagefright/AudioSource.cpp
@@ -308,10 +308,6 @@ void AudioSource::signalBufferReturned(MediaBuffer *buffer) {
 
 status_t AudioSource::dataCallback(const AudioRecord::Buffer& audioBuffer) {
     int64_t timeUs = systemTime() / 1000ll;
-    // Estimate the real sampling time of the 1st sample in this buffer
-    // from AudioRecord's latency. (Apply this adjustment first so that
-    // the start time logic is not affected.)
-    timeUs -= mRecord->latency() * 1000LL;
 
     ALOGV("dataCallbackTimestamp: %" PRId64 " us", timeUs);
     Mutex::Autolock autoLock(mLock);
-- 
2.7.4


From d2625589d206d3382f2f34122f80f3de44f2fcdf Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 26 Nov 2015 05:31:01 -0800
Subject: [PATCH 032/119] audioflinger: Adjust throttle interval when effects
 in use

 * Loud clicks/pops are heard when playing to a USB device with
   AudioFX enabled. Particularly frequent when the USB device is
   capable of high-resolution output.
 * Adjust the throttling period when effects are enabled to
   prevent this.

Change-Id: I3db220d13c37f4ff5b835c14831fbe6f5a5b062c
---
 services/audioflinger/Threads.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index e5123f4..e24a070 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -3061,8 +3061,9 @@ bool AudioFlinger::PlaybackThread::threadLoop()
                         //     the app won't fill fast enough to handle the sudden draw).
 
                         const int32_t deltaMs = delta / 1000000;
-                        const int32_t throttleMs = mHalfBufferMs - deltaMs;
-                        if ((signed)mHalfBufferMs >= throttleMs && throttleMs > 0) {
+                        const int32_t halfBufferMs = mHalfBufferMs / (mEffectBufferValid ? 4 : 1);
+                        const int32_t throttleMs = halfBufferMs - deltaMs;
+                        if ((signed)halfBufferMs >= throttleMs && throttleMs > 0) {
                             usleep(throttleMs * 1000);
                             // notify of throttle start on verbose log
                             ALOGV_IF(mThreadThrottleEndMs == mThreadThrottleTimeMs,
-- 
2.7.4


From 633692ff26dde5ba22afe7173c1b1d8160cc9608 Mon Sep 17 00:00:00 2001
From: Wei Jia <wjia@google.com>
Date: Thu, 19 Nov 2015 10:57:15 -0800
Subject: [PATCH 033/119] NuPlayerRenderer: always display the first video
 frame without delay.

Bug: 25357751
Change-Id: Iffd9af2ddf7626155d98caf086fe209600141585
---
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 7bf1771..c1e5dee 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1076,6 +1076,9 @@ void NuPlayer::Renderer::postDrainVideoQueue() {
                 mMediaClock->updateAnchor(mediaTimeUs, nowUs, mediaTimeUs);
                 mAnchorTimeMediaUs = mediaTimeUs;
                 realTimeUs = nowUs;
+            } else if (!mVideoSampleReceived) {
+                // Always render the first video frame.
+                realTimeUs = nowUs;
             } else {
                 realTimeUs = getRealTimeUs(mediaTimeUs, nowUs);
             }
@@ -1141,7 +1144,7 @@ void NuPlayer::Renderer::onDrainVideoQueue() {
         return;
     }
 
-    int64_t nowUs = -1;
+    int64_t nowUs = ALooper::GetNowUs();
     int64_t realTimeUs;
     if (mFlags & FLAG_REAL_TIME) {
         CHECK(entry->mBuffer->meta()->findInt64("timeUs", &realTimeUs));
@@ -1149,16 +1152,12 @@ void NuPlayer::Renderer::onDrainVideoQueue() {
         int64_t mediaTimeUs;
         CHECK(entry->mBuffer->meta()->findInt64("timeUs", &mediaTimeUs));
 
-        nowUs = ALooper::GetNowUs();
         realTimeUs = getRealTimeUs(mediaTimeUs, nowUs);
     }
 
     bool tooLate = false;
 
     if (!mPaused) {
-        if (nowUs == -1) {
-            nowUs = ALooper::GetNowUs();
-        }
         setVideoLateByUs(nowUs - realTimeUs);
         tooLate = (mVideoLateByUs > 40000);
 
@@ -1182,6 +1181,12 @@ void NuPlayer::Renderer::onDrainVideoQueue() {
         }
     }
 
+    // Always render the first video frame while keeping stats on A/V sync.
+    if (!mVideoSampleReceived) {
+        realTimeUs = nowUs;
+        tooLate = false;
+    }
+
     entry->mNotifyConsumed->setInt64("timestampNs", realTimeUs * 1000ll);
     entry->mNotifyConsumed->setInt32("render", !tooLate);
     entry->mNotifyConsumed->post();
-- 
2.7.4


From 7515416a95944156c0d9b7b7eda20aa7c59b67dc Mon Sep 17 00:00:00 2001
From: Leena Winterrowd <lenhardw@codeaurora.org>
Date: Wed, 10 Sep 2014 19:22:54 -0700
Subject: [PATCH 034/119] libstagefright: Handle MPEG4 DP playback

Since the HW decoder doesn't support MPEG4 DP clips, detect DP
format clips in the parser and report a new MIME:
video/mpeg4-esdp. This MIME is only registered to the SW
decoder which supports DP clips.

Merges the following change from kitkat:
libstagefright: Fix DP Parsing issue with mpeg4 SP,ASP
(Change-Id: I69c719011e1a0d2a0b0ae5a9b504b7cce443866b)

CRs-Fixed: 722066
Change-Id: I7bc3a7a9f4a6d37e046ed9c8008cb27fb3bc665d
---
 include/media/stagefright/Utils.h                  |   4 +
 media/libstagefright/ACodec.cpp                    |   2 +
 media/libstagefright/MPEG4Extractor.cpp            |   3 +
 media/libstagefright/OMXCodec.cpp                  |   8 +-
 media/libstagefright/Utils.cpp                     | 223 +++++++++++++++++++++
 .../libstagefright/matroska/MatroskaExtractor.cpp  |   2 +
 media/libstagefright/rtsp/APacketSource.cpp        |   3 +
 7 files changed, 243 insertions(+), 2 deletions(-)

diff --git a/include/media/stagefright/Utils.h b/include/media/stagefright/Utils.h
index 1e9de1a..847ea36 100644
--- a/include/media/stagefright/Utils.h
+++ b/include/media/stagefright/Utils.h
@@ -87,6 +87,10 @@ void readFromAMessage(
 
 audio_format_t getPCMFormat(const sp<AMessage> &format);
 
+void updateVideoTrackInfoFromESDS_MPEG4Video(sp<MetaData> meta);
+bool checkDPFromVOLHeader(const uint8_t *ptr, size_t size);
+bool checkDPFromCodecSpecificData(const uint8_t *ptr, size_t size);
+
 }  // namespace android
 
 #endif  // UTILS_H_
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 79f1d46..a116240 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -1653,6 +1653,8 @@ status_t ACodec::setComponentRole(
             "audio_decoder.ac3", "audio_encoder.ac3" },
         { MEDIA_MIMETYPE_AUDIO_EAC3,
             "audio_decoder.eac3", "audio_encoder.eac3" },
+        { MEDIA_MIMETYPE_VIDEO_MPEG4_DP,
+            "video_decoder.mpeg4", NULL },
 #ifdef DOLBY_UDC
         { MEDIA_MIMETYPE_AUDIO_EAC3_JOC,
             "audio_decoder.eac3_joc", NULL },
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 24daebc..c0d83ac 100755
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -1917,6 +1917,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                     }
                 }
             }
+
+            updateVideoTrackInfoFromESDS_MPEG4Video(mLastTrack->meta);
+
             break;
         }
 
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index ba6bc67..97bc5b8 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -926,7 +926,8 @@ void OMXCodec::setVideoInputFormat(
         compressionFormat = OMX_VIDEO_CodingAVC;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
         compressionFormat = OMX_VIDEO_CodingHEVC;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime) ||
+            !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4_DP, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
         compressionFormat = OMX_VIDEO_CodingH263;
@@ -1318,7 +1319,8 @@ status_t OMXCodec::setVideoOutputFormat(
     OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
         compressionFormat = OMX_VIDEO_CodingAVC;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime) ||
+            !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4_DP, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
         compressionFormat = OMX_VIDEO_CodingHEVC;
@@ -1520,6 +1522,8 @@ void OMXCodec::setComponentRole(
             "video_decoder.hevc", "video_encoder.hevc" },
         { MEDIA_MIMETYPE_VIDEO_MPEG4,
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
+        { MEDIA_MIMETYPE_VIDEO_MPEG4_DP,
+            "video_decoder.mpeg4", NULL },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
         { MEDIA_MIMETYPE_VIDEO_VP8,
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 6a4b0d3..602c4f0 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -56,6 +56,7 @@
 
 #include <stagefright/AVExtensions.h>
 #include <media/stagefright/FFMPEGSoftCodec.h>
+#include <media/stagefright/foundation/ABitReader.h>
 
 namespace android {
 
@@ -1090,5 +1091,227 @@ audio_format_t getPCMFormat(const sp<AMessage> &format) {
     return AUDIO_FORMAT_PCM_16_BIT;
 }
 
+void updateVideoTrackInfoFromESDS_MPEG4Video(sp<MetaData> meta) {
+    const char* mime = NULL;
+    if (meta != NULL && meta->findCString(kKeyMIMEType, &mime) &&
+            mime && !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4)) {
+        uint32_t type;
+        const void *data;
+        size_t size;
+        if (!meta->findData(kKeyESDS, &type, &data, &size) || !data) {
+            ALOGW("ESDS atom is invalid");
+            return;
+        }
+
+        if (checkDPFromCodecSpecificData((const uint8_t*) data, size)) {
+            meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_MPEG4_DP);
+        }
+    }
+}
+
+bool checkDPFromCodecSpecificData(const uint8_t *data, size_t size) {
+    bool retVal = false;
+    size_t offset = 0, startCodeOffset = 0;
+    bool isStartCode = false;
+    const int kVolStartCode = 0x20;
+    const char kStartCode[] = "\x00\x00\x01";
+    // must contain at least 4 bytes for video_object_layer_start_code
+    const size_t kMinCsdSize = 4;
+
+    if (!data || (size < kMinCsdSize)) {
+        ALOGV("Invalid CSD (expected at least %zu bytes)", kMinCsdSize);
+        return retVal;
+    }
+
+    while (offset < size - 3) {
+        if ((data[offset + 3] & 0xf0) == kVolStartCode) {
+            if (!memcmp(&data[offset], kStartCode, 3)) {
+                startCodeOffset = offset;
+                isStartCode = true;
+                break;
+            }
+        }
+
+        offset++;
+    }
+
+    if (isStartCode) {
+        retVal = checkDPFromVOLHeader((const uint8_t*) &data[startCodeOffset],
+                (size - startCodeOffset));
+    }
+
+    return retVal;
+}
+
+bool checkDPFromVOLHeader(const uint8_t *data, size_t size) {
+    bool retVal = false; 
+    // must contain at least 4 bytes for video_object_layer_start_code + 9 bits of data
+    const size_t kMinHeaderSize = 6;
+
+    if (!data || (size < kMinHeaderSize)) {
+        ALOGV("Invalid VOL header (expected at least %zu bytes)", kMinHeaderSize);
+        return false;
+    }
+
+    ALOGV("Checking for MPEG4 DP bit");
+    ABitReader br(&data[4], (size - 4));
+    br.skipBits(1); // random_accessible_vol
+
+    unsigned videoObjectTypeIndication = br.getBits(8);
+    if (videoObjectTypeIndication == 0x12u) {
+        ALOGW("checkDPFromVOLHeader: videoObjectTypeIndication:%u",
+               videoObjectTypeIndication);
+        return false;
+    }
+
+    unsigned videoObjectLayerVerid = 1;
+    if (br.getBits(1)) {
+        videoObjectLayerVerid = br.getBits(4);
+        br.skipBits(3); // video_object_layer_priority
+        ALOGV("checkDPFromVOLHeader: videoObjectLayerVerid:%u",
+               videoObjectLayerVerid);
+    }
+
+    if (br.getBits(4) == 0x0f) { // aspect_ratio_info
+        ALOGV("checkDPFromVOLHeader: extended PAR");
+        br.skipBits(8); // par_width
+        br.skipBits(8); // par_height
+    }
+
+    if (br.getBits(1)) { // vol_control_parameters
+        br.skipBits(2);  // chroma_format
+        br.skipBits(1);  // low_delay
+        if (br.getBits(1)) { // vbv_parameters
+            br.skipBits(15); // first_half_bit_rate
+            br.skipBits(1);  // marker_bit
+            br.skipBits(15); // latter_half_bit_rate
+            br.skipBits(1);  // marker_bit
+            br.skipBits(15); // first_half_vbv_buffer_size
+            br.skipBits(1);  // marker_bit
+            br.skipBits(3);  // latter_half_vbv_buffer_size
+            br.skipBits(11); // first_half_vbv_occupancy
+            br.skipBits(1);  // marker_bit
+            br.skipBits(15); // latter_half_vbv_occupancy
+            br.skipBits(1);  // marker_bit
+        }
+    }
+
+    unsigned videoObjectLayerShape = br.getBits(2);
+    if (videoObjectLayerShape != 0x00u /* rectangular */) {
+        ALOGV("checkDPFromVOLHeader: videoObjectLayerShape:%x",
+               videoObjectLayerShape);
+        return false;
+    }
+
+    br.skipBits(1); // marker_bit
+    unsigned vopTimeIncrementResolution = br.getBits(16);
+    br.skipBits(1); // marker_bit
+    if (br.getBits(1)) {  // fixed_vop_rate
+        // range [0..vopTimeIncrementResolution)
+
+        // vopTimeIncrementResolution
+        // 2 => 0..1, 1 bit
+        // 3 => 0..2, 2 bits
+        // 4 => 0..3, 2 bits
+        // 5 => 0..4, 3 bits
+        // ...
+
+        if (vopTimeIncrementResolution <= 0u) {
+            return BAD_VALUE;
+        }
+
+        --vopTimeIncrementResolution;
+        unsigned numBits = 0;
+        while (vopTimeIncrementResolution > 0) {
+            ++numBits;
+            vopTimeIncrementResolution >>= 1;
+        }
+
+        br.skipBits(numBits);  // fixed_vop_time_increment
+    }
+
+    br.skipBits(1);  // marker_bit
+    br.skipBits(13); // video_object_layer_width
+    br.skipBits(1);  // marker_bit
+    br.skipBits(13); // video_object_layer_height
+    br.skipBits(1);  // marker_bit
+    br.skipBits(1);  // interlaced
+    br.skipBits(1);  // obmc_disable
+    unsigned spriteEnable = 0;
+    if (videoObjectLayerVerid == 1) {
+        spriteEnable = br.getBits(1);
+    } else {
+        spriteEnable = br.getBits(2);
+    }
+
+    if (spriteEnable == 0x1) { // static
+        int spriteWidth = br.getBits(13);
+        ALOGV("checkDPFromVOLHeader: spriteWidth:%d", spriteWidth);
+        br.skipBits(1) ; // marker_bit
+        br.skipBits(13); // sprite_height
+        br.skipBits(1);  // marker_bit
+        br.skipBits(13); // sprite_left_coordinate
+        br.skipBits(1);  // marker_bit
+        br.skipBits(13); // sprite_top_coordinate
+        br.skipBits(1);  // marker_bit
+        br.skipBits(6);  // no_of_sprite_warping_points
+        br.skipBits(2);  // sprite_warping_accuracy
+        br.skipBits(1);  // sprite_brightness_change
+        br.skipBits(1);  // low_latency_sprite_enable
+    } else if (spriteEnable == 0x2) { // GMC
+        br.skipBits(6); // no_of_sprite_warping_points
+        br.skipBits(2); // sprite_warping_accuracy
+        br.skipBits(1); // sprite_brightness_change
+    }
+
+    if (videoObjectLayerVerid != 1
+            && videoObjectLayerShape != 0x0u) {
+        br.skipBits(1);
+    }
+
+    if (br.getBits(1)) { // not_8_bit
+        br.skipBits(4);  // quant_precision
+        br.skipBits(4);  // bits_per_pixel
+    }
+
+    if (videoObjectLayerShape == 0x3) {
+        br.skipBits(1);
+        br.skipBits(1);
+        br.skipBits(1);
+    }
+
+    if (br.getBits(1)) { // quant_type
+        if (br.getBits(1)) { // load_intra_quant_mat
+            unsigned IntraQuantMat = 1;
+            for (int i = 0; i < 64 && IntraQuantMat; i++) {
+                 IntraQuantMat = br.getBits(8);
+            }
+        }
+
+        if (br.getBits(1)) { // load_non_intra_quant_matrix
+            unsigned NonIntraQuantMat = 1;
+            for (int i = 0; i < 64 && NonIntraQuantMat; i++) {
+                 NonIntraQuantMat = br.getBits(8);
+            }
+        }
+    } /* quantType */
+
+    if (videoObjectLayerVerid != 1) {
+        unsigned quarterSample = br.getBits(1);
+        ALOGV("checkDPFromVOLHeader: quarterSample:%u",
+                quarterSample);
+    }
+
+    br.skipBits(1); // complexity_estimation_disable
+    br.skipBits(1); // resync_marker_disable
+    unsigned dataPartitioned = br.getBits(1);
+    if (dataPartitioned) {
+        retVal = true;
+    }
+
+    ALOGD("checkDPFromVOLHeader: DP:%u", dataPartitioned);
+    return retVal;
+}
+
 }  // namespace android
 
diff --git a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
index 9377b17..c584669 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -915,6 +915,8 @@ static void addESDSFromCodecPrivate(
 
     meta->setData(kKeyESDS, 0, esds, esdsSize);
 
+    updateVideoTrackInfoFromESDS_MPEG4Video(meta);
+
     delete[] esds;
     esds = NULL;
 }
diff --git a/media/libstagefright/rtsp/APacketSource.cpp b/media/libstagefright/rtsp/APacketSource.cpp
index cfafaa7..e81325d 100644
--- a/media/libstagefright/rtsp/APacketSource.cpp
+++ b/media/libstagefright/rtsp/APacketSource.cpp
@@ -37,6 +37,7 @@
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
 #include <utils/Vector.h>
 
 namespace android {
@@ -535,6 +536,8 @@ APacketSource::APacketSource(
             return;
         }
 
+        updateVideoTrackInfoFromESDS_MPEG4Video(mFormat);
+
         mFormat->setInt32(kKeyWidth, width);
         mFormat->setInt32(kKeyHeight, height);
     } else if (!strncasecmp(desc.c_str(), "mpeg4-generic/", 14)) {
-- 
2.7.4


From f4fdd95361245698d0833ff66bfcf6f43c086898 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Fri, 27 Nov 2015 19:01:45 -0800
Subject: [PATCH 035/119] stagefright: Fix tags in mpeg4 not parsed correctly.

This fixes a bug introduced by commit
440b54cbef4a20caeb18bf6927bc728645f649e2 which skipped
the atoms inside in mpeg4 container without correctly
parsing all of it.

Change-Id: I6152b0a8e0248a39f9c686e748b3ae22457579da
---
 media/libstagefright/MPEG4Extractor.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index c0d83ac..caab461 100755
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -928,7 +928,7 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             && chunk_type != FOURCC('c', 'o', 'v', 'r')
             && mPath.size() == 5 && underMetaDataPath(mPath)) {
         off64_t stop_offset = *offset + chunk_size;
-        *offset = stop_offset;
+        *offset = data_offset;
         while (*offset < stop_offset) {
             status_t err = parseChunk(offset, depth + 1);
             if (err != OK) {
-- 
2.7.4


From 49e4354b60c60b9b58808de784ed5d3feae9b3ce Mon Sep 17 00:00:00 2001
From: Sidipotu Ashok <sashok@codeaurora.org>
Date: Tue, 27 Oct 2015 23:06:22 +0530
Subject: [PATCH 036/119] MediaCodec: reset size to zero for EOS.

testflush CTS test doesnt have logic to detect EOS
currently, reset the size to zero in Mediacodec, on
behalf of the CTS test.

CRs-Fixed: 911338
Change-Id: I31727a00e0edf5604d0409fecbd976334508e6d7
---
 media/libstagefright/MediaCodec.cpp | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/media/libstagefright/MediaCodec.cpp b/media/libstagefright/MediaCodec.cpp
index 759bc24..5e0ee55 100644
--- a/media/libstagefright/MediaCodec.cpp
+++ b/media/libstagefright/MediaCodec.cpp
@@ -2413,7 +2413,12 @@ status_t MediaCodec::onQueueInputBuffer(const sp<AMessage> &msg) {
     }
 
     if (offset + size > info->mData->capacity()) {
-        return -EINVAL;
+        if ( ((int)size == (int)-1) && !(flags & BUFFER_FLAG_EOS)) {
+            size = 0;
+            ALOGD("EOS, reset size to zero");
+        }
+        else
+            return -EINVAL;
     }
 
     sp<AMessage> reply = info->mNotify;
-- 
2.7.4


From e2b4f3cf5da272d870610d6bd67917055c2e3fc8 Mon Sep 17 00:00:00 2001
From: Lucas Gomez Jimenez <lucas.gomezjimenez@tomtom.com>
Date: Thu, 30 Jul 2015 09:53:47 +0200
Subject: [PATCH 037/119] Audio Effects are not processing first buffer

Current implementation in AudioFlinger set the effects to state IDLE
when they are created. Later on when the effect is enabled by the
client, the state changes to STARTING.

Then when the audio playback starts, the AudioFlinger thread loop
calls EffectChain::process_l() to perform the effects processing.
However this method will first call process() and then updateState(),
so the firstprocess won't do anything because the effect is in
STARTING state. After the call to updateState, the state is moved
to ACTIVE and then next calls to process_l() will work as expected.

Change-Id: I9dfd3d5a0e53403034eb42f9366e1b3cdc5249c0
---
 services/audioflinger/Effects.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/services/audioflinger/Effects.cpp b/services/audioflinger/Effects.cpp
index ccf155c..a1fb040 100644
--- a/services/audioflinger/Effects.cpp
+++ b/services/audioflinger/Effects.cpp
@@ -1494,14 +1494,14 @@ void AudioFlinger::EffectChain::process_l()
     }
 
     size_t size = mEffects.size();
+    for (size_t i = 0; i < size; i++) {
+        mEffects[i]->updateState();
+    }
     if (doProcess) {
         for (size_t i = 0; i < size; i++) {
             mEffects[i]->process();
         }
     }
-    for (size_t i = 0; i < size; i++) {
-        mEffects[i]->updateState();
-    }
 }
 
 // addEffect_l() must be called with PlaybackThread::mLock held
-- 
2.7.4


From 39815a81029f697ed79ed562779c0d987936805f Mon Sep 17 00:00:00 2001
From: Haynes Mathew George <hgeorge@codeaurora.org>
Date: Wed, 4 Nov 2015 17:14:42 -0800
Subject: [PATCH 038/119] stagefright: omx: delay observer death handling

Delay observer death handling to give the component
a chance to observe pending freeNode (in other words,
allow component to observe mDying = true).

Change-Id: I5f70e9b04a1d2decc7abd0d2a9588f2298519cbb
---
 media/libstagefright/include/OMXNodeInstance.h | 2 +-
 media/libstagefright/omx/OMXNodeInstance.cpp   | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/media/libstagefright/include/OMXNodeInstance.h b/media/libstagefright/include/OMXNodeInstance.h
index c60d2dd..4f1fa84 100644
--- a/media/libstagefright/include/OMXNodeInstance.h
+++ b/media/libstagefright/include/OMXNodeInstance.h
@@ -145,8 +145,8 @@ private:
     OMX::node_id mNodeID;
     OMX_HANDLETYPE mHandle;
     sp<IOMXObserver> mObserver;
-    atomic_bool mDying;
     bool mIsSecure;
+    atomic_bool mDying;
 
     // Lock only covers mGraphicBufferSource.  We can't always use mLock
     // because of rare instances where we'd end up locking it recursively.
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 26fab96..36349af 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -215,6 +215,7 @@ OMXNodeInstance::OMXNodeInstance(
     mMetadataType[1] = kMetadataBufferTypeInvalid;
     atomic_store(&mDying, false);
     mIsSecure = AString(name).endsWith(".secure");
+    atomic_store(&mDying, false);
 }
 
 OMXNodeInstance::~OMXNodeInstance() {
-- 
2.7.4


From a62a616621f4a254af3eebe20df38551358c841d Mon Sep 17 00:00:00 2001
From: Praveen Chavan <pchavan@codeaurora.org>
Date: Mon, 19 Oct 2015 14:44:52 -0700
Subject: [PATCH 039/119] GenericSource: Synchronize access to dataSource

DataSource and HTTPSource can be accessed/modified by
GenericSource's looper and Client's thread which can
lead to race conditions when copying the sp<>.
Add a Mutex lock to synchronize such accesses and avoid
race conditions.

CRs-Fixed: 906899
Change-Id: I2fb4b4a7079e638e151f4fe67a780007a4011652
---
 media/libmediaplayerservice/nuplayer/GenericSource.cpp | 11 +++++++----
 media/libmediaplayerservice/nuplayer/GenericSource.h   |  1 +
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/GenericSource.cpp b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
index b78bd6d..7615fb5 100644
--- a/media/libmediaplayerservice/nuplayer/GenericSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
@@ -128,6 +128,7 @@ status_t NuPlayer::GenericSource::setDataSource(
 
 status_t NuPlayer::GenericSource::setDataSource(const sp<DataSource>& source) {
     resetDataSource();
+    Mutex::Autolock _l(mSourceLock);
     mDataSource = source;
     return OK;
 }
@@ -393,6 +394,7 @@ void NuPlayer::GenericSource::onPrepareAsync() {
                 }
             }
 
+            Mutex::Autolock _l(mSourceLock);
             mDataSource = DataSource::CreateFromURI(
                    mHTTPService, uri, &mUriHeaders, &contentType,
                    static_cast<HTTPBase *>(mHttpSource.get()),
@@ -400,6 +402,7 @@ void NuPlayer::GenericSource::onPrepareAsync() {
         } else {
             mIsWidevine = false;
 
+            Mutex::Autolock _l(mSourceLock);
             mDataSource = new FileSource(mFd, mOffset, mLength);
             mFd = -1;
         }
@@ -564,11 +567,11 @@ void NuPlayer::GenericSource::disconnect() {
 
     if (dataSource != NULL) {
         // disconnect data source
-        if (mDataSource->flags() & DataSource::kIsCachingDataSource) {
-            static_cast<NuCachedSource2 *>(mDataSource.get())->disconnect();
+        if (dataSource->flags() & DataSource::kIsCachingDataSource) {
+            static_cast<NuCachedSource2 *>(dataSource.get())->disconnect();
         }
-    } else if (mHttpSource != NULL) {
-        static_cast<HTTPBase *>(mHttpSource.get())->disconnect();
+    } else if (httpSource != NULL) {
+        static_cast<HTTPBase *>(httpSource.get())->disconnect();
     }
 }
 
diff --git a/media/libmediaplayerservice/nuplayer/GenericSource.h b/media/libmediaplayerservice/nuplayer/GenericSource.h
index bdcf706..9f8556e 100644
--- a/media/libmediaplayerservice/nuplayer/GenericSource.h
+++ b/media/libmediaplayerservice/nuplayer/GenericSource.h
@@ -137,6 +137,7 @@ protected:
     int64_t mOffset;
     int64_t mLength;
 
+    Mutex mSourceLock;
     sp<DataSource> mDataSource;
     sp<NuCachedSource2> mCachedSource;
     sp<DataSource> mHttpSource;
-- 
2.7.4


From d906221be61647775bd51aeeca0b9d081446b506 Mon Sep 17 00:00:00 2001
From: Shivaprasad Hongal <shongal@codeaurora.org>
Date: Fri, 23 Oct 2015 11:43:19 -0700
Subject: [PATCH 040/119] GenericSource: Hold an additional reference to
 dataSource.

mDataSource can be deleted by client thread while GenericSource
looper is accessing dataSource in sniff functions, which can
lead to race condition. Add local sp<> to hold an additional
reference to dataSource.

Change-Id: I9e51f75f3c2bd703e381230dd93cb4d3f6621dab
CRs-Fixed: 923729
---
 media/libmediaplayerservice/nuplayer/GenericSource.cpp | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/media/libmediaplayerservice/nuplayer/GenericSource.cpp b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
index 7615fb5..3f42178 100644
--- a/media/libmediaplayerservice/nuplayer/GenericSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
@@ -156,7 +156,12 @@ status_t NuPlayer::GenericSource::initFromDataSource() {
             return UNKNOWN_ERROR;
         }
     } else if (mIsStreaming) {
-        if (!mDataSource->sniff(&mimeType, &confidence, &dummy)) {
+        sp<DataSource> dataSource;
+        {
+            Mutex::Autolock _l(mSourceLock);
+            dataSource = mDataSource;
+        }
+        if (!dataSource->sniff(&mimeType, &confidence, &dummy)) {
             return UNKNOWN_ERROR;
         }
         isWidevineStreaming = !strcasecmp(
-- 
2.7.4


From c0eb9566fdf483552832e5e7c24781a0afd5f736 Mon Sep 17 00:00:00 2001
From: Shivaprasad Hongal <shongal@codeaurora.org>
Date: Mon, 9 Nov 2015 11:17:02 -0800
Subject: [PATCH 041/119] GenericSource: acquire lock only for assigning
 dataSource.

Acquire lock after DataSource::CreateFromURI() to avoid a deadlock/ANR
as GenericSource::disconnect() also tries to acquire same lock.

Change-Id: I28430800853ed11e0a37a8a38defab72470c3f6d
---
 media/libmediaplayerservice/nuplayer/GenericSource.cpp | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/GenericSource.cpp b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
index 3f42178..f40ad7e 100644
--- a/media/libmediaplayerservice/nuplayer/GenericSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
@@ -399,16 +399,20 @@ void NuPlayer::GenericSource::onPrepareAsync() {
                 }
             }
 
-            Mutex::Autolock _l(mSourceLock);
-            mDataSource = DataSource::CreateFromURI(
+            sp<DataSource> dataSource;
+            dataSource = DataSource::CreateFromURI(
                    mHTTPService, uri, &mUriHeaders, &contentType,
                    static_cast<HTTPBase *>(mHttpSource.get()),
                    true /*use extended cache*/);
+            Mutex::Autolock _l(mSourceLock);
+            mDataSource = dataSource;
         } else {
             mIsWidevine = false;
 
+            sp<DataSource> dataSource;
+            dataSource = new FileSource(mFd, mOffset, mLength);
             Mutex::Autolock _l(mSourceLock);
-            mDataSource = new FileSource(mFd, mOffset, mLength);
+            mDataSource = dataSource;
             mFd = -1;
         }
 
-- 
2.7.4


From 6f2688341faae2eb9f7f49a0d45c5f3c19eea4a6 Mon Sep 17 00:00:00 2001
From: Diogo Ferreira <defer@cyngn.com>
Date: Tue, 1 Dec 2015 15:33:17 +0000
Subject: [PATCH 042/119] ffmpeg: flac: Assume 16 bits per sample if not set

Fixes
android.media.cts.MediaCodecCapabilitiesTest#testGetMaxSupportedInstances

Change-Id: I52222fd739c413ddd9c925796dc7adabef1b375a
---
 media/libstagefright/FFMPEGSoftCodec.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 6a842e7..fe86a03 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -1020,7 +1020,7 @@ status_t FFMPEGSoftCodec::setFLACFormat(
 
     CHECK(msg->findInt32(getMsgKey(kKeyChannelCount), &numChannels));
     CHECK(msg->findInt32(getMsgKey(kKeySampleRate), &sampleRate));
-    CHECK(msg->findInt32(getMsgKey(kKeyBitsPerSample), &bitsPerSample));
+    msg->findInt32(getMsgKey(kKeyBitsPerSample), &bitsPerSample);
 
     ALOGV("Channels: %d, SampleRate: %d BitsPerSample: %d",
             numChannels, sampleRate, bitsPerSample);
-- 
2.7.4


From 0631a50c62e67917cd3782a55900a025af2f72f4 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Tue, 1 Dec 2015 11:17:09 -0800
Subject: [PATCH 043/119] stagefright: Fix cts testGetMaxSupportedInstances

Fix cts testGetMaxSupportedInstances on 64 bits system.

In FFMPEGSoftCodec.cpp, it tries to get OMX parameter
in function setRawAudioFormat by calling:
    OMX_PARAM_PORTDEFINITIONTYPE def;
    ...
    status_t err = OMXhandle->getParameter(
            nodeID, OMX_IndexParamPortDefinition, &def, sizeof(def));
However, this code runs in 64 bits, and mediaserver is running in 32 bits.
sizeof(OMX_PARAM_PORTDEFINITIONTYPE) is equals to 112 vs 96 in 32 bits mode,
since sizeof(OMX_PTR) are different.

In SimpleSoftOMXComponent::internalGetParameter which runs in 32 bits mode,
it checks defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)
and fails.

Declaring OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS in
FFMPEGSoftCodec.cpp solves it.

Change-Id: Ieb5a548c580e87c964c66f0b0d6ce8bb14dac690
---
 media/libstagefright/FFMPEGSoftCodec.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index fe86a03..2af53b3 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -14,6 +14,10 @@
  * limitations under the License.
  */
 
+#ifdef __LP64__
+#define OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS
+#endif
+
 //#define LOG_NDEBUG 0
 #define LOG_TAG "FFMPEGSoftCodec"
 #include <utils/Log.h>
@@ -330,7 +334,7 @@ status_t FFMPEGSoftCodec::setVideoFormat(
 
             xerr = OMXhandle->setParameter(
                     nodeID, (OMX_INDEXTYPE)OMX_QcomIndexEnableExtnUserData,
-                    (OMX_PTR)&enableType, sizeof(enableType));
+                    &enableType, sizeof(enableType));
             if (xerr != OK) {
                 ALOGW("[%s] Failed to enable user-extradata", componentName);
             }
-- 
2.7.4


From 7e1f5e97d69a3321d4d34efb02f0b3a8c013b0ce Mon Sep 17 00:00:00 2001
From: Diogo Ferreira <defer@cyngn.com>
Date: Tue, 1 Dec 2015 15:52:30 +0000
Subject: [PATCH 044/119] stagefright: handleSetSurface: Don't dereference null
 graphic buffers

In metadata mode and when buffers are owned by the native window
, it is possible that the graphics buffer is null.

This is fine since we don't have to attach it to a surface. However,
the logging was trying to dereference this graphic buffer which caused
media to crash sporadically.

This fixes the flakiness in
android.media.cts.MediaPlayerTest#testVideoSurfaceResetting

Change-Id: I89f30ca1177d7118da5a7b0ffbbb91370f9b54ab
---
 media/libstagefright/ACodec.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index a116240..966fd2d 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -770,7 +770,7 @@ status_t ACodec::handleSetSurface(const sp<Surface> &surface) {
         if (storingMetadataInDecodedBuffers()
                 && !mLegacyAdaptiveExperiment
                 && info.mStatus == BufferInfo::OWNED_BY_NATIVE_WINDOW) {
-            ALOGV("skipping buffer %p", info.mGraphicBuffer->getNativeBuffer());
+            ALOGV("skipping buffer %p", info.mGraphicBuffer.get() ? info.mGraphicBuffer->getNativeBuffer() : 0x0);
             continue;
         }
         ALOGV("attaching buffer %p", info.mGraphicBuffer->getNativeBuffer());
-- 
2.7.4


From 3d74528323d0424207c62d81d494b33e6fe601b9 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Tue, 1 Dec 2015 14:25:45 -0800
Subject: [PATCH 045/119] stagefright: Fix fallback mechanism to SW decoder

Fallback mediaserver to SW decoder breaks
with commit eeb8a90192cee627890a74f75a0c64145fbc34f4

Since the err parameters is overrided in a local loop.
And even an alternative decoder is configureCodec
sucessfully, the outer loop err parameters is still != OK
and return false.

Change-Id: Id5a9e570e5f55f28a80d7cd25a2a14d59442f3e2
---
 media/libstagefright/ACodec.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 966fd2d..dc71271 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -5921,7 +5921,7 @@ bool ACodec::LoadedState::onConfigureComponent(
                 0,     // flags
                 &matchingCodecs);
 
-            status_t err = mCodec->mOMX->freeNode(mCodec->mNode);
+            err = mCodec->mOMX->freeNode(mCodec->mNode);
 
             if (err != OK) {
                 ALOGE("Failed to freeNode");
-- 
2.7.4


From 955dd754f0481c7c2cedd900b28a5ec8ae43e594 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Wed, 2 Dec 2015 10:04:24 -0800
Subject: [PATCH 046/119] stagefright: More HW codec support w/ FFMPEGExtractor

 * Support QC DiVX codec

Change-Id: I5591b4544a8f92a7cc309b45a8de009f572217b7
---
 include/media/stagefright/FFMPEGSoftCodec.h |  4 +++
 media/libstagefright/FFMPEGSoftCodec.cpp    | 51 +++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+)

diff --git a/include/media/stagefright/FFMPEGSoftCodec.h b/include/media/stagefright/FFMPEGSoftCodec.h
index 2f31e72..30dafb8 100644
--- a/include/media/stagefright/FFMPEGSoftCodec.h
+++ b/include/media/stagefright/FFMPEGSoftCodec.h
@@ -128,6 +128,10 @@ private:
             const sp<AMessage> &msg, sp<IOMX> OMXhandle,
             IOMX::node_id nodeID);
 
+    static status_t setQCDIVXFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID, int port_index);
+
 };
 
 }
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 2af53b3..3e51322 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -73,6 +73,7 @@ static const MetaKeyEntry MetaKeyTable[] {
    {kKeyWMAVersion           , "wma-version"            , INT32},  // int32_t
    {kKeyWMVVersion           , "wmv-version"            , INT32},
    {kKeyPCMFormat            , "pcm-format"             , INT32},
+   {kKeyDivXVersion          , "divx-version"           , INT32},
 };
 
 const char* FFMPEGSoftCodec::getMsgKey(int key) {
@@ -277,6 +278,14 @@ status_t FFMPEGSoftCodec::setVideoFormat(
     if (err != BAD_TYPE && (strncmp(componentName, "OMX.qcom.", 9) == 0)) {
         status_t xerr = OK;
 
+        if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
+            *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)) {
+            *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+            *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+        }
+
         int32_t mode = 0;
         OMX_QCOM_PARAM_PORTDEFINITIONTYPE portFmt;
         portFmt.nPortIndex = kPortIndexInput;
@@ -295,6 +304,8 @@ status_t FFMPEGSoftCodec::setVideoFormat(
             ALOGW("Failed to set frame packing format on component");
         }
 
+        setQCDIVXFormat(msg, mime, OMXhandle, nodeID, kPortIndexOutput);
+
         // Enable timestamp reordering for mpeg4 and vc1 codec types, the AVI file
         // type, and hevc content in the ts container
         bool tsReorder = false;
@@ -344,6 +355,46 @@ status_t FFMPEGSoftCodec::setVideoFormat(
     return err;
 }
 
+status_t FFMPEGSoftCodec::setQCDIVXFormat(
+        const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, int port_index) {
+    status_t err = OK;
+#ifdef QCOM_HARDWARE
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime) ||
+        !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime) ||
+        !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+        ALOGV("Setting the QOMX_VIDEO_PARAM_DIVXTYPE params ");
+        QOMX_VIDEO_PARAM_DIVXTYPE paramDivX;
+        InitOMXParams(&paramDivX);
+        paramDivX.nPortIndex = port_index;
+        int32_t DivxVersion = 0;
+        if (!msg->findInt32(getMsgKey(kKeyDivXVersion), &DivxVersion)) {
+            DivxVersion = kTypeDivXVer_4;
+            ALOGW("Divx version key missing, initializing the version to %d", DivxVersion);
+        }
+        ALOGV("Divx Version Type %d", DivxVersion);
+
+        if (DivxVersion == kTypeDivXVer_4) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat4;
+        } else if (DivxVersion == kTypeDivXVer_5) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat5;
+        } else if (DivxVersion == kTypeDivXVer_6) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat6;
+        } else if (DivxVersion == kTypeDivXVer_3_11 ) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat311;
+        } else {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormatUnused;
+        }
+        paramDivX.eProfile = (QOMX_VIDEO_DIVXPROFILETYPE)0;    //Not used for now.
+
+        err =  OMXhandle->setParameter(nodeID,
+                         (OMX_INDEXTYPE)OMX_QcomIndexParamVideoDivx,
+                         &paramDivX, sizeof(paramDivX));
+    }
+#endif
+    return err;
+}
+
 status_t FFMPEGSoftCodec::getVideoPortFormat(OMX_U32 portIndex, int coding,
         sp<AMessage> &notify, sp<IOMX> OMXHandle, IOMX::node_id nodeId) {
 
-- 
2.7.4


From a707cabb86c6d4869707c6e1f3fbb44050556dd0 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Wed, 2 Dec 2015 14:56:18 -0800
Subject: [PATCH 047/119] stagefright: Fix build breaks

Fix build breaks on non QCOM_HARDWARE device

Change-Id: I4671fa21cc7836172d356a83381dc80ee6b18f03
---
 include/media/stagefright/FFMPEGSoftCodec.h | 2 ++
 media/libstagefright/FFMPEGSoftCodec.cpp    | 4 ++--
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/include/media/stagefright/FFMPEGSoftCodec.h b/include/media/stagefright/FFMPEGSoftCodec.h
index 30dafb8..79ea229 100644
--- a/include/media/stagefright/FFMPEGSoftCodec.h
+++ b/include/media/stagefright/FFMPEGSoftCodec.h
@@ -128,9 +128,11 @@ private:
             const sp<AMessage> &msg, sp<IOMX> OMXhandle,
             IOMX::node_id nodeID);
 
+#ifdef QCOM_HARDWARE
     static status_t setQCDIVXFormat(
             const sp<AMessage> &msg, const char* mime,
             sp<IOMX> OMXhandle, IOMX::node_id nodeID, int port_index);
+#endif
 
 };
 
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 3e51322..101d765 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -355,11 +355,11 @@ status_t FFMPEGSoftCodec::setVideoFormat(
     return err;
 }
 
+#ifdef QCOM_HARDWARE
 status_t FFMPEGSoftCodec::setQCDIVXFormat(
         const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
         IOMX::node_id nodeID, int port_index) {
     status_t err = OK;
-#ifdef QCOM_HARDWARE
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime) ||
         !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime) ||
         !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
@@ -391,9 +391,9 @@ status_t FFMPEGSoftCodec::setQCDIVXFormat(
                          (OMX_INDEXTYPE)OMX_QcomIndexParamVideoDivx,
                          &paramDivX, sizeof(paramDivX));
     }
-#endif
     return err;
 }
+#endif
 
 status_t FFMPEGSoftCodec::getVideoPortFormat(OMX_U32 portIndex, int coding,
         sp<AMessage> &notify, sp<IOMX> OMXHandle, IOMX::node_id nodeId) {
-- 
2.7.4


From 49779cde4de462e573ab04338f0a4ff2f70e02f2 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Thu, 3 Dec 2015 09:45:42 -0800
Subject: [PATCH 048/119] stagefright: Fix Divx version key

If mime type is MEDIA_MIMETYPE_VIDEO_DIVX4 or MEDIA_MIMETYPE_VIDEO_DIVX311,
the qcom specific portion of code is skipped, since err = BAD_TYPE.
Fix it by checking mimetype div4 and div311 before the qcom
specific code.

Change-Id: Id1a4f43541ef2b0f4d3ab84425965f30be17b7e4
---
 media/libstagefright/FFMPEGSoftCodec.cpp | 88 ++++++++++++++++++--------------
 1 file changed, 51 insertions(+), 37 deletions(-)

diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 101d765..d899351 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -255,6 +255,13 @@ status_t FFMPEGSoftCodec::setVideoFormat(
         *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingFLV1;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
         *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+#ifdef QCOM_HARDWARE
+    // compressionFormat will be override later
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+#endif
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
         *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingHEVC;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FFMPEG, mime)) {
@@ -275,16 +282,9 @@ status_t FFMPEGSoftCodec::setVideoFormat(
     // from the CAF L release. It was unfortunately moved to a proprietary
     // blob and an architecture which is hellish for OEMs who wish to
     // customize the platform.
-    if (err != BAD_TYPE && (strncmp(componentName, "OMX.qcom.", 9) == 0)) {
+    if (err != BAD_TYPE && (!strncmp(componentName, "OMX.qcom.", 9))) {
         status_t xerr = OK;
 
-        if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
-            *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
-        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)) {
-            *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
-        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
-            *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
-        }
 
         int32_t mode = 0;
         OMX_QCOM_PARAM_PORTDEFINITIONTYPE portFmt;
@@ -304,7 +304,13 @@ status_t FFMPEGSoftCodec::setVideoFormat(
             ALOGW("Failed to set frame packing format on component");
         }
 
-        setQCDIVXFormat(msg, mime, OMXhandle, nodeID, kPortIndexOutput);
+        if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime) ||
+                !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime) ||
+                !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+            // Override with QCOM specific compressionFormat
+            *compressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+            setQCDIVXFormat(msg, mime, OMXhandle, nodeID, kPortIndexOutput);
+        }
 
         // Enable timestamp reordering for mpeg4 and vc1 codec types, the AVI file
         // type, and hevc content in the ts container
@@ -360,37 +366,45 @@ status_t FFMPEGSoftCodec::setQCDIVXFormat(
         const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
         IOMX::node_id nodeID, int port_index) {
     status_t err = OK;
-    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime) ||
-        !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime) ||
-        !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
-        ALOGV("Setting the QOMX_VIDEO_PARAM_DIVXTYPE params ");
-        QOMX_VIDEO_PARAM_DIVXTYPE paramDivX;
-        InitOMXParams(&paramDivX);
-        paramDivX.nPortIndex = port_index;
-        int32_t DivxVersion = 0;
-        if (!msg->findInt32(getMsgKey(kKeyDivXVersion), &DivxVersion)) {
+    ALOGV("Setting the QOMX_VIDEO_PARAM_DIVXTYPE params ");
+    QOMX_VIDEO_PARAM_DIVXTYPE paramDivX;
+    InitOMXParams(&paramDivX);
+    paramDivX.nPortIndex = port_index;
+    int32_t DivxVersion = 0;
+    if (!msg->findInt32(getMsgKey(kKeyDivXVersion), &DivxVersion)) {
+        // Cannot find the key, the caller is skipping the container
+        // and use codec directly, let determine divx version from
+        // mime type
+        DivxVersion = kTypeDivXVer_4;
+        const char *v;
+        if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime) ||
+                !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)) {
             DivxVersion = kTypeDivXVer_4;
-            ALOGW("Divx version key missing, initializing the version to %d", DivxVersion);
-        }
-        ALOGV("Divx Version Type %d", DivxVersion);
-
-        if (DivxVersion == kTypeDivXVer_4) {
-            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat4;
-        } else if (DivxVersion == kTypeDivXVer_5) {
-            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat5;
-        } else if (DivxVersion == kTypeDivXVer_6) {
-            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat6;
-        } else if (DivxVersion == kTypeDivXVer_3_11 ) {
-            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat311;
-        } else {
-            paramDivX.eFormat = QOMX_VIDEO_DIVXFormatUnused;
+            v = "4";
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+            DivxVersion = kTypeDivXVer_3_11;
+            v = "3.11";
         }
-        paramDivX.eProfile = (QOMX_VIDEO_DIVXPROFILETYPE)0;    //Not used for now.
-
-        err =  OMXhandle->setParameter(nodeID,
-                         (OMX_INDEXTYPE)OMX_QcomIndexParamVideoDivx,
-                         &paramDivX, sizeof(paramDivX));
+        ALOGW("Divx version key missing, initializing the version to %s", v);
     }
+    ALOGV("Divx Version Type %d", DivxVersion);
+
+    if (DivxVersion == kTypeDivXVer_4) {
+        paramDivX.eFormat = QOMX_VIDEO_DIVXFormat4;
+    } else if (DivxVersion == kTypeDivXVer_5) {
+        paramDivX.eFormat = QOMX_VIDEO_DIVXFormat5;
+    } else if (DivxVersion == kTypeDivXVer_6) {
+        paramDivX.eFormat = QOMX_VIDEO_DIVXFormat6;
+    } else if (DivxVersion == kTypeDivXVer_3_11 ) {
+        paramDivX.eFormat = QOMX_VIDEO_DIVXFormat311;
+    } else {
+        paramDivX.eFormat = QOMX_VIDEO_DIVXFormatUnused;
+    }
+    paramDivX.eProfile = (QOMX_VIDEO_DIVXPROFILETYPE)0;    //Not used for now.
+
+    err =  OMXhandle->setParameter(nodeID,
+            (OMX_INDEXTYPE)OMX_QcomIndexParamVideoDivx,
+            &paramDivX, sizeof(paramDivX));
     return err;
 }
 #endif
-- 
2.7.4


From 33053ad6e06a782f365b0919588a8576567b2318 Mon Sep 17 00:00:00 2001
From: Simon Shields <keepcalm444@gmail.com>
Date: Mon, 7 Dec 2015 17:40:13 +1100
Subject: [PATCH 049/119] libstagefright: squash exynos4 support

commit e41cc838b6212f8711c550522e8cefc95f003a67
Author: rINanDO <drjisakh@gmail.com>
Date:   Mon Aug 10 13:56:56 2015 +0200

    stagefright: Exynos4 MPEG4 decoder should set native color format.

    Change-Id: I41bee77d48fc0b35691b94585de10269579ae789

commit a50263c53a1ecd0f75688f7042dd5e5d9badbc39
Author: Caio Schnepper <caioschnepper@gmail.com>
Date:   Wed Jun 10 22:26:07 2015 -0300

    libstagefright: back off exynos4_enhancements HWC_HWOVERLAY usage

    The open source hwc doesn't support the
    GRALLOC_USAGE_HW_FIMC1 | GRALLOC_USAGE_HWC_HWOVERLAY
    combination. Removing HWC_HWOVERLAY allows FIMC1 to do
    decode/color conversion.

    Change-Id: Ibdfa9e5dd170e99e0d994540979e88e519931641

commit 63286a333bde1aa047de4e2fde8da1b59e42a16d
Author: Ricardo Cerqueira <cyanogenmod@cerqueira.org>
Date:   Sun Nov 3 02:45:19 2013 +0000

    exynos4: libstragefright: add support for samsung colorformat/omx/mfc

    Source:
    http://git.insignal.co.kr/samsung/exynos/android/platform/frameworks/av/commit/?h=exynos-jb&id=1614612f7ca2a00473d202dbedcb135fadc608ad

    Conflicts:

        media/libstagefright/ACodec.cpp
        media/libstagefright/OMXCodec.cpp

    cherry pick from 906eba9f

    Change-Id: I1c174f8e9fa9bd3ed16a0399f070b6680f6a331c

Change-Id: I47f5b09b37ea5376a45c80c9dd91a7fbd0c3361a
---
 include/media/stagefright/ACodec.h                 |  3 ++
 media/libstagefright/ACodec.cpp                    | 34 ++++++++++++++++++++++
 media/libstagefright/Android.mk                    | 10 +++++++
 media/libstagefright/CameraSource.cpp              |  5 ++++
 .../colorconversion/SoftwareRenderer.cpp           | 23 ++++++++++++++-
 5 files changed, 74 insertions(+), 1 deletion(-)

diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index 5b8e2ac..f4b0710 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -310,6 +310,9 @@ protected:
     status_t submitOutputMetadataBuffer();
     void signalSubmitOutputMetadataBufferIfEOS_workaround();
     status_t allocateOutputBuffersFromNativeWindow();
+#ifdef USE_SAMSUNG_COLORFORMAT
+    void setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat);
+#endif
     status_t cancelBufferToNativeWindow(BufferInfo *info);
     status_t freeOutputBuffersNotOwnedByComponent();
     BufferInfo *dequeueBufferFromNativeWindow();
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index dc71271..9ec0f68 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -92,6 +92,10 @@
 #include <OMX_IndexExt.h>
 #include <OMX_AsString.h>
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+#include <sec_format.h>
+#endif
+
 #include "include/avc_utils.h"
 
 #include <stagefright/AVExtensions.h>
@@ -958,12 +962,21 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
     usage |= kVideoGrallocUsage;
     *finalUsage = usage;
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
+    setNativeWindowColorFormat(eNativeColorFormat);
+#endif
+
     ALOGV("gralloc usage: %#x(OMX) => %#x(ACodec)", omxUsage, usage);
     err = setNativeWindowSizeFormatAndUsage(
             nativeWindow,
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+#ifdef USE_SAMSUNG_COLORFORMAT
+            eNativeColorFormat,
+#else
             def.format.video.eColorFormat,
+#endif
             mRotationDegrees,
             usage);
     if (err == OK) {
@@ -1321,6 +1334,27 @@ void ACodec::dumpBuffers(OMX_U32 portIndex) {
     }
 }
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+void ACodec::setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat)
+{
+    // In case of Samsung decoders, we set proper native color format for the Native Window
+    if (!strcasecmp(mComponentName.c_str(), "OMX.SEC.AVC.Decoder")
+        || !strcasecmp(mComponentName.c_str(), "OMX.SEC.FP.AVC.Decoder")
+        || !strcasecmp(mComponentName.c_str(), "OMX.SEC.MPEG4.Decoder")
+        || !strcasecmp(mComponentName.c_str(), "OMX.Exynos.AVC.Decoder")) {
+        switch (eNativeColorFormat) {
+            case OMX_COLOR_FormatYUV420SemiPlanar:
+                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
+                break;
+            case OMX_COLOR_FormatYUV420Planar:
+            default:
+                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
+                break;
+        }
+    }
+}
+#endif
+
 status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_US);
 
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 497997f..110f2ee 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -195,6 +195,16 @@ endif
 LOCAL_C_INCLUDES += $(TOP)/external/stagefright-plugins/include
 
 #LOCAL_CFLAGS += -DLOG_NDEBUG=0
+
+ifeq ($(BOARD_USE_SAMSUNG_COLORFORMAT), true)
+LOCAL_CFLAGS += -DUSE_SAMSUNG_COLORFORMAT
+
+# Include native color format header path
+LOCAL_C_INCLUDES += \
+	$(TOP)/hardware/samsung/exynos4/hal/include \
+	$(TOP)/hardware/samsung/exynos4/include
+endif
+
 LOCAL_MODULE:= libstagefright
 
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 47b4e62..88a87bf 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -116,7 +116,12 @@ static int32_t getColorFormat(const char* colorFormat) {
     }
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
+#ifdef USE_SAMSUNG_COLORFORMAT
+        static const int OMX_SEC_COLOR_FormatNV12LPhysicalAddress = 0x7F000002;
+        return OMX_SEC_COLOR_FormatNV12LPhysicalAddress;
+#else
         return OMX_COLOR_FormatYUV420SemiPlanar;
+#endif
     }
 
 #ifdef USE_SAMSUNG_CAMERAFORMAT_NV21
diff --git a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
index e92c192..3fa29a2 100644
--- a/media/libstagefright/colorconversion/SoftwareRenderer.cpp
+++ b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
@@ -150,11 +150,20 @@ void SoftwareRenderer::resetFormatIfChanged(const sp<AMessage> &format) {
     CHECK(mCropHeight > 0);
     CHECK(mConverter == NULL || mConverter->isValid());
 
+#ifdef EXYNOS4_ENHANCEMENTS
+    CHECK_EQ(0,
+            native_window_set_usage(
+            mNativeWindow.get(),
+            GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_SW_WRITE_OFTEN
+            | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP
+            | GRALLOC_USAGE_HW_FIMC1));
+#else
     CHECK_EQ(0,
             native_window_set_usage(
             mNativeWindow.get(),
             GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_SW_WRITE_OFTEN
             | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP));
+#endif
 
     CHECK_EQ(0,
             native_window_set_scaling_mode(
@@ -282,13 +291,25 @@ std::list<FrameRenderTracker::Info> SoftwareRenderer::render(
         const uint8_t *src_uv = (const uint8_t *)data
                 + mWidth * (mHeight - mCropTop / 2);
 
-        uint8_t *dst_y = (uint8_t *)dst;
+#ifdef EXYNOS4_ENHANCEMENTS
+        void *pYUVBuf[3];
+
+        CHECK_EQ(0, mapper.unlock(buf->handle));
+        CHECK_EQ(0, mapper.lock(
+                buf->handle, GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_YUV_ADDR, bounds, pYUVBuf));
 
+        size_t dst_c_stride = buf->stride / 2;
+        uint8_t *dst_y = (uint8_t *)pYUVBuf[0];
+        uint8_t *dst_v = (uint8_t *)pYUVBuf[1];
+        uint8_t *dst_u = (uint8_t *)pYUVBuf[2];
+#else
+        uint8_t *dst_y = (uint8_t *)dst;
         size_t dst_y_size = buf->stride * buf->height;
         size_t dst_c_stride = ALIGN(buf->stride / 2, 16);
         size_t dst_c_size = dst_c_stride * buf->height / 2;
         uint8_t *dst_v = dst_y + dst_y_size;
         uint8_t *dst_u = dst_v + dst_c_size;
+#endif
 
         for (int y = 0; y < mCropHeight; ++y) {
             memcpy(dst_y, src_y, mCropWidth);
-- 
2.7.4


From 7a5a12d3ea4b618cf5dcd2fd1e0eaac8d29a0f98 Mon Sep 17 00:00:00 2001
From: Mazhar <mazharx.sameullah@intel.com>
Date: Mon, 28 Apr 2014 20:11:21 +0530
Subject: [PATCH 050/119] Fatal error while playing certain mkv files.

In addTracks() function, the value of codecPrivateSize is zero
for the certain mkv contents, which causes this fatal error.
With this fix, error is returned whenever the value of
codecPrivateSize is less than 2, to avoid the fatal error.

Change-Id: I2f464deb7444d4c129aaa4d77bba35a3835bf7e1
Signed-off-by: gbhakteX <gurudattax.bhakte@intel.com>
Signed-off-by: Mazhar <mazharx.sameullah@intel.com>
---
 media/libstagefright/matroska/MatroskaExtractor.cpp | 12 +++++++++---
 media/libstagefright/matroska/MatroskaExtractor.h   |  2 +-
 2 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
index c584669..72112be 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -804,7 +804,12 @@ MatroskaExtractor::MatroskaExtractor(const sp<DataSource> &source)
          info->GetWritingAppAsUTF8());
 #endif
 
-    addTracks();
+    ret = addTracks();
+    if (ret < 0) {
+        delete mSegment;
+        mSegment = NULL;
+        return;
+    }
 }
 
 MatroskaExtractor::~MatroskaExtractor() {
@@ -999,7 +1004,7 @@ status_t addVorbisCodecInfo(
     return OK;
 }
 
-void MatroskaExtractor::addTracks() {
+int MatroskaExtractor::addTracks() {
     const mkvparser::Tracks *tracks = mSegment->GetTracks();
 
     for (size_t index = 0; index < tracks->GetTracksCount(); ++index) {
@@ -1077,7 +1082,7 @@ void MatroskaExtractor::addTracks() {
                 if (!strcmp("A_AAC", codecID)) {
                     meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC);
                     if (codecPrivateSize < 2) {
-                        return;
+                        return -1;
                     }
 
                     addESDSFromCodecPrivate(
@@ -1127,6 +1132,7 @@ void MatroskaExtractor::addTracks() {
         trackInfo->mMeta = meta;
         trackInfo->mExtractor = this;
     }
+    return 0;
 }
 
 void MatroskaExtractor::findThumbnails() {
diff --git a/media/libstagefright/matroska/MatroskaExtractor.h b/media/libstagefright/matroska/MatroskaExtractor.h
index db36bf8..e3a07ec 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.h
+++ b/media/libstagefright/matroska/MatroskaExtractor.h
@@ -74,7 +74,7 @@ private:
     bool mIsWebm;
     int64_t mSeekPreRollNs;
 
-    void addTracks();
+    int addTracks();
     void findThumbnails();
 
     bool isLiveStreaming() const;
-- 
2.7.4


From 5c64c1b68dd82eac8bb944437d0e5bfe21dd7dda Mon Sep 17 00:00:00 2001
From: Jorge Ruesga <jorge@ruesga.com>
Date: Sun, 26 Jul 2015 14:18:53 +0200
Subject: [PATCH 051/119] mediascanner: handle DATE tag

Allow passing DATE tag to MediaScanner in order to use it to retrieve the year, if YEAR tag isn't
present (see http://review.cyanogenmod.org/#/c/101467)

Change-Id: I928177e5473262a45b1041a58f381a00d67e2995
Signed-off-by: Jorge Ruesga <jorge@ruesga.com>
---
 media/libstagefright/StagefrightMediaScanner.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/media/libstagefright/StagefrightMediaScanner.cpp b/media/libstagefright/StagefrightMediaScanner.cpp
index c5018ae..8d3392e 100644
--- a/media/libstagefright/StagefrightMediaScanner.cpp
+++ b/media/libstagefright/StagefrightMediaScanner.cpp
@@ -125,6 +125,7 @@ MediaScanResult StagefrightMediaScanner::processFileInternal(
         { "genre", METADATA_KEY_GENRE },
         { "title", METADATA_KEY_TITLE },
         { "year", METADATA_KEY_YEAR },
+        { "date", METADATA_KEY_DATE },
         { "duration", METADATA_KEY_DURATION },
         { "writer", METADATA_KEY_WRITER },
         { "compilation", METADATA_KEY_COMPILATION },
-- 
2.7.4


From ea7eb39f7b1f74c5b4e0cc0f244bde2929958420 Mon Sep 17 00:00:00 2001
From: Jia Meng <jmeng@codeaurora.org>
Date: Wed, 12 Nov 2014 11:24:47 +0800
Subject: [PATCH 052/119] stagefright: Clear mNoMoreOutputData flag during
 seeking

For some 3rd party players, stop won't be called when playing
to the end. If seeking happens after that, we need to clear
this flag to make it be ready for subsequence data flow.

Change-Id: I9b2d18d03225420a45821ba7536cdc91d52b1312
CRs-Fixed: 755988
---
 media/libstagefright/OMXCodec.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 97bc5b8..2efe997 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -2549,6 +2549,7 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
 
                     // We implicitly resume pulling on our upstream source.
                     mPaused = false;
+                    mNoMoreOutputData = false;
 
                     drainInputBuffers();
                     fillOutputBuffers();
-- 
2.7.4


From 2148c741100adbe081181eff9c9e0797263fe865 Mon Sep 17 00:00:00 2001
From: David Williams <david.williams@sonymobile.com>
Date: Fri, 9 Oct 2015 16:52:06 +0200
Subject: [PATCH 053/119] Cached reading of stsz atom

The entire stsz atom needs to be checked, entry by entry, to
determine the maximum size of a sample so that the proper buffer
size can be allocated by the decoder. This change reads a block of
entries at a time, cutting down the number of file reads and thus
significantly increasing the performance of reading the entries.

Change-Id: Ida39c2fe59bccb4440faeab1e71d8cf58682bcc3
---
 media/libstagefright/SampleIterator.cpp       | 96 +++++++++++++++++----------
 media/libstagefright/include/SampleIterator.h |  5 ++
 2 files changed, 66 insertions(+), 35 deletions(-)

diff --git a/media/libstagefright/SampleIterator.cpp b/media/libstagefright/SampleIterator.cpp
index 7bf3437..0efa270 100644
--- a/media/libstagefright/SampleIterator.cpp
+++ b/media/libstagefright/SampleIterator.cpp
@@ -30,6 +30,8 @@
 
 namespace android {
 
+const uint32_t kMaxSampleCacheSize = 4096;
+
 SampleIterator::SampleIterator(SampleTable *table)
     : mTable(table),
       mInitialized(false),
@@ -37,7 +39,12 @@ SampleIterator::SampleIterator(SampleTable *table)
       mTTSSampleIndex(0),
       mTTSSampleTime(0),
       mTTSCount(0),
-      mTTSDuration(0) {
+      mTTSDuration(0),
+      mSampleCache(NULL) {
+    reset();
+}
+
+SampleIterator::~SampleIterator() {
     reset();
 }
 
@@ -49,6 +56,10 @@ void SampleIterator::reset() {
     mStopChunkSampleIndex = 0;
     mSamplesPerChunk = 0;
     mChunkDesc = 0;
+    delete[] mSampleCache;
+    mSampleCache = NULL;
+    mSampleCacheSize = 0;
+    mCurrentSampleCacheStartIndex = 0;
 }
 
 status_t SampleIterator::seekTo(uint32_t sampleIndex) {
@@ -240,58 +251,73 @@ status_t SampleIterator::getSampleSizeDirect(
         return OK;
     }
 
+    bool readNewSampleCache = false;
+
+    // Check if current sample is inside cache, otherwise read new cache
+    if (sampleIndex < mCurrentSampleCacheStartIndex ||
+            ((sampleIndex - mCurrentSampleCacheStartIndex) *
+            mTable->mSampleSizeFieldSize + 4) / 8 >= mSampleCacheSize) {
+        uint32_t prevCacheSize = mSampleCacheSize;
+        mSampleCacheSize = ((mTable->mNumSampleSizes - sampleIndex) *
+                mTable->mSampleSizeFieldSize + 4) / 8;
+        mSampleCacheSize = mSampleCacheSize > kMaxSampleCacheSize ?
+                kMaxSampleCacheSize : mSampleCacheSize;
+        mCurrentSampleCacheStartIndex = sampleIndex;
+        readNewSampleCache = true;
+        if (mSampleCacheSize != prevCacheSize) {
+            delete[] mSampleCache;
+            mSampleCache = new uint8_t[mSampleCacheSize];
+        }
+    }
+
+    if (mSampleCache == NULL) {
+        return ERROR_IO;
+    }
+
+    if (mTable->mSampleSizeFieldSize != 32 &&
+        mTable->mSampleSizeFieldSize != 16 &&
+        mTable->mSampleSizeFieldSize != 8 &&
+        mTable->mSampleSizeFieldSize != 4) {
+        return ERROR_IO;
+    }
+
+    if (readNewSampleCache) {
+        if (mTable->mDataSource->readAt(
+                    mTable->mSampleSizeOffset + 12 +
+                        mTable->mSampleSizeFieldSize * sampleIndex / 8,
+                    mSampleCache,
+                    mSampleCacheSize) < (int32_t) mSampleCacheSize) {
+            return ERROR_IO;
+        }
+    }
+
+    uint32_t cacheReadOffset = (sampleIndex - mCurrentSampleCacheStartIndex) *
+                                mTable->mSampleSizeFieldSize / 8;
+
     switch (mTable->mSampleSizeFieldSize) {
         case 32:
         {
-            if (mTable->mDataSource->readAt(
-                        mTable->mSampleSizeOffset + 12 + 4 * sampleIndex,
-                        size, sizeof(*size)) < (ssize_t)sizeof(*size)) {
-                return ERROR_IO;
-            }
-
-            *size = ntohl(*size);
+            *size = ntohl(*((size_t *) &(mSampleCache[cacheReadOffset])));
             break;
         }
 
         case 16:
         {
-            uint16_t x;
-            if (mTable->mDataSource->readAt(
-                        mTable->mSampleSizeOffset + 12 + 2 * sampleIndex,
-                        &x, sizeof(x)) < (ssize_t)sizeof(x)) {
-                return ERROR_IO;
-            }
-
-            *size = ntohs(x);
+            *size = ntohs(*((uint16_t *) &(mSampleCache[cacheReadOffset])));
             break;
         }
 
         case 8:
         {
-            uint8_t x;
-            if (mTable->mDataSource->readAt(
-                        mTable->mSampleSizeOffset + 12 + sampleIndex,
-                        &x, sizeof(x)) < (ssize_t)sizeof(x)) {
-                return ERROR_IO;
-            }
-
-            *size = x;
+            *size = mSampleCache[cacheReadOffset];
             break;
         }
 
         default:
         {
-            CHECK_EQ(mTable->mSampleSizeFieldSize, 4);
-
-            uint8_t x;
-            if (mTable->mDataSource->readAt(
-                        mTable->mSampleSizeOffset + 12 + sampleIndex / 2,
-                        &x, sizeof(x)) < (ssize_t)sizeof(x)) {
-                return ERROR_IO;
-            }
-
-            *size = (sampleIndex & 1) ? x & 0x0f : x >> 4;
-            break;
+            *size = (sampleIndex - mCurrentSampleCacheStartIndex) & 0x01 ?
+                    (mSampleCache[cacheReadOffset] & 0x0f) :
+                    (mSampleCache[cacheReadOffset] & 0xf0) >> 4;
         }
     }
 
diff --git a/media/libstagefright/include/SampleIterator.h b/media/libstagefright/include/SampleIterator.h
index 2ef41ae..4ad7f2e 100644
--- a/media/libstagefright/include/SampleIterator.h
+++ b/media/libstagefright/include/SampleIterator.h
@@ -26,6 +26,7 @@ class SampleTable;
 
 struct SampleIterator {
     SampleIterator(SampleTable *table);
+    ~SampleIterator();
 
     status_t seekTo(uint32_t sampleIndex);
 
@@ -68,6 +69,10 @@ private:
     uint32_t mCurrentSampleTime;
     uint32_t mCurrentSampleDuration;
 
+    uint8_t *mSampleCache;
+    uint32_t mSampleCacheSize;
+    uint32_t mCurrentSampleCacheStartIndex;
+
     void reset();
     status_t findChunkRange(uint32_t sampleIndex);
     status_t getChunkOffset(uint32_t chunk, off64_t *offset);
-- 
2.7.4


From ba9e35ee007fa7ba7ac30905cc5496f5af7dbd84 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Mon, 7 Dec 2015 16:24:32 -0800
Subject: [PATCH 054/119] stagefright: Add OMX.ffmpeg. checking

Port from L, add "OMX.ffmpeg." checking in additional
to "OMX.google." for software codec

Change-Id: I3ef70a965573d7c2818236a70d4f99b6b7873468
---
 media/libstagefright/AwesomePlayer.cpp | 1 +
 media/libstagefright/OMXClient.cpp     | 2 +-
 media/libstagefright/OMXCodec.cpp      | 3 ++-
 3 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index 778dfa5..5a43caf 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -1245,6 +1245,7 @@ void AwesomePlayer::initRenderer_l() {
     setVideoScalingMode_l(mVideoScalingMode);
     if (USE_SURFACE_ALLOC
             && !strncmp(component, "OMX.", 4)
+            && strncmp(component, "OMX.ffmpeg.", 11)
             && strncmp(component, "OMX.google.", 11)) {
         // Hardware decoders avoid the CPU color conversion by decoding
         // directly to ANativeBuffers, so we must use a renderer that
diff --git a/media/libstagefright/OMXClient.cpp b/media/libstagefright/OMXClient.cpp
index ac925f7..eff07f9 100644
--- a/media/libstagefright/OMXClient.cpp
+++ b/media/libstagefright/OMXClient.cpp
@@ -189,7 +189,7 @@ bool MuxOMX::CanLiveLocally(const char *name) {
     return false;
 #else
     // 32 bit processes run only OMX.google.* components locally
-    return !strncasecmp(name, "OMX.google.", 11);
+    return !strncasecmp(name, "OMX.google.", 11) || !strncasecmp(name, "OMX.ffmpeg.", 11);
 #endif
 }
 
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 2efe997..8fd3951 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -200,7 +200,8 @@ static bool IsSoftwareCodec(const char *componentName) {
         return true;
     }
 #endif // DOLBY_END
-    if (!strncmp("OMX.google.", componentName, 11)) {
+    if (!strncmp("OMX.google.", componentName, 11)
+        || !strncmp("OMX.ffmpeg.", componentName, 11)) {
         return true;
     }
 
-- 
2.7.4


From a97ed2dc0a4b5ce6029ea70809a95f89915beb5f Mon Sep 17 00:00:00 2001
From: Michael Bestas <mikeioannina@gmail.com>
Date: Sat, 12 Dec 2015 21:59:49 +0200
Subject: [PATCH 055/119] StagefrightRecorder: Add support for WAVE recording

* Forward port the cm-12.1 code

Change-Id: I77373a236108507b8fa76cc8d3016de36aade301
---
 include/media/stagefright/WAVEWriter.h             | 108 +++++++
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  19 ++
 media/libmediaplayerservice/StagefrightRecorder.h  |   1 +
 media/libstagefright/Android.mk                    |   1 +
 media/libstagefright/WAVEWriter.cpp                | 323 +++++++++++++++++++++
 5 files changed, 452 insertions(+)
 create mode 100644 include/media/stagefright/WAVEWriter.h
 create mode 100644 media/libstagefright/WAVEWriter.cpp

diff --git a/include/media/stagefright/WAVEWriter.h b/include/media/stagefright/WAVEWriter.h
new file mode 100644
index 0000000..766d8f4
--- /dev/null
+++ b/include/media/stagefright/WAVEWriter.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WAVE_WRITER_H_
+
+#define WAVE_WRITER_H_
+
+#include <stdio.h>
+
+#include <media/stagefright/MediaWriter.h>
+#include <utils/threads.h>
+
+namespace android {
+
+
+#define ID_RIFF 0x46464952
+#define ID_WAVE 0x45564157
+#define ID_FMT  0x20746d66
+#define ID_DATA 0x61746164
+#define FORMAT_PCM 1
+
+
+struct MediaSource;
+struct MetaData;
+
+struct wav_header {
+    uint32_t riff_id;
+    uint32_t riff_sz;
+    uint32_t riff_fmt;
+    uint32_t fmt_id;
+    uint32_t fmt_sz;
+    uint16_t audio_format;
+    uint16_t num_channels;
+    uint32_t sample_rate;
+    uint32_t byte_rate;       /* sample_rate * num_channels * bps / 8 */
+    uint16_t block_align;     /* num_channels * bps / 8 */
+    uint16_t bits_per_sample;
+    uint32_t data_id;
+    uint32_t data_sz;
+};
+
+
+struct WAVEWriter : public MediaWriter {
+    WAVEWriter(const char *filename);
+    WAVEWriter(int fd);
+
+    status_t initCheck() const;
+
+    virtual status_t addSource(const sp<MediaSource> &source);
+    virtual bool reachedEOS();
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+    virtual status_t pause();
+
+protected:
+    virtual ~WAVEWriter();
+
+private:
+    int   mFd;
+    status_t mInitCheck;
+    sp<MediaSource> mSource;
+    bool mStarted;
+    volatile bool mPaused;
+    volatile bool mResumed;
+    volatile bool mDone;
+    volatile bool mReachedEOS;
+    pthread_t mThread;
+    int64_t mEstimatedSizeBytes;
+    int64_t mEstimatedDurationUs;
+
+    static void *ThreadWrapper(void *);
+    status_t threadFunc();
+    bool exceedsFileSizeLimit();
+    bool exceedsFileDurationLimit();
+
+    WAVEWriter(const WAVEWriter &);
+    WAVEWriter &operator=(const WAVEWriter &);
+};
+
+}  // namespace android
+
+#endif  // WAVE_WRITER_H_
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 5609333..fae9b7d 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -44,6 +44,7 @@
 #include <media/stagefright/MediaCodecSource.h>
 #include <media/stagefright/OMXClient.h>
 #include <media/stagefright/OMXCodec.h>
+#include <media/stagefright/WAVEWriter.h>
 #include <media/MediaProfiles.h>
 #include <camera/ICamera.h>
 #include <camera/CameraParameters.h>
@@ -822,6 +823,10 @@ status_t StagefrightRecorder::prepareInternal() {
             status = setupMPEG2TSRecording();
             break;
 
+        case OUTPUT_FORMAT_WAVE:
+            status = setupWAVERecording();
+            break;
+
         default:
             if (handleCustomRecording() != OK) {
                 ALOGE("Unsupported output file format: %d", mOutputFormat);
@@ -899,6 +904,7 @@ status_t StagefrightRecorder::start() {
         case OUTPUT_FORMAT_AAC_ADTS:
         case OUTPUT_FORMAT_RTP_AVP:
         case OUTPUT_FORMAT_MPEG2TS:
+        case OUTPUT_FORMAT_WAVE:
         {
             status = mWriter->start();
             break;
@@ -991,6 +997,9 @@ sp<MediaSource> StagefrightRecorder::createAudioSource() {
             format->setString("mime", MEDIA_MIMETYPE_AUDIO_AAC);
             format->setInt32("aac-profile", OMX_AUDIO_AACObjectELD);
             break;
+        case AUDIO_ENCODER_LPCM:
+            format->setString("mime", MEDIA_MIMETYPE_AUDIO_RAW);
+            break;
 
         default:
             if (handleCustomAudioSource(format) != OK) {
@@ -1193,6 +1202,15 @@ status_t StagefrightRecorder::setupMPEG2TSRecording() {
     return OK;
 }
 
+status_t StagefrightRecorder::setupWAVERecording() {
+    CHECK(mOutputFormat == OUTPUT_FORMAT_WAVE);
+    CHECK(mAudioEncoder == AUDIO_ENCODER_LPCM);
+    CHECK(mAudioSource != AUDIO_SOURCE_CNT);
+
+    mWriter = new WAVEWriter(mOutputFd);
+    return setupRawAudioRecording();
+}
+
 void StagefrightRecorder::clipVideoFrameRate() {
     ALOGV("clipVideoFrameRate: encoder %d", mVideoEncoder);
     if (mFrameRate == -1) {
@@ -1662,6 +1680,7 @@ status_t StagefrightRecorder::setupAudioEncoder(const sp<MediaWriter>& writer) {
         case AUDIO_ENCODER_AAC:
         case AUDIO_ENCODER_HE_AAC:
         case AUDIO_ENCODER_AAC_ELD:
+        case AUDIO_ENCODER_LPCM:
             break;
 
         default:
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index 6c14993..72dc77b 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -199,6 +199,7 @@ protected:
     StagefrightRecorder(const StagefrightRecorder &);
     StagefrightRecorder &operator=(const StagefrightRecorder &);
 
+    status_t setupWAVERecording();
 public:
     virtual status_t setSourcePause(bool pause);
 };
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 110f2ee..74f93bc 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -85,6 +85,7 @@ LOCAL_SRC_FILES:=                         \
         VBRISeeker.cpp                    \
         VideoFrameScheduler.cpp           \
         WAVExtractor.cpp                  \
+        WAVEWriter.cpp                    \
         WVMExtractor.cpp                  \
         XINGSeeker.cpp                    \
         avc_utils.cpp                     \
diff --git a/media/libstagefright/WAVEWriter.cpp b/media/libstagefright/WAVEWriter.cpp
new file mode 100644
index 0000000..fe3c53b
--- /dev/null
+++ b/media/libstagefright/WAVEWriter.cpp
@@ -0,0 +1,323 @@
+/*
+* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*/
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "WAVEWriter"
+#include <utils/Log.h>
+
+#include <media/stagefright/WAVEWriter.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/mediarecorder.h>
+#include <sys/prctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+namespace android {
+
+static struct wav_header hdr;
+
+
+WAVEWriter::WAVEWriter(const char *filename)
+    : mFd(-1),
+      mInitCheck(NO_INIT),
+      mStarted(false),
+      mPaused(false),
+      mResumed(false) {
+
+    mFd = open(filename, O_CREAT | O_LARGEFILE | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR);
+    if (mFd >= 0) {
+        mInitCheck = OK;
+    }
+}
+
+WAVEWriter::WAVEWriter(int fd)
+    : mFd(dup(fd)),
+      mInitCheck(mFd < 0? NO_INIT: OK),
+      mStarted(false),
+      mPaused(false),
+      mResumed(false) {
+}
+
+WAVEWriter::~WAVEWriter() {
+    if (mStarted) {
+        stop();
+    }
+
+    if (mFd != -1) {
+        close(mFd);
+        mFd = -1;
+    }
+}
+
+status_t WAVEWriter::initCheck() const {
+    return mInitCheck;
+}
+
+status_t WAVEWriter::addSource(const sp<MediaSource> &source) {
+    if (mInitCheck != OK) {
+        ALOGE("Init Check not OK, return");
+        return mInitCheck;
+    }
+
+    if (mSource != NULL) {
+        ALOGE("A source already exists, return");
+        return UNKNOWN_ERROR;
+    }
+
+    sp<MetaData> meta = source->getFormat();
+
+    const char *mime;
+    CHECK(meta->findCString(kKeyMIMEType, &mime));
+
+    int32_t channelCount;
+    int32_t sampleRate;
+    CHECK(meta->findInt32(kKeyChannelCount, &channelCount));
+    CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+
+    memset(&hdr, 0, sizeof(struct wav_header));
+    hdr.riff_id = ID_RIFF;
+    hdr.riff_fmt = ID_WAVE;
+    hdr.fmt_id = ID_FMT;
+    hdr.fmt_sz = 16;
+    hdr.audio_format = FORMAT_PCM;
+    hdr.num_channels = channelCount;
+    hdr.sample_rate = sampleRate;
+    hdr.bits_per_sample = 16;
+    hdr.byte_rate = (sampleRate * channelCount * hdr.bits_per_sample) / 8;
+    hdr.block_align = ( hdr.bits_per_sample * channelCount ) / 8;
+    hdr.data_id = ID_DATA;
+    hdr.data_sz = 0;
+    hdr.riff_sz = hdr.data_sz + 44 - 8;
+
+    if (write(mFd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
+        ALOGE("Write header error, return ERROR_IO");
+        return -ERROR_IO;
+    }
+
+    mSource = source;
+
+    return OK;
+}
+
+status_t WAVEWriter::start(MetaData * /* params */) {
+    if (mInitCheck != OK) {
+        ALOGE("Init Check not OK, return");
+        return mInitCheck;
+    }
+
+    if (mSource == NULL) {
+        ALOGE("NULL Source");
+        return UNKNOWN_ERROR;
+    }
+
+    if (mStarted && mPaused) {
+        mPaused = false;
+        mResumed = true;
+        return OK;
+    } else if (mStarted) {
+        ALOGE("Already startd, return");
+        return OK;
+    }
+
+    status_t err = mSource->start();
+
+    if (err != OK) {
+        return err;
+    }
+
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    mReachedEOS = false;
+    mDone = false;
+
+    pthread_create(&mThread, &attr, ThreadWrapper, this);
+    pthread_attr_destroy(&attr);
+
+    mStarted = true;
+
+    return OK;
+}
+
+status_t WAVEWriter::pause() {
+    if (!mStarted) {
+        return OK;
+    }
+    mPaused = true;
+    return OK;
+}
+
+status_t WAVEWriter::stop() {
+    if (!mStarted) {
+        return OK;
+    }
+
+    mDone = true;
+
+    void *dummy;
+    pthread_join(mThread, &dummy);
+
+    status_t err = static_cast<status_t>(reinterpret_cast<uintptr_t>(dummy));
+    {
+        status_t status = mSource->stop();
+        if (err == OK &&
+            (status != OK && status != ERROR_END_OF_STREAM)) {
+            err = status;
+        }
+    }
+
+    mStarted = false;
+    return err;
+}
+
+bool WAVEWriter::exceedsFileSizeLimit() {
+    if (mMaxFileSizeLimitBytes == 0) {
+        return false;
+    }
+    return mEstimatedSizeBytes >= mMaxFileSizeLimitBytes;
+}
+
+bool WAVEWriter::exceedsFileDurationLimit() {
+    if (mMaxFileDurationLimitUs == 0) {
+        return false;
+    }
+    return mEstimatedDurationUs >= mMaxFileDurationLimitUs;
+}
+
+// static
+void *WAVEWriter::ThreadWrapper(void *me) {
+    return (void *) (uintptr_t)static_cast<WAVEWriter *>(me)->threadFunc();
+}
+
+status_t WAVEWriter::threadFunc() {
+    mEstimatedDurationUs = 0;
+    mEstimatedSizeBytes = 0;
+    bool stoppedPrematurely = true;
+    int64_t previousPausedDurationUs = 0;
+    int64_t maxTimestampUs = 0;
+    status_t err = OK;
+
+    prctl(PR_SET_NAME, (unsigned long)"WAVEWriter", 0, 0, 0);
+    hdr.data_sz = 0;
+    while (!mDone) {
+        MediaBuffer *buffer;
+        err = mSource->read(&buffer);
+
+        if (err != OK) {
+            break;
+        }
+
+        if (mPaused) {
+            buffer->release();
+            buffer = NULL;
+            continue;
+        }
+
+        mEstimatedSizeBytes += buffer->range_length();
+        if (exceedsFileSizeLimit()) {
+            buffer->release();
+            buffer = NULL;
+            notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, 0);
+            break;
+        }
+
+        int64_t timestampUs;
+        CHECK(buffer->meta_data()->findInt64(kKeyTime, &timestampUs));
+        if (timestampUs > mEstimatedDurationUs) {
+            mEstimatedDurationUs = timestampUs;
+        }
+        if (mResumed) {
+            previousPausedDurationUs += (timestampUs - maxTimestampUs - 20000);
+            mResumed = false;
+        }
+        timestampUs -= previousPausedDurationUs;
+        ALOGV("time stamp: %lld, previous paused duration: %lld",
+                timestampUs, previousPausedDurationUs);
+        if (timestampUs > maxTimestampUs) {
+            maxTimestampUs = timestampUs;
+        }
+
+        if (exceedsFileDurationLimit()) {
+            buffer->release();
+            buffer = NULL;
+            notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, 0);
+            break;
+        }
+        ssize_t n = write(mFd,
+                        (const uint8_t *)buffer->data() + buffer->range_offset(),
+                        buffer->range_length());
+
+        hdr.data_sz += (ssize_t)buffer->range_length();
+        hdr.riff_sz = hdr.data_sz + 44 - 8;
+
+        if (n < (ssize_t)buffer->range_length()) {
+            buffer->release();
+            buffer = NULL;
+
+            break;
+        }
+
+        if (stoppedPrematurely) {
+            stoppedPrematurely = false;
+        }
+
+        buffer->release();
+        buffer = NULL;
+    }
+
+    if (stoppedPrematurely) {
+        notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_TRACK_INFO_COMPLETION_STATUS, UNKNOWN_ERROR);
+    }
+
+    lseek(mFd, 0, SEEK_SET);
+    write(mFd, &hdr, sizeof(hdr));
+    lseek(mFd, 0, SEEK_END);
+
+    close(mFd);
+    mFd = -1;
+    mReachedEOS = true;
+    if (err == ERROR_END_OF_STREAM) {
+        return OK;
+    }
+    return err;
+}
+
+bool WAVEWriter::reachedEOS() {
+    return mReachedEOS;
+}
+
+}  // namespace android
-- 
2.7.4


From 8b1b373e9904efd269241b6f4ef43debca6760ba Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sun, 13 Dec 2015 08:54:18 -0800
Subject: [PATCH 056/119] stagefright: Fix a few format strings on 64-bit

Change-Id: I25708df616fe53d709b80c65ddecbdddef303124
---
 media/libmediaplayerservice/nuplayer/StreamingSource.cpp | 2 +-
 media/libstagefright/WAVEWriter.cpp                      | 3 ++-
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/StreamingSource.cpp b/media/libmediaplayerservice/nuplayer/StreamingSource.cpp
index 0246b59..23bed9e 100644
--- a/media/libmediaplayerservice/nuplayer/StreamingSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/StreamingSource.cpp
@@ -248,7 +248,7 @@ status_t NuPlayer::StreamingSource::dequeueAccessUnit(
     if (err == OK) {
         int64_t timeUs;
         CHECK((*accessUnit)->meta()->findInt64("timeUs", &timeUs));
-        ALOGV("dequeueAccessUnit timeUs=%lld us", timeUs);
+        ALOGV("dequeueAccessUnit timeUs=%" PRId64 " us", timeUs);
     }
 #endif
 
diff --git a/media/libstagefright/WAVEWriter.cpp b/media/libstagefright/WAVEWriter.cpp
index fe3c53b..2bd4287 100644
--- a/media/libstagefright/WAVEWriter.cpp
+++ b/media/libstagefright/WAVEWriter.cpp
@@ -44,6 +44,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <inttypes.h>
 
 namespace android {
 
@@ -265,7 +266,7 @@ status_t WAVEWriter::threadFunc() {
             mResumed = false;
         }
         timestampUs -= previousPausedDurationUs;
-        ALOGV("time stamp: %lld, previous paused duration: %lld",
+        ALOGV("time stamp: %" PRId64 ", previous paused duration: %" PRId64,
                 timestampUs, previousPausedDurationUs);
         if (timestampUs > maxTimestampUs) {
             maxTimestampUs = timestampUs;
-- 
2.7.4


From 6cbc3993eca0f3f04c49d9a645f13263c61f473e Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Wed, 9 Dec 2015 20:44:26 -0800
Subject: [PATCH 057/119] stagefright: Resurrect PCM offload

 * Forward-port the open-source code from L which was moved to closed-source
   in M. This is being done out of necessity- the architecture chosen by
   Qualcomm is not optimal and doesn't work well with a singular
   codebase which attempts to service a large number of devices.
 * This patch brings in the code to support PCM offload (AudioFlinger
   bypass). This allows for playback of high resolution clips without
   decimation stages, and enables reduced power consumption for audio
   pipelines which take advantage of the Hexagon DSP (effects).

Change-Id: I0ef15fc3df538ab723f3c12ce0ed71d0e607c99e
---
 media/libavextensions/Android.mk                   |   8 +-
 media/libavextensions/media/AVMediaExtensions.h    |   5 +-
 .../mediaplayerservice/AVNuUtils.cpp               | 257 ++++++++++++++++++--
 media/libavextensions/stagefright/AVUtils.cpp      | 267 +++++++++++++++++++--
 media/libmediaplayerservice/Android.mk             |   3 +-
 media/libmediaplayerservice/nuplayer/Android.mk    |   2 +-
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |  63 ++++-
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |  10 +-
 .../nuplayer/NuPlayerDecoderPassThrough.cpp        |  12 +-
 .../nuplayer/NuPlayerDecoderPassThrough.h          |   1 +
 .../nuplayer/NuPlayerRenderer.cpp                  | 214 +++++++++--------
 11 files changed, 693 insertions(+), 149 deletions(-)

diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
index 6b2a2eb..c597697 100644
--- a/media/libavextensions/Android.mk
+++ b/media/libavextensions/Android.mk
@@ -23,7 +23,7 @@ ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
 endif
 
 LOCAL_MODULE:= libavextensions
-LOCAL_CLANG := false
+LOCAL_CFLAGS += -DLOG_NDEBUG=0
 
 LOCAL_MODULE_TAGS := optional
 
@@ -42,6 +42,7 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/external/flac/include \
+        $(TOP)/system/media/audio_utils/include \
         $(TOP)/$(call project-path-for,qcom-media)/mm-core/inc
 
 LOCAL_CFLAGS += -Wno-multichar -Werror
@@ -51,7 +52,7 @@ ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
 endif
 
 LOCAL_MODULE:= libavmediaextentions
-LOCAL_CLANG := false
+LOCAL_CFLAGS += -DLOG_NDEBUG=0
 
 LOCAL_MODULE_TAGS := optional
 
@@ -76,6 +77,7 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/external/flac/include \
+        $(TOP)/system/media/audio_utils/include \
         $(TOP)/$(call project-path-for,qcom-media)/mm-core/inc
 
 LOCAL_CFLAGS += -Wno-multichar -Werror
@@ -89,7 +91,7 @@ ifeq ($(TARGET_BOARD_PLATFORM),msm8974)
 endif
 
 LOCAL_MODULE:= libavmediaserviceextensions
-LOCAL_CLANG := false
+LOCAL_CFLAGS += -DLOG_NDEBUG=0
 
 LOCAL_MODULE_TAGS := optional
 
diff --git a/media/libavextensions/media/AVMediaExtensions.h b/media/libavextensions/media/AVMediaExtensions.h
index 9161fae..d48feec 100644
--- a/media/libavextensions/media/AVMediaExtensions.h
+++ b/media/libavextensions/media/AVMediaExtensions.h
@@ -33,6 +33,7 @@
 #include <common/AVExtensionsCommon.h>
 #include <hardware/audio.h>
 #include <media/AudioTrack.h>
+#include <audio_utils/format.h>
 
 namespace android {
 
@@ -43,8 +44,8 @@ class Parcel;
  */
 struct AVMediaUtils {
 
-    virtual bool AudioTrackIsPcmOffloaded(const audio_format_t /*format*/) {
-        return false;
+    virtual bool AudioTrackIsPcmOffloaded(const audio_format_t format) {
+        return audio_is_offload_pcm(format);
     }
     virtual status_t AudioTrackGetPosition(AudioTrack* /*track*/,
             uint32_t* /*position*/) {
diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index 3e70c0a..b795aac 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -30,10 +30,18 @@
 #define LOG_TAG "AVNuUtils"
 #include <utils/Log.h>
 
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/foundation/ABitReader.h>
 #include <media/stagefright/foundation/ADebug.h>
-#include <media/stagefright/foundation/AMessage.h>
-
+#include <media/stagefright/foundation/ABuffer.h>
 #include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/OMXCodec.h>
+#include <cutils/properties.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/MediaProfiles.h>
+#include <media/stagefright/Utils.h>
+
+#include <audio_utils/format.h>
 
 #include <nuplayer/NuPlayer.h>
 #include <nuplayer/NuPlayerDecoderBase.h>
@@ -46,12 +54,116 @@
 
 namespace android {
 
+static bool is24bitPCMOffloadEnabled() {
+    char propPCMOfload[PROPERTY_VALUE_MAX] = {0};
+    property_get("audio.offload.pcm.24bit.enable", propPCMOfload, "0");
+    if (!strncmp(propPCMOfload, "true", 4) || atoi(propPCMOfload))
+        return true;
+    else
+        return false;
+}
+
+static bool is16bitPCMOffloadEnabled() {
+    char propPCMOfload[PROPERTY_VALUE_MAX] = {0};
+    property_get("audio.offload.pcm.16bit.enable", propPCMOfload, "0");
+    if (!strncmp(propPCMOfload, "true", 4) || atoi(propPCMOfload))
+        return true;
+    else
+        return false;
+}
+
 sp<MetaData> AVNuUtils::createPCMMetaFromSource(const sp<MetaData> &sMeta) {
-    return sMeta;
+    sp<MetaData> tPCMMeta = new MetaData;
+    //hard code as RAW
+    tPCMMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+
+    int32_t bits = 16;
+    sMeta->findInt32(kKeyBitsPerSample, &bits);
+    tPCMMeta->setInt32(kKeyBitsPerSample, bits > 24 ? 24 : bits);
+
+    if (sMeta == NULL) {
+        ALOGW("no meta returning dummy meta");
+        return tPCMMeta;
+    }
+
+    int32_t srate = -1;
+    if (!sMeta->findInt32(kKeySampleRate, &srate)) {
+        ALOGV("No sample rate");
+    }
+    tPCMMeta->setInt32(kKeySampleRate, srate);
+
+    int32_t cmask = 0;
+    if (!sMeta->findInt32(kKeyChannelMask, &cmask) || (cmask == 0)) {
+        ALOGI("No channel mask, try channel count");
+    }
+    int32_t channelCount = 0;
+    if (!sMeta->findInt32(kKeyChannelCount, &channelCount)) {
+        ALOGI("No channel count either");
+    } else {
+        //if channel mask is not set till now, use channel count
+        //to retrieve channel count
+        if (!cmask) {
+            cmask = audio_channel_out_mask_from_count(channelCount);
+        }
+    }
+    tPCMMeta->setInt32(kKeyChannelCount, channelCount);
+    tPCMMeta->setInt32(kKeyChannelMask, cmask);
+
+    int64_t duration = INT_MAX;
+    if (!sMeta->findInt64(kKeyDuration, &duration)) {
+        ALOGW("No duration in meta setting max duration");
+    }
+    tPCMMeta->setInt64(kKeyDuration, duration);
+
+    int32_t bitRate = -1;
+    if (!sMeta->findInt32(kKeyBitRate, &bitRate)) {
+        ALOGW("No bitrate info");
+    } else {
+        tPCMMeta->setInt32(kKeyBitRate, bitRate);
+    }
+
+    return tPCMMeta;
 }
 
-bool AVNuUtils::pcmOffloadException(const sp<MetaData> &) {
-    return true;
+bool AVNuUtils::pcmOffloadException(const sp<MetaData> &meta) {
+    bool decision = false;
+    const char *mime = {0};
+
+    if (meta == NULL) {
+        return true;
+    }
+    meta->findCString(kKeyMIMEType, &mime);
+
+    if (!mime) {
+        ALOGV("%s: no audio mime present, ignoring pcm offload", __func__);
+        return true;
+    }
+//#if defined (PCM_OFFLOAD_ENABLED) || defined (PCM_OFFLOAD_ENABLED_24)
+    const char * const ExceptionTable[] = {
+        MEDIA_MIMETYPE_AUDIO_AMR_NB,
+        MEDIA_MIMETYPE_AUDIO_AMR_WB,
+        MEDIA_MIMETYPE_AUDIO_QCELP,
+        MEDIA_MIMETYPE_AUDIO_G711_ALAW,
+        MEDIA_MIMETYPE_AUDIO_G711_MLAW,
+        MEDIA_MIMETYPE_AUDIO_EVRC
+    };
+    int countException = (sizeof(ExceptionTable) / sizeof(ExceptionTable[0]));
+
+    for(int i = 0; i < countException; i++) {
+        if (!strcasecmp(mime, ExceptionTable[i])) {
+            decision = true;
+            break;
+        }
+    }
+    ALOGI("decision %d mime %s", decision, mime);
+    return decision;
+#if 0
+    //if PCM offload flag is disabled, do not offload any sessions
+    //using pcm offload
+    decision = true;
+    ALOGI("decision %d mime %s", decision, mime);
+    return decision;
+#endif
 }
 
 bool AVNuUtils::isRAWFormat(const sp<MetaData> &meta) {
@@ -83,44 +195,145 @@ bool AVNuUtils::isVorbisFormat(const sp<MetaData> &) {
     return false;
 }
 
-int AVNuUtils::updateAudioBitWidth(audio_format_t /*audioFormat*/,
-        const sp<AMessage> &){
-    return 16;
+int AVNuUtils::updateAudioBitWidth(audio_format_t audioFormat,
+        const sp<AMessage> &format){
+    int bits = 16;
+    if (audio_is_linear_pcm(audioFormat) || audio_is_offload_pcm(audioFormat)) {
+        bits = audio_bytes_per_sample(audioFormat) * 8;
+        format->setInt32("bits-per-sample", bits);
+    }
+    return bits;
 }
 
 audio_format_t AVNuUtils::getKeyPCMFormat(const sp<MetaData> &meta) {
-    int32_t pcmFormat = 0;
-    if (meta->findInt32('pfmt', &pcmFormat))
-        return (audio_format_t)pcmFormat;
-
-    return AUDIO_FORMAT_PCM_16_BIT;
+    audio_format_t pcmFormat = AUDIO_FORMAT_INVALID;
+    meta->findInt32('pfmt', (int32_t *)&pcmFormat);
+    return pcmFormat;
 }
 
 void AVNuUtils::setKeyPCMFormat(const sp<MetaData> &meta, audio_format_t audioFormat) {
-    if (audio_is_linear_pcm(audioFormat))
+    if (meta != NULL && audio_is_linear_pcm(audioFormat))
         meta->setInt32('pfmt', audioFormat);
 }
 
-audio_format_t AVNuUtils::getPCMFormat(const sp<AMessage> &/*format*/) {
-    return AUDIO_FORMAT_PCM_16_BIT;
+audio_format_t AVNuUtils::getPCMFormat(const sp<AMessage> &format) {
+    audio_format_t pcmFormat = AUDIO_FORMAT_INVALID;
+    format->findInt32("pcm-format", (int32_t *)&pcmFormat);
+    return pcmFormat;
 }
 
 void AVNuUtils::setPCMFormat(const sp<AMessage> &format, audio_format_t audioFormat) {
-    if (audio_is_linear_pcm(audioFormat))
+    if (audio_is_linear_pcm(audioFormat) || audio_is_offload_pcm(audioFormat))
         format->setInt32("pcm-format", audioFormat);
 }
 
-void AVNuUtils::setSourcePCMFormat(const sp<MetaData> &) {
-
+void AVNuUtils::setSourcePCMFormat(const sp<MetaData> &audioMeta) {
+    audio_format_t pcmFormat = getKeyPCMFormat(audioMeta);
+    ALOGI("setSourcePCMFormat fmt=%x", pcmFormat);
+    audioMeta->dumpToLog();
+    if (pcmFormat == AUDIO_FORMAT_INVALID) {
+        int32_t bits = 16;
+        if (audioMeta->findInt32(kKeyBitsPerSample, &bits)) {
+            if (bits == 8)
+                pcmFormat = AUDIO_FORMAT_PCM_8_BIT;
+            if (bits == 24)
+                pcmFormat = AUDIO_FORMAT_PCM_32_BIT;
+            if (bits == 32)
+                pcmFormat = AUDIO_FORMAT_PCM_FLOAT;
+            setKeyPCMFormat(audioMeta, pcmFormat);
+        }
+    }
 }
 
 void AVNuUtils::setDecodedPCMFormat(const sp<AMessage> &) {
 
 }
 
-status_t AVNuUtils::convertToSinkFormatIfNeeded(const sp<ABuffer> &, sp<ABuffer> &,
-        audio_format_t /*sinkFormat*/, bool /*isOffload*/) {
-    return INVALID_OPERATION;
+status_t AVNuUtils::convertToSinkFormatIfNeeded(
+        const sp<ABuffer> &buffer, sp<ABuffer> &newBuffer,
+        audio_format_t sinkFormat, bool isOffload) {
+
+    audio_format_t srcFormat = AUDIO_FORMAT_INVALID;
+    if (!buffer->meta()->findInt32("pcm-format", (int32_t *)&srcFormat)) {
+        newBuffer = buffer;
+        return OK;
+    }
+
+    size_t bps = audio_bytes_per_sample(srcFormat);
+
+    if (bps <= 0) {
+        ALOGE("Invalid pcmformat %x given for conversion", srcFormat);
+        return INVALID_OPERATION;
+    }
+
+    size_t frames = buffer->size() / bps;
+
+    if (frames == 0) {
+        ALOGE("zero sized buffer, nothing to convert");
+        return BAD_VALUE;
+    }
+
+    ALOGV("convert %zu bytes (frames %d) of format %x",
+          buffer->size(), frames, srcFormat);
+
+    audio_format_t dstFormat;
+    if (isOffload) {
+        switch (sinkFormat) {
+            case AUDIO_FORMAT_PCM_16_BIT_OFFLOAD:
+                dstFormat = AUDIO_FORMAT_PCM_16_BIT;
+                break;
+            case AUDIO_FORMAT_PCM_24_BIT_OFFLOAD:
+                if (srcFormat != AUDIO_FORMAT_PCM_24_BIT_PACKED &&
+                    srcFormat != AUDIO_FORMAT_PCM_8_24_BIT) {
+                        ALOGE("Invalid src format for 24 bit conversion");
+                        return INVALID_OPERATION;
+                }
+                dstFormat = AUDIO_FORMAT_PCM_24_BIT_OFFLOAD;
+                break;
+            case AUDIO_FORMAT_DEFAULT:
+                ALOGI("OffloadInfo not yet initialized, retry");
+                return NO_INIT;
+            default:
+                ALOGE("Invalid offload format %x given for conversion",
+                      sinkFormat);
+                return INVALID_OPERATION;
+        }
+    } else {
+        if (sinkFormat == AUDIO_FORMAT_INVALID) {
+            ALOGD("PCM Info not yet initialized, drop buffer");
+            return INVALID_OPERATION;
+        }
+
+        dstFormat = sinkFormat;
+    }
+    if (srcFormat == dstFormat) {
+        ALOGV("same format");
+        newBuffer = buffer;
+        return OK;
+    }
+
+    size_t dstFrameSize = audio_bytes_per_sample(dstFormat);
+    size_t dstBytes = frames * dstFrameSize;
+
+    newBuffer = new ABuffer(dstBytes);
+
+    memcpy_by_audio_format(newBuffer->data(), dstFormat,
+                           buffer->data(), srcFormat, frames);
+
+    ALOGV("convert to format %x newBuffer->size() %zu",
+          dstFormat, newBuffer->size());
+
+    // copy over some meta info
+    int64_t timeUs = 0;
+    buffer->meta()->findInt64("timeUs", &timeUs);
+    newBuffer->meta()->setInt64("timeUs", timeUs);
+
+    int32_t eos = false;
+    buffer->meta()->findInt32("eos", &eos);
+    newBuffer->meta()->setInt32("eos", eos);
+
+    newBuffer->meta()->setInt32("pcm-format", (int32_t)dstFormat);
+    return OK;
 }
 
 void AVNuUtils::printFileName(int) {}
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index f3f2276..bf90b0a 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -39,52 +39,291 @@
 #include <media/stagefright/ACodec.h>
 #include <media/stagefright/MediaCodec.h>
 
+#ifdef QCOM_HARDWARE
+#include "QCMediaDefs.h"
+#include "QCMetaData.h"
+#endif
+
 #include "common/ExtensionsLoader.hpp"
 #include "stagefright/AVExtensions.h"
 
 namespace android {
 
+enum MetaKeyType{
+    INT32, INT64, STRING, DATA, CSD
+};
+
+struct MetaKeyEntry{
+    int MetaKey;
+    const char* MsgKey;
+    MetaKeyType KeyType;
+};
+
+static const MetaKeyEntry MetaKeyTable[] {
+#ifdef QCOM_HARDWARE
+   {kKeyAacCodecSpecificData , "aac-codec-specific-data", CSD},
+   {kKeyDivXVersion          , "divx-version"           , INT32},  // int32_t
+   {kKeyDivXDrm              , "divx-drm"               , DATA},  // void *
+   {kKeyWMAEncodeOpt         , "wma-encode-opt"         , INT32},  // int32_t
+   {kKeyWMABlockAlign        , "wma-block-align"        , INT32},  // int32_t
+   {kKeyWMAAdvEncOpt1        , "wma-adv-enc-opt1"       , INT32},  // int16_t
+   {kKeyWMAAdvEncOpt2        , "wma-adv-enc-opt2"       , INT32},  // int32_t
+   {kKeyWMAFormatTag         , "wma-format-tag"         , INT32},  // int32_t
+   {kKeyWMABitspersample     , "wma-bits-per-sample"    , INT32},  // int32_t
+   {kKeyWMAVirPktSize        , "wma-vir-pkt-size"       , INT32},  // int32_t
+   {kKeyWMAChannelMask       , "wma-channel-mask"       , INT32},  // int32_t
+   {kKeyFileFormat           , "file-format"            , STRING},  // cstring
+
+   {kkeyAacFormatAdif        , "aac-format-adif"        , INT32},  // bool (int32_t)
+   {kkeyAacFormatLtp         , "aac-format-ltp"         , INT32},
+
+   //DTS subtype
+   {kKeyDTSSubtype           , "dts-subtype"            , INT32},  //int32_t
+
+   //Extractor sets this
+   {kKeyUseArbitraryMode     , "use-arbitrary-mode"     , INT32},  //bool (int32_t)
+   {kKeySmoothStreaming      , "smooth-streaming"       , INT32},  //bool (int32_t)
+   {kKeyHFR                  , "hfr"                    , INT32},  // int32_t
+#endif
+
+
+   {kKeyBitRate              , "bitrate"                , INT32},
+   {kKeySampleRate           , "sample-rate"            , INT32},
+   {kKeyChannelCount         , "channel-count"          , INT32},
+   {kKeyRawCodecSpecificData , "raw-codec-specific-data", CSD},
+
+   {kKeyBitsPerSample        , "bits-per-sample"        , INT32},
+   {kKeyCodecId              , "codec-id"               , INT32},
+   {kKeySampleFormat         , "sample-format"          , INT32},
+   {kKeyBlockAlign           , "block-align"            , INT32},
+   {kKeyCodedSampleBits      , "coded-sample-bits"      , INT32},
+   {kKeyAACAOT               , "aac-profile"            , INT32},
+   {kKeyRVVersion            , "rv-version"             , INT32},
+   {kKeyWMAVersion           , "wma-version"            , INT32},  // int32_t
+   {kKeyWMVVersion           , "wmv-version"            , INT32},
+};
+
 status_t AVUtils::convertMetaDataToMessage(
-        const sp<MetaData> &, sp<AMessage> *) {
+        const sp<MetaData> &meta, sp<AMessage> *format) {
+    const char * str_val;
+    int32_t int32_val;
+    int64_t int64_val;
+    uint32_t data_type;
+    const void * data;
+    size_t size;
+    static const size_t numMetaKeys =
+                     sizeof(MetaKeyTable) / sizeof(MetaKeyTable[0]);
+    size_t i;
+    for (i = 0; i < numMetaKeys; ++i) {
+        if (MetaKeyTable[i].KeyType == INT32 &&
+            meta->findInt32(MetaKeyTable[i].MetaKey, &int32_val)) {
+            ALOGV("found metakey %s of type int32", MetaKeyTable[i].MsgKey);
+            format->get()->setInt32(MetaKeyTable[i].MsgKey, int32_val);
+        } else if (MetaKeyTable[i].KeyType == INT64 &&
+                 meta->findInt64(MetaKeyTable[i].MetaKey, &int64_val)) {
+            ALOGV("found metakey %s of type int64", MetaKeyTable[i].MsgKey);
+            format->get()->setInt64(MetaKeyTable[i].MsgKey, int64_val);
+        } else if (MetaKeyTable[i].KeyType == STRING &&
+                 meta->findCString(MetaKeyTable[i].MetaKey, &str_val)) {
+            ALOGV("found metakey %s of type string", MetaKeyTable[i].MsgKey);
+            format->get()->setString(MetaKeyTable[i].MsgKey, str_val);
+        } else if ( (MetaKeyTable[i].KeyType == DATA ||
+                   MetaKeyTable[i].KeyType == CSD) &&
+                   meta->findData(MetaKeyTable[i].MetaKey, &data_type, &data, &size)) {
+            ALOGV("found metakey %s of type data", MetaKeyTable[i].MsgKey);
+            if (MetaKeyTable[i].KeyType == CSD) {
+                const char *mime;
+                CHECK(meta->findCString(kKeyMIMEType, &mime));
+                if (strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) {
+                    sp<ABuffer> buffer = new ABuffer(size);
+                    memcpy(buffer->data(), data, size);
+                    buffer->meta()->setInt32("csd", true);
+                    buffer->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-0", buffer);
+                } else {
+                    const uint8_t *ptr = (const uint8_t *)data;
+                    CHECK(size >= 8);
+                    int seqLength = 0, picLength = 0;
+                    for (size_t i = 4; i < (size - 4); i++)
+                    {
+                        if ((*(ptr + i) == 0) && (*(ptr + i + 1) == 0) &&
+                           (*(ptr + i + 2) == 0) && (*(ptr + i + 3) == 1))
+                            seqLength = i;
+                    }
+                    sp<ABuffer> buffer = new ABuffer(seqLength);
+                    memcpy(buffer->data(), data, seqLength);
+                    buffer->meta()->setInt32("csd", true);
+                    buffer->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-0", buffer);
+                    picLength=size-seqLength;
+                    sp<ABuffer> buffer1 = new ABuffer(picLength);
+                    memcpy(buffer1->data(), (const uint8_t *)data + seqLength, picLength);
+                    buffer1->meta()->setInt32("csd", true);
+                    buffer1->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-1", buffer1);
+                }
+            } else {
+                sp<ABuffer> buffer = new ABuffer(size);
+                memcpy(buffer->data(), data, size);
+                format->get()->setBuffer(MetaKeyTable[i].MsgKey, buffer);
+            }
+        }
+    }
     return OK;
 }
 
+struct mime_conv_t {
+    const char* mime;
+    audio_format_t format;
+};
+
+static const struct mime_conv_t mimeLookup[] = {
+    { MEDIA_MIMETYPE_AUDIO_MPEG,        AUDIO_FORMAT_MP3 },
+    { MEDIA_MIMETYPE_AUDIO_RAW,         AUDIO_FORMAT_PCM_16_BIT },
+    { MEDIA_MIMETYPE_AUDIO_AMR_NB,      AUDIO_FORMAT_AMR_NB },
+    { MEDIA_MIMETYPE_AUDIO_AMR_WB,      AUDIO_FORMAT_AMR_WB },
+    { MEDIA_MIMETYPE_AUDIO_AAC,         AUDIO_FORMAT_AAC },
+    { MEDIA_MIMETYPE_AUDIO_VORBIS,      AUDIO_FORMAT_VORBIS },
+    { MEDIA_MIMETYPE_AUDIO_OPUS,        AUDIO_FORMAT_OPUS},
+#ifdef QCOM_HARDWARE
+    { MEDIA_MIMETYPE_AUDIO_AC3,         AUDIO_FORMAT_AC3 },
+    { MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS, AUDIO_FORMAT_AMR_WB_PLUS },
+    { MEDIA_MIMETYPE_AUDIO_DTS,         AUDIO_FORMAT_DTS },
+    { MEDIA_MIMETYPE_AUDIO_EAC3,        AUDIO_FORMAT_E_AC3 },
+    { MEDIA_MIMETYPE_AUDIO_EVRC,        AUDIO_FORMAT_EVRC },
+    { MEDIA_MIMETYPE_AUDIO_QCELP,       AUDIO_FORMAT_QCELP },
+    { MEDIA_MIMETYPE_AUDIO_WMA,         AUDIO_FORMAT_WMA },
+    { MEDIA_MIMETYPE_AUDIO_FLAC,        AUDIO_FORMAT_FLAC },
+    { MEDIA_MIMETYPE_CONTAINER_QTIFLAC, AUDIO_FORMAT_FLAC },
+#ifdef DOLBY_UDC
+    { MEDIA_MIMETYPE_AUDIO_EAC3_JOC,    AUDIO_FORMAT_E_AC3_JOC },
+#endif
+#endif
+    { 0, AUDIO_FORMAT_INVALID }
+};
+
 status_t AVUtils::mapMimeToAudioFormat(
-        audio_format_t&, const char* ) {
-        return OK;
+        audio_format_t& format, const char* mime) {
+    const struct mime_conv_t* p = &mimeLookup[0];
+    while (p->mime != NULL) {
+        if (0 == strcasecmp(mime, p->mime)) {
+            format = p->format;
+            return OK;
+        }
+        ++p;
+    }
+
+    return BAD_VALUE;
 }
 
 status_t AVUtils::sendMetaDataToHal(
-        const sp<MetaData>&, AudioParameter *){
-        return OK;
+        const sp<MetaData>& meta, AudioParameter *param){
+#ifdef FLAC_OFFLOAD_ENABLED
+    int32_t minBlkSize, maxBlkSize, minFrmSize, maxFrmSize; //FLAC params
+    if (meta->findInt32(kKeyMinBlkSize, &minBlkSize)) {
+        param.addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MIN_BLK_SIZE), minBlkSize);
+    }
+    if (meta->findInt32(kKeyMaxBlkSize, &maxBlkSize)) {
+        param.addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MAX_BLK_SIZE), maxBlkSize);
+    }
+    if (meta->findInt32(kKeyMinFrmSize, &minFrmSize)) {
+        param.addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MIN_FRAME_SIZE), minFrmSize);
+    }
+    if (meta->findInt32(kKeyMaxFrmSize, &maxFrmSize)) {
+        param.addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MAX_FRAME_SIZE), maxFrmSize);
+    }
+#else
+    (void)meta;
+    (void)param;
+#endif
+    return OK;
+}
+
+bool AVUtils::is24bitPCMOffloadEnabled() {
+    char propPCMOfload[PROPERTY_VALUE_MAX] = {0};
+    property_get("audio.offload.pcm.24bit.enable", propPCMOfload, "0");
+    if (!strncmp(propPCMOfload, "true", 4) || atoi(propPCMOfload))
+        return true;
+    else
+        return false;
+}
+
+bool AVUtils::is16bitPCMOffloadEnabled() {
+    char propPCMOfload[PROPERTY_VALUE_MAX] = {0};
+    property_get("audio.offload.pcm.16bit.enable", propPCMOfload, "0");
+    if (!strncmp(propPCMOfload, "true", 4) || atoi(propPCMOfload))
+        return true;
+    else
+        return false;
 }
 
-bool AVUtils::is24bitPCMOffloadEnabled() {return false;}
-bool AVUtils::is16bitPCMOffloadEnabled() {return false;}
 
-int AVUtils::getAudioSampleBits(const sp<MetaData> &) {
-    return 16;
+int AVUtils::getAudioSampleBits(const sp<MetaData> &meta) {
+    int32_t bits = 16;
+    audio_format_t audioFormat = AUDIO_FORMAT_INVALID;
+    if (meta->findInt32('pfmt', (int32_t *)&audioFormat)) {
+        bits = audio_bytes_per_sample(audioFormat) * 8;
+    } else if (meta->findInt32(kKeyBitsPerSample, &bits)) {
+        return bits;
+    }
+    return bits;
 }
 
 int AVUtils::getAudioSampleBits(const sp<AMessage> &format) {
     int32_t bits = 16;
-    format->findInt32("bits-per-sample", &bits);
+    audio_format_t audioFormat = AUDIO_FORMAT_INVALID;
+    if (format->findInt32("pcm-format", (int32_t *)&audioFormat)) {
+        bits = audio_bytes_per_sample(audioFormat) * 8;
+    } else if (format->findInt32("bits-per-sample", &bits)) {
+        return bits;
+    }
     return bits;
 }
 
-void AVUtils::setPcmSampleBits(const sp<AMessage> &, int32_t /*bitWidth*/) {
+void AVUtils::setPcmSampleBits(const sp<AMessage> &format, int32_t bitWidth) {
+    format->setInt32("bits-per-sample", bitWidth);
 }
 
-void AVUtils::setPcmSampleBits(const sp<MetaData> &, int32_t /*bitWidth*/) {
+void AVUtils::setPcmSampleBits(const sp<MetaData> &meta, int32_t bitWidth) {
+    meta->setInt32(kKeyBitsPerSample, bitWidth);
 }
 
 audio_format_t AVUtils::updateAudioFormat(audio_format_t audioFormat,
-        const sp<MetaData> &){
+        const sp<MetaData> &meta){
+    int32_t bits = getAudioSampleBits(meta);
+
+    ALOGV("updateAudioFormat %x %d", audioFormat, bits);
+    meta->dumpToLog();
+
+    // Override audio format for PCM offload
+    if (audio_is_linear_pcm(audioFormat)) {
+        if (bits > 16 && is24bitPCMOffloadEnabled()) {
+            audioFormat = AUDIO_FORMAT_PCM_24_BIT_OFFLOAD;
+            meta->setInt32(kKeyBitsPerSample, 24);
+        } else if (bits == 16 && is16bitPCMOffloadEnabled()) {
+            audioFormat = AUDIO_FORMAT_PCM_16_BIT_OFFLOAD;
+        }
+    }
+
     return audioFormat;
 }
 
 audio_format_t AVUtils::updateAudioFormat(audio_format_t audioFormat,
-        const sp<AMessage> &){
+        const sp<AMessage> &format){
+    int32_t bits = getAudioSampleBits(format);
+
+    ALOGV("updateAudioFormat %x %d %s", audioFormat, bits, format->debugString().c_str());
+
+    // Override audio format for PCM offload
+    if (audio_is_linear_pcm(audioFormat)) {
+        if (bits > 16 && is24bitPCMOffloadEnabled()) {
+            audioFormat = AUDIO_FORMAT_PCM_24_BIT_OFFLOAD;
+            format->setInt32("bits-per-sample", 24);
+        } else if (bits == 16 && is16bitPCMOffloadEnabled()) {
+            audioFormat = AUDIO_FORMAT_PCM_16_BIT_OFFLOAD;
+        }
+    }
+
     return audioFormat;
 }
 
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index 7afc52a..8cf623a 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -40,6 +40,7 @@ LOCAL_SHARED_LIBRARIES :=       \
     libstagefright_wfd          \
     libutils                    \
     libvorbisidec               \
+	libaudioutils               \
 
 LOCAL_STATIC_LIBRARIES :=       \
     libstagefright_nuplayer     \
@@ -58,7 +59,7 @@ LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/frameworks/av/media/libavextensions                      \
     $(TOP)/frameworks/av/media/libstagefright/mpeg2ts               \
 
-LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
+LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall #-DLOG_NDEBUG=0
 LOCAL_CLANG := true
 
 LOCAL_MODULE:= libmediaplayerservice
diff --git a/media/libmediaplayerservice/nuplayer/Android.mk b/media/libmediaplayerservice/nuplayer/Android.mk
index f4c000d..ff2a202 100644
--- a/media/libmediaplayerservice/nuplayer/Android.mk
+++ b/media/libmediaplayerservice/nuplayer/Android.mk
@@ -27,7 +27,7 @@ LOCAL_C_INCLUDES := \
 	$(TOP)/frameworks/av/media/libavextensions                    \
 	$(TOP)/frameworks/av/include/media                            \
 
-LOCAL_CFLAGS += -Werror -Wall
+LOCAL_CFLAGS += -Werror -Wall #-DLOG_NDEBUG=0
 
 # enable experiments only in userdebug and eng builds
 ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 347c5fb..e642cf5 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -211,6 +211,7 @@ NuPlayer::NuPlayer(pid_t pid)
       mPID(pid),
       mSourceFlags(0),
       mOffloadAudio(false),
+      mOffloadDecodedPCM(false),
       mAudioDecoderGeneration(0),
       mVideoDecoderGeneration(0),
       mRendererGeneration(0),
@@ -1196,10 +1197,12 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 
             mResetting = true;
 
-            mDeferredActions.push_back(
-                    new FlushDecoderAction(
-                        FLUSH_CMD_SHUTDOWN /* audio */,
-                        FLUSH_CMD_SHUTDOWN /* video */));
+            if (mAudioDecoder != NULL && mFlushingAudio == NONE) {
+                mDeferredActions.push_back(
+                        new FlushDecoderAction(
+                            FLUSH_CMD_SHUTDOWN /* audio */,
+                            FLUSH_CMD_SHUTDOWN /* video */));
+            }
 
             mDeferredActions.push_back(
                     new SimpleAction(&NuPlayer::closeAudioSink));
@@ -1291,9 +1294,16 @@ void NuPlayer::onResume() {
     } else {
         ALOGW("resume called when source is gone or not set");
     }
+    if (mOffloadAudio && !mOffloadDecodedPCM) {
+          // Resuming after a pause timed out event, check if can continue with offload
+          sp<AMessage> videoFormat = mSource->getFormat(false /* audio */);
+          sp<AMessage> format = mSource->getFormat(true /*audio*/);
+          const bool hasVideo = (videoFormat != NULL);
+          tryOpenAudioSinkForOffload(format, hasVideo);
+    } 
     // |mAudioDecoder| may have been released due to the pause timeout, so re-create it if
     // needed.
-    if (audioDecoderStillNeeded() && mAudioDecoder == NULL) {
+    if (audioDecoderStillNeeded() && mAudioDecoder == NULL && !mOffloadDecodedPCM) {
         instantiateDecoder(true /* audio */, &mAudioDecoder);
     }
     if (mRenderer != NULL) {
@@ -1345,6 +1355,7 @@ void NuPlayer::onStart(int64_t startPositionUs) {
     }
 
     mOffloadAudio = false;
+    mOffloadDecodedPCM = false;
     mAudioEOS = false;
     mVideoEOS = false;
     mStarted = true;
@@ -1355,8 +1366,10 @@ void NuPlayer::onStart(int64_t startPositionUs) {
         flags |= Renderer::FLAG_REAL_TIME;
     }
 
+    ALOGV("onStart");
     sp<MetaData> audioMeta = mSource->getFormatMeta(true /* audio */);
     AVNuUtils::get()->setSourcePCMFormat(audioMeta);
+    audioMeta->dumpToLog();
     audio_stream_type_t streamType = AUDIO_STREAM_MUSIC;
     if (mAudioSink != NULL) {
         streamType = mAudioSink->getAudioStreamType();
@@ -1753,6 +1766,18 @@ void NuPlayer::flushDecoder(bool audio, bool needShutdown) {
         return;
     }
 
+    FlushStatus *state = audio ? &mFlushingAudio : &mFlushingVideo;
+
+    bool inShutdown = *state != NONE &&
+                      *state != FLUSHING_DECODER &&
+                      *state != FLUSHED;
+
+    // Reject flush if the decoder state is not one of the above
+    if (inShutdown) {
+        ALOGI("flush %s called while in shutdown", audio ? "audio" : "video");
+        return;
+    }
+
     // Make sure we don't continue to scan sources until we finish flushing.
     ++mScanSourcesGeneration;
     if (mScanSourcesPending) {
@@ -2449,4 +2474,32 @@ void NuPlayer::Source::onMessageReceived(const sp<AMessage> & /* msg */) {
     TRESPASS();
 }
 
+bool NuPlayer::ifDecodedPCMOffload() {
+    return mOffloadDecodedPCM;
+}
+
+void NuPlayer::setDecodedPcmOffload(bool decodePcmOffload) {
+    mOffloadDecodedPCM = decodePcmOffload;
+}
+
+bool NuPlayer::canOffloadDecodedPCMStream(const sp<MetaData> audioMeta,
+            bool hasVideo, bool isStreaming, audio_stream_type_t streamType) {
+    const char *mime = NULL;
+
+     //For offloading decoded content
+    if (!mOffloadAudio && (audioMeta != NULL)) {
+        audioMeta->findCString(kKeyMIMEType, &mime);
+        sp<MetaData> audioPCMMeta =
+                AVNuUtils::get()->createPCMMetaFromSource(audioMeta);
+
+        ALOGI("canOffloadDecodedPCMStream");
+        audioMeta->dumpToLog();
+        mOffloadDecodedPCM =
+                ((mime && !AVNuUtils::get()->pcmOffloadException(audioMeta)) &&
+                canOffloadStream(audioPCMMeta, hasVideo, isStreaming, streamType));
+        ALOGI("PCM offload decided: %d", mOffloadDecodedPCM);
+    }
+    return mOffloadDecodedPCM;
+}
+
 }  // namespace android
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index 14090d0..a20cf12 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -105,11 +105,12 @@ protected:
     virtual ~NuPlayer();
 
     virtual void onMessageReceived(const sp<AMessage> &msg);
-    virtual bool ifDecodedPCMOffload() {return false;}
-    virtual void setDecodedPcmOffload(bool /*decodePcmOffload*/) {}
-    virtual bool canOffloadDecodedPCMStream(const sp<MetaData> /*meta*/,
-            bool /*hasVideo*/, bool /*isStreaming*/, audio_stream_type_t /*streamType*/) {return false;}
+    virtual bool ifDecodedPCMOffload();
+    virtual void setDecodedPcmOffload(bool decodePcmOffload);
+    virtual bool canOffloadDecodedPCMStream(const sp<MetaData> meta,
+            bool hasVideo, bool isStreaming, audio_stream_type_t streamType);
     static bool IsHTTPLiveURL(const char *url);
+
 public:
     struct NuPlayerStreamListener;
     struct Source;
@@ -170,6 +171,7 @@ protected:
     sp<MediaPlayerBase::AudioSink> mAudioSink;
     sp<DecoderBase> mVideoDecoder;
     bool mOffloadAudio;
+    bool mOffloadDecodedPCM;
     sp<DecoderBase> mAudioDecoder;
     sp<CCDecoder> mCCDecoder;
     sp<Renderer> mRenderer;
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
index daee385..b8b0505 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
@@ -52,7 +52,8 @@ NuPlayer::DecoderPassThrough::DecoderPassThrough(
       mPendingAudioErr(OK),
       mPendingBuffersToDrain(0),
       mCachedBytes(0),
-      mComponentName("pass through decoder") {
+      mComponentName("pass through decoder"),
+      mPCMFormat(AUDIO_FORMAT_INVALID) {
     ALOGW_IF(renderer == NULL, "expect a non-NULL renderer");
 }
 
@@ -74,6 +75,15 @@ void NuPlayer::DecoderPassThrough::onConfigure(const sp<AMessage> &format) {
     // The audio sink is already opened before the PassThrough decoder is created.
     // Opening again might be relevant if decoder is instantiated after shutdown and
     // format is different.
+    sp<MetaData> audioMeta = mSource->getFormatMeta(true /* audio */);
+    if (AVNuUtils::get()->isRAWFormat(audioMeta)) {
+        mPCMFormat = AVNuUtils::get()->getKeyPCMFormat(audioMeta);
+        if (mPCMFormat != AUDIO_FORMAT_INVALID) {
+            AVNuUtils::get()->setPCMFormat(format, mPCMFormat);
+            AVNuUtils::get()->updateAudioBitWidth(mPCMFormat, format);
+        }
+    }
+
     status_t err = mRenderer->openAudioSink(
             format, true /* offloadOnly */, hasVideo,
             AUDIO_OUTPUT_FLAG_NONE /* flags */, NULL /* isOffloaded */, mSource->isStreaming());
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
index 52fff73..13a7c61 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
@@ -68,6 +68,7 @@ private:
     size_t  mPendingBuffersToDrain;
     size_t  mCachedBytes;
     AString mComponentName;
+    audio_format_t mPCMFormat;
 
     bool isStaleReply(const sp<AMessage> &msg);
     bool isDoneFetching() const;
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index c1e5dee..b7a2573 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1262,6 +1262,30 @@ void NuPlayer::Renderer::onQueueBuffer(const sp<AMessage> &msg) {
 
     if (audio) {
         Mutex::Autolock autoLock(mLock);
+#if 1
+        sp<ABuffer> newBuffer;
+        status_t err = AVNuUtils::get()->convertToSinkFormatIfNeeded(
+                buffer, newBuffer,
+                (offloadingAudio() ? mCurrentOffloadInfo.format : mCurrentPcmInfo.mFormat),
+                offloadingAudio());
+        switch (err) {
+        case NO_INIT:
+            // passthru decoder pushes some buffers before the audio sink
+            // is opened. Since the offload format is known only when the sink
+            // is opened, pcm conversions cannot take place. So, retry.
+            ALOGI("init pending, retrying in 10ms, this shouldn't happen");
+            msg->post(10000LL);
+            return;
+        case OK:
+            break;
+        default:
+            ALOGW("error 0x%x in converting to sink format, drop buffer", err);
+            notifyConsumed->post();
+            return;
+        }
+        CHECK(newBuffer != NULL);
+        entry.mBuffer = newBuffer;
+#endif
         mAudioQueue.push_back(entry);
         postDrainAudioQueue_l();
     } else {
@@ -1745,108 +1769,106 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
     AString mime;
     CHECK(format->findString("mime", &mime));
 
-    if (offloadingAudio()) {
-        audio_format_t audioFormat = AUDIO_FORMAT_PCM_16_BIT;
-        status_t err = mapMimeToAudioFormat(audioFormat, mime.c_str());
+    audio_format_t audioFormat = AUDIO_FORMAT_PCM_16_BIT;
+    status_t err = mapMimeToAudioFormat(audioFormat, mime.c_str());
 
-        if (err != OK) {
-            ALOGE("Couldn't map mime \"%s\" to a valid "
-                    "audio_format", mime.c_str());
-            onDisableOffloadAudio();
-        } else {
-            audioFormat = AVUtils::get()->updateAudioFormat(audioFormat, format);
-
-            bitWidth = AVUtils::get()->getAudioSampleBits(format);
-            int avgBitRate = -1;
-            format->findInt32("bitrate", &avgBitRate);
-
-            int32_t aacProfile = -1;
-            if (audioFormat == AUDIO_FORMAT_AAC
-                    && format->findInt32("aac-profile", &aacProfile)) {
-                // Redefine AAC format as per aac profile
-                int32_t isADTSSupported;
-                isADTSSupported = AVUtils::get()->mapAACProfileToAudioFormat(format,
-                                          audioFormat,
-                                          aacProfile);
-                if (!isADTSSupported) {
-                    mapAACProfileToAudioFormat(audioFormat,
-                            aacProfile);
-                } else {
-                    ALOGV("Format is AAC ADTS\n");
-                }
+    if (err != OK) {
+        ALOGE("Couldn't map mime \"%s\" to a valid "
+                "audio_format", mime.c_str());
+        onDisableOffloadAudio();
+    } else {
+        audioFormat = AVUtils::get()->updateAudioFormat(audioFormat, format);
+
+        bitWidth = AVUtils::get()->getAudioSampleBits(format);
+        int avgBitRate = -1;
+        format->findInt32("bitrate", &avgBitRate);
+
+        int32_t aacProfile = -1;
+        if (audioFormat == AUDIO_FORMAT_AAC
+                && format->findInt32("aac-profile", &aacProfile)) {
+            // Redefine AAC format as per aac profile
+            int32_t isADTSSupported;
+            isADTSSupported = AVUtils::get()->mapAACProfileToAudioFormat(format,
+                                      audioFormat,
+                                      aacProfile);
+            if (!isADTSSupported) {
+                mapAACProfileToAudioFormat(audioFormat,
+                        aacProfile);
+            } else {
+                ALOGV("Format is AAC ADTS\n");
             }
+        }
 
-            int32_t offloadBufferSize =
-                                    AVUtils::get()->getAudioMaxInputBufferSize(
-                                                   audioFormat,
-                                                   format);
-            audio_offload_info_t offloadInfo = AUDIO_INFO_INITIALIZER;
-
-            offloadInfo.duration_us = -1;
-            format->findInt64(
-                    "durationUs", &offloadInfo.duration_us);
-            offloadInfo.sample_rate = sampleRate;
-            offloadInfo.channel_mask = channelMask;
-            offloadInfo.format = audioFormat;
-            offloadInfo.stream_type = AUDIO_STREAM_MUSIC;
-            offloadInfo.bit_rate = avgBitRate;
-            offloadInfo.has_video = hasVideo;
-            offloadInfo.is_streaming = isStreaming;
-            offloadInfo.bit_width = bitWidth;
-            offloadInfo.offload_buffer_size = offloadBufferSize;
-
-            if (memcmp(&mCurrentOffloadInfo, &offloadInfo, sizeof(offloadInfo)) == 0) {
-                ALOGV("openAudioSink: no change in offload mode");
-                // no change from previous configuration, everything ok.
-                return OK;
-            }
-            mCurrentPcmInfo = AUDIO_PCMINFO_INITIALIZER;
+        int32_t offloadBufferSize =
+                                AVUtils::get()->getAudioMaxInputBufferSize(
+                                               audioFormat,
+                                               format);
+        audio_offload_info_t offloadInfo = AUDIO_INFO_INITIALIZER;
+
+        offloadInfo.duration_us = -1;
+        format->findInt64(
+                "durationUs", &offloadInfo.duration_us);
+        offloadInfo.sample_rate = sampleRate;
+        offloadInfo.channel_mask = channelMask;
+        offloadInfo.format = audioFormat;
+        offloadInfo.stream_type = AUDIO_STREAM_MUSIC;
+        offloadInfo.bit_rate = avgBitRate;
+        offloadInfo.has_video = hasVideo;
+        offloadInfo.is_streaming = isStreaming;
+        offloadInfo.bit_width = bitWidth;
+        offloadInfo.offload_buffer_size = offloadBufferSize;
+
+        if (memcmp(&mCurrentOffloadInfo, &offloadInfo, sizeof(offloadInfo)) == 0) {
+            ALOGV("openAudioSink: no change in offload mode");
+            // no change from previous configuration, everything ok.
+            return OK;
+        }
+        mCurrentPcmInfo = AUDIO_PCMINFO_INITIALIZER;
 
-            ALOGV("openAudioSink: try to open AudioSink in offload mode");
-            uint32_t offloadFlags = flags;
-            offloadFlags |= AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD;
-            offloadFlags &= ~AUDIO_OUTPUT_FLAG_DEEP_BUFFER;
-            audioSinkChanged = true;
-            mAudioSink->close();
+        ALOGV("openAudioSink: try to open AudioSink in offload mode");
+        uint32_t offloadFlags = flags;
+        offloadFlags |= AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD;
+        offloadFlags &= ~AUDIO_OUTPUT_FLAG_DEEP_BUFFER;
+        audioSinkChanged = true;
+        mAudioSink->close();
 
-            err = mAudioSink->open(
-                    sampleRate,
-                    numChannels,
-                    (audio_channel_mask_t)channelMask,
-                    audioFormat,
-                    0 /* bufferCount - unused */,
-                    &NuPlayer::Renderer::AudioSinkCallback,
-                    this,
-                    (audio_output_flags_t)offloadFlags,
-                    &offloadInfo);
+        err = mAudioSink->open(
+                sampleRate,
+                numChannels,
+                (audio_channel_mask_t)channelMask,
+                audioFormat,
+                0 /* bufferCount - unused */,
+                &NuPlayer::Renderer::AudioSinkCallback,
+                this,
+                (audio_output_flags_t)offloadFlags,
+                &offloadInfo);
 
-            if (err == OK) {
-                err = mAudioSink->setPlaybackRate(mPlaybackSettings);
-            }
+        if (err == OK) {
+            err = mAudioSink->setPlaybackRate(mPlaybackSettings);
+        }
 
-            if (err == OK) {
-                // If the playback is offloaded to h/w, we pass
-                // the HAL some metadata information.
-                // We don't want to do this for PCM because it
-                // will be going through the AudioFlinger mixer
-                // before reaching the hardware.
-                // TODO
-                mCurrentOffloadInfo = offloadInfo;
-                if (!mPaused) { // for preview mode, don't start if paused
-                    err = mAudioSink->start();
-                }
-                ALOGV_IF(err == OK, "openAudioSink: offload succeeded");
-            }
-            if (err != OK) {
-                // Clean up, fall back to non offload mode.
-                mAudioSink->close();
-                onDisableOffloadAudio();
-                mCurrentOffloadInfo = AUDIO_INFO_INITIALIZER;
-                ALOGV("openAudioSink: offload failed");
-            } else {
-                mUseAudioCallback = true;  // offload mode transfers data through callback
-                ++mAudioDrainGeneration;  // discard pending kWhatDrainAudioQueue message.
+        if (err == OK) {
+            // If the playback is offloaded to h/w, we pass
+            // the HAL some metadata information.
+            // We don't want to do this for PCM because it
+            // will be going through the AudioFlinger mixer
+            // before reaching the hardware.
+            // TODO
+            mCurrentOffloadInfo = offloadInfo;
+            if (!mPaused) { // for preview mode, don't start if paused
+                err = mAudioSink->start();
             }
+            ALOGV_IF(err == OK, "openAudioSink: offload succeeded");
+        }
+        if (err != OK) {
+            // Clean up, fall back to non offload mode.
+            mAudioSink->close();
+            onDisableOffloadAudio();
+            mCurrentOffloadInfo = AUDIO_INFO_INITIALIZER;
+            ALOGV("openAudioSink: offload failed");
+        } else {
+            mUseAudioCallback = true;  // offload mode transfers data through callback
+            ++mAudioDrainGeneration;  // discard pending kWhatDrainAudioQueue message.
         }
     }
     if (!offloadOnly && !offloadingAudio()) {
@@ -1857,7 +1879,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
         const PcmInfo info = {
                 (audio_channel_mask_t)channelMask,
                 (audio_output_flags_t)pcmFlags,
-                getPCMFormat(format),
+                AVNuUtils::get()->getPCMFormat(format),
                 numChannels,
                 sampleRate
         };
@@ -1892,7 +1914,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
                     sampleRate,
                     numChannels,
                     (audio_channel_mask_t)channelMask,
-                    getPCMFormat(format),
+                    AVNuUtils::get()->getPCMFormat(format),
                     0 /* bufferCount - unused */,
                     mUseAudioCallback ? &NuPlayer::Renderer::AudioSinkCallback : NULL,
                     mUseAudioCallback ? this : NULL,
-- 
2.7.4


From 977f11a8a3eb12f7da642ac973eb37a77ed2ecaf Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 12 Dec 2015 21:28:57 -0800
Subject: [PATCH 058/119] stagefright: Add support for FLAC offloading

 * New Qualcomm DSPs support FLAC decoding, but the offload code is
   stubbed out in M. Unstub it from what used to be open source.

Change-Id: I03c129c42ebc6909a3392e42a7f96791c8fabd28
---
 media/libavextensions/Android.mk                       |  6 ++++++
 media/libavextensions/mediaplayerservice/AVNuUtils.cpp |  3 +++
 media/libavextensions/stagefright/AVExtensions.h       |  2 +-
 media/libavextensions/stagefright/AVUtils.cpp          | 17 +++++++++++++----
 media/libstagefright/Android.mk                        |  6 +++++-
 media/libstagefright/FLACExtractor.cpp                 | 17 ++++++++++++++++-
 6 files changed, 44 insertions(+), 7 deletions(-)

diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
index c597697..22cf8d9 100644
--- a/media/libavextensions/Android.mk
+++ b/media/libavextensions/Android.mk
@@ -18,9 +18,15 @@ LOCAL_C_INCLUDES:= \
 
 LOCAL_CFLAGS += -Wno-multichar -Werror
 
+ifeq ($(call is-vendor-board-platform,QCOM),true)
+LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/mm-audio
 ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
        LOCAL_CFLAGS += -DENABLE_AV_ENHANCEMENTS
 endif
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_FLAC_OFFLOAD)),true)
+       LOCAL_CFLAGS += -DFLAC_OFFLOAD_ENABLED
+endif
+endif
 
 LOCAL_MODULE:= libavextensions
 LOCAL_CFLAGS += -DLOG_NDEBUG=0
diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index b795aac..d7b951f 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -228,6 +228,9 @@ void AVNuUtils::setPCMFormat(const sp<AMessage> &format, audio_format_t audioFor
 }
 
 void AVNuUtils::setSourcePCMFormat(const sp<MetaData> &audioMeta) {
+    if (!isRAWFormat(audioMeta))
+        return;
+
     audio_format_t pcmFormat = getKeyPCMFormat(audioMeta);
     ALOGI("setSourcePCMFormat fmt=%x", pcmFormat);
     audioMeta->dumpToLog();
diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
index 3ec3808..f216341 100644
--- a/media/libavextensions/stagefright/AVExtensions.h
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -35,11 +35,11 @@
 #include <camera/ICamera.h>
 #include <media/mediarecorder.h>
 #include <media/IOMX.h>
+#include <media/AudioParameter.h>
 #include "ESQueue.h"
 
 namespace android {
 
-class AudioParameter;
 class MetaData;
 class MediaExtractor;
 class MPEG4Writer;
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index bf90b0a..bc162bb 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -42,6 +42,9 @@
 #ifdef QCOM_HARDWARE
 #include "QCMediaDefs.h"
 #include "QCMetaData.h"
+#ifdef FLAC_OFFLOAD_ENABLED
+#include "audio_defs.h"
+#endif
 #endif
 
 #include "common/ExtensionsLoader.hpp"
@@ -84,6 +87,12 @@ static const MetaKeyEntry MetaKeyTable[] {
    {kKeyUseArbitraryMode     , "use-arbitrary-mode"     , INT32},  //bool (int32_t)
    {kKeySmoothStreaming      , "smooth-streaming"       , INT32},  //bool (int32_t)
    {kKeyHFR                  , "hfr"                    , INT32},  // int32_t
+#ifdef FLAC_OFFLOAD_ENABLED
+   {kKeyMinBlkSize           , "min-block-size"         , INT32},
+   {kKeyMaxBlkSize           , "max-block-size"         , INT32},
+   {kKeyMinFrmSize           , "min-frame-size"         , INT32},
+   {kKeyMaxFrmSize           , "max-frame-size"         , INT32},
+#endif
 #endif
 
 
@@ -221,16 +230,16 @@ status_t AVUtils::sendMetaDataToHal(
 #ifdef FLAC_OFFLOAD_ENABLED
     int32_t minBlkSize, maxBlkSize, minFrmSize, maxFrmSize; //FLAC params
     if (meta->findInt32(kKeyMinBlkSize, &minBlkSize)) {
-        param.addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MIN_BLK_SIZE), minBlkSize);
+        param->addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MIN_BLK_SIZE), minBlkSize);
     }
     if (meta->findInt32(kKeyMaxBlkSize, &maxBlkSize)) {
-        param.addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MAX_BLK_SIZE), maxBlkSize);
+        param->addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MAX_BLK_SIZE), maxBlkSize);
     }
     if (meta->findInt32(kKeyMinFrmSize, &minFrmSize)) {
-        param.addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MIN_FRAME_SIZE), minFrmSize);
+        param->addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MIN_FRAME_SIZE), minFrmSize);
     }
     if (meta->findInt32(kKeyMaxFrmSize, &maxFrmSize)) {
-        param.addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MAX_FRAME_SIZE), maxFrmSize);
+        param->addInt(String8(AUDIO_OFFLOAD_CODEC_FLAC_MAX_FRAME_SIZE), maxFrmSize);
     }
 #else
     (void)meta;
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 74f93bc..029d42d 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -153,7 +153,7 @@ LOCAL_SHARED_LIBRARIES += \
         libdl \
         libRScpp \
 
-LOCAL_CFLAGS += -Wno-multichar -Werror -Wno-error=deprecated-declarations -Wall
+LOCAL_CFLAGS += -Werror -Wno-multichar -Wno-error=deprecated-declarations
 
 ifeq ($(TARGET_USES_QCOM_BSP), true)
     LOCAL_C_INCLUDES += $(call project-path-for,qcom-display)/libgralloc
@@ -172,9 +172,13 @@ LOCAL_CFLAGS += -DBOARD_CANT_REALLOCATE_OMX_BUFFERS
 endif
 
 ifeq ($(call is-vendor-board-platform,QCOM),true)
+LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/mm-audio
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_EXTN_FLAC_DECODER)),true)
     LOCAL_CFLAGS += -DQTI_FLAC_DECODER
 endif
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_FLAC_OFFLOAD)),true)
+    LOCAL_CFLAGS += -DFLAC_OFFLOAD_ENABLED
+endif
 endif
 
 LOCAL_CLANG := true
diff --git a/media/libstagefright/FLACExtractor.cpp b/media/libstagefright/FLACExtractor.cpp
index 91f0e65..51a502d 100644
--- a/media/libstagefright/FLACExtractor.cpp
+++ b/media/libstagefright/FLACExtractor.cpp
@@ -32,7 +32,7 @@
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MediaBuffer.h>
 
-#ifdef ENABLE_AV_ENHANCEMENTS
+#ifdef FLAC_OFFLOAD_ENABLED
 #include "QCMediaDefs.h"
 #include "QCMetaData.h"
 #endif
@@ -93,9 +93,18 @@ public:
     }
 
     // stream properties
+    unsigned getMinBlockSize() const {
+        return mStreamInfo.min_blocksize;
+    }
     unsigned getMaxBlockSize() const {
         return mStreamInfo.max_blocksize;
     }
+    unsigned getMinFrameSize() const {
+        return mStreamInfo.min_framesize;
+    }
+    unsigned getMaxFrameSize() const {
+        return mStreamInfo.max_framesize;
+    }
     unsigned getSampleRate() const {
         return mStreamInfo.sample_rate;
     }
@@ -544,6 +553,12 @@ status_t FLACParser::init()
             mTrackMetadata->setInt64(kKeyDuration,
                     (getTotalSamples() * 1000000LL) / getSampleRate());
             mTrackMetadata->setInt32(kKeyBitsPerSample, getBitsPerSample());
+#ifdef FLAC_OFFLOAD_ENABLED
+            mTrackMetadata->setInt32(kKeyMinBlkSize, getMinBlockSize());
+            mTrackMetadata->setInt32(kKeyMaxBlkSize, getMaxBlockSize());
+            mTrackMetadata->setInt32(kKeyMinFrmSize, getMinFrameSize());
+            mTrackMetadata->setInt32(kKeyMaxFrmSize, getMaxFrameSize());
+#endif
         }
     } else {
         ALOGE("missing STREAMINFO");
-- 
2.7.4


From a7e5278eb04521d4dec930e54dc7a567fc3eaacd Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sun, 13 Dec 2015 12:57:26 -0800
Subject: [PATCH 059/119] stagefright: Finish support for HEVC muxing

 * Forward-port CAF L-MR1 code to fill in stubs.

Change-Id: I6c07e803ad4fe3ef5286f61667b5ca11380db984
---
 include/media/stagefright/Utils.h                  |   3 +
 media/libavextensions/stagefright/AVExtensions.h   |  23 +
 media/libavextensions/stagefright/AVUtils.cpp      | 595 ++++++++++++++++++++-
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  17 +-
 media/libstagefright/Utils.cpp                     |   2 +-
 5 files changed, 616 insertions(+), 24 deletions(-)

diff --git a/include/media/stagefright/Utils.h b/include/media/stagefright/Utils.h
index 847ea36..e91c03a 100644
--- a/include/media/stagefright/Utils.h
+++ b/include/media/stagefright/Utils.h
@@ -18,6 +18,7 @@
 
 #define UTILS_H_
 
+#include <media/stagefright/foundation/ABuffer.h>
 #include <media/stagefright/foundation/AString.h>
 #include <stdint.h>
 #include <utils/Errors.h>
@@ -91,6 +92,8 @@ void updateVideoTrackInfoFromESDS_MPEG4Video(sp<MetaData> meta);
 bool checkDPFromVOLHeader(const uint8_t *ptr, size_t size);
 bool checkDPFromCodecSpecificData(const uint8_t *ptr, size_t size);
 
+status_t copyNALUToABuffer(sp<ABuffer> *buffer, const uint8_t *ptr, size_t length);
+
 }  // namespace android
 
 #endif  // UTILS_H_
diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
index f216341..0ea3a4c 100644
--- a/media/libavextensions/stagefright/AVExtensions.h
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -195,8 +195,31 @@ struct AVUtils {
         HEVCMuxer() {};
         virtual ~HEVCMuxer() {};
         friend struct AVUtils;
+
+    private:
+        struct HEVCParamSet {
+            HEVCParamSet(uint16_t length, const uint8_t *data)
+                   : mLength(length), mData(data) {}
+
+            uint16_t mLength;
+            const uint8_t *mData;
+        };
+
+        status_t extractNALRBSPData(const uint8_t *data, size_t size,
+                uint8_t **header, bool *alreadyFilled);
+
+        status_t parserProfileTierLevel(const uint8_t *data, size_t size,
+                uint8_t **header, bool *alreadyFilled);
+
+        const uint8_t *parseHEVCParamSet(const uint8_t *data, size_t length,
+                List<HEVCParamSet> &paramSetList, size_t *paramSetLen);
+
+        size_t parseHEVCCodecSpecificData(const uint8_t *data, size_t size,
+                List<HEVCParamSet> &vidParamSet, List<HEVCParamSet> &seqParamSet,
+                List<HEVCParamSet> &picParamSet );
     };
 
+
     virtual inline HEVCMuxer& HEVCMuxerUtils() {
          return mHEVCMuxer;
     }
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index bc162bb..b153573 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -38,6 +38,8 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/ACodec.h>
 #include <media/stagefright/MediaCodec.h>
+#include <media/stagefright/MPEG4Writer.h>
+#include <media/stagefright/Utils.h>
 
 #ifdef QCOM_HARDWARE
 #include "QCMediaDefs.h"
@@ -52,6 +54,10 @@
 
 namespace android {
 
+static const uint8_t kHEVCNalUnitTypeVidParamSet = 0x20;
+static const uint8_t kHEVCNalUnitTypeSeqParamSet = 0x21;
+static const uint8_t kHEVCNalUnitTypePicParamSet = 0x22;
+
 enum MetaKeyType{
     INT32, INT64, STRING, DATA, CSD
 };
@@ -373,38 +379,591 @@ bool AVUtils::isEnhancedExtension(const char *) {
     return false;
 }
 
-bool AVUtils::HEVCMuxer::reassembleHEVCCSD(const AString &/*mime*/, sp<ABuffer> /*csd0*/, sp<MetaData> &/*meta*/) {
+bool AVUtils::HEVCMuxer::reassembleHEVCCSD(const AString &mime, sp<ABuffer> csd0, sp<MetaData> &meta) {
+    if (!isVideoHEVC(mime.c_str())) {
+        return false;
+    }
+    uint32_t type;
+    const void *data;
+    size_t size;
+    if (meta->findData(kKeyHVCC, &type, &data, &size)) {
+        const uint8_t *ptr = (const uint8_t *)data;
+
+        CHECK(size >= 7);
+        uint8_t profile = ptr[1] & 31;
+        uint8_t level = ptr[12];
+        ptr += 22;
+        size -= 22;
+
+
+        size_t numofArrays = (char)ptr[0];
+        ptr += 1;
+        size -= 1;
+        size_t j = 0, i = 0;
+
+        csd0->setRange(0, 0);
+
+        for (i = 0; i < numofArrays; i++) {
+            ptr += 1;
+            size -= 1;
+
+            //Num of nals
+            size_t numofNals = U16_AT(ptr);
+
+            ptr += 2;
+            size -= 2;
+
+            for (j = 0; j < numofNals; j++) {
+                CHECK(size >= 2);
+                size_t length = U16_AT(ptr);
+
+                ptr += 2;
+                size -= 2;
+
+                if (size < length) {
+                    return false;
+                }
+                status_t err = copyNALUToABuffer(&csd0, ptr, length);
+                if (err != OK) {
+                    return false;
+                }
+
+                ptr += length;
+                size -= length;
+            }
+        }
+        csd0->meta()->setInt32("csd", true);
+        csd0->meta()->setInt64("timeUs", 0);
+        return true;
+    }
     return false;
 }
 
-void AVUtils::HEVCMuxer::writeHEVCFtypBox(MPEG4Writer * /*writer*/) {
-    return;
+void AVUtils::HEVCMuxer::writeHEVCFtypBox(MPEG4Writer *writer) {
+    ALOGV("writeHEVCFtypBox called");
+    writer->writeFourcc("3gp5");
+    writer->writeInt32(0);
+    writer->writeFourcc("hvc1");
+    writer->writeFourcc("hev1");
+    writer->writeFourcc("3gp5");
 }
 
-status_t AVUtils::HEVCMuxer::makeHEVCCodecSpecificData(const uint8_t * /*data*/,
-        size_t /*size*/, void ** /*codecSpecificData*/,
-        size_t * /*codecSpecificDataSize*/) {
-    return UNKNOWN_ERROR;
+status_t AVUtils::HEVCMuxer::makeHEVCCodecSpecificData(
+                         const uint8_t *data, size_t size, void** codecSpecificData,
+                         size_t *codecSpecificDataSize) {
+    ALOGV("makeHEVCCodecSpecificData called");
+
+    if (*codecSpecificData != NULL) {
+        ALOGE("Already have codec specific data");
+        return ERROR_MALFORMED;
+    }
+
+    if (size < 4) {
+        ALOGE("Codec specific data length too short: %zu", size);
+        return ERROR_MALFORMED;
+    }
+
+    // Data is in the form of HVCCodecSpecificData
+    if (memcmp("\x00\x00\x00\x01", data, 4)) {
+        // 23 byte fixed header
+        if (size < 23) {
+            ALOGE("Codec specific data length too short: %zu", size);
+            return ERROR_MALFORMED;
+        }
+
+        *codecSpecificData = malloc(size);
+
+        if (*codecSpecificData != NULL) {
+            *codecSpecificDataSize = size;
+            memcpy(*codecSpecificData, data, size);
+            return OK;
+        }
+
+        return NO_MEMORY;
+    }
+
+    List<HEVCParamSet> vidParamSets;
+    List<HEVCParamSet> seqParamSets;
+    List<HEVCParamSet> picParamSets;
+
+    if ((*codecSpecificDataSize = parseHEVCCodecSpecificData(data, size,
+                                   vidParamSets, seqParamSets, picParamSets)) <= 0) {
+        ALOGE("cannot parser codec specific data, bailing out");
+        return ERROR_MALFORMED;
+    }
+
+    size_t numOfNALArray = 0;
+    bool doneWritingVPS = true, doneWritingSPS = true, doneWritingPPS = true;
+
+    if (!vidParamSets.empty()) {
+        doneWritingVPS = false;
+        ++numOfNALArray;
+    }
+
+    if (!seqParamSets.empty()) {
+       doneWritingSPS = false;
+       ++numOfNALArray;
+    }
+
+    if (!picParamSets.empty()) {
+       doneWritingPPS = false;
+       ++numOfNALArray;
+    }
+
+    //additional 23 bytes needed (22 bytes for hvc1 header + 1 byte for number of arrays)
+    *codecSpecificDataSize += 23;
+    //needed 3 bytes per NAL array
+    *codecSpecificDataSize += 3 * numOfNALArray;
+
+    int count = 0;
+    void *codecConfigData = malloc(*codecSpecificDataSize);
+    if (codecSpecificData == NULL) {
+        ALOGE("Failed to allocate memory, bailing out");
+        return NO_MEMORY;
+    }
+
+    uint8_t *header = (uint8_t *)codecConfigData;
+    // 8  - bit version
+    header[0]  = 1;
+    //Profile space 2 bit, tier flag 1 bit and profile IDC 5 bit
+    header[1]  = 0x00;
+    // 32 - bit compatibility flag
+    header[2]  = 0x00;
+    header[3]  = 0x00;
+    header[4]  = 0x00;
+    header[5]  = 0x00;
+    // 48 - bit general constraint indicator flag
+    header[6]  = header[7]  = header[8]  = 0x00;
+    header[9]  = header[10] = header[11] = 0x00;
+    // 8  - bit general IDC level
+    header[12] = 0x00;
+    // 4  - bit reserved '1111'
+    // 12 - bit spatial segmentation idc
+    header[13] = 0xf0;
+    header[14] = 0x00;
+    // 6  - bit reserved '111111'
+    // 2  - bit parallelism Type
+    header[15] = 0xfc;
+    // 6  - bit reserved '111111'
+    // 2  - bit chromaFormat
+    header[16] = 0xfc;
+    // 5  - bit reserved '11111'
+    // 3  - bit DepthLumaMinus8
+    header[17] = 0xf8;
+    // 5  - bit reserved '11111'
+    // 3  - bit DepthChromaMinus8
+    header[18] = 0xf8;
+    // 16 - bit average frame rate
+    header[19] = header[20] = 0x00;
+    // 2  - bit constant frame rate
+    // 3  - bit num temporal layers
+    // 1  - bit temoral nested
+    // 2  - bit lengthSizeMinusOne
+    header[21] = 0x07;
+
+    // 8-bit number of NAL types
+    header[22] = (uint8_t)numOfNALArray;
+
+    header += 23;
+    count  += 23;
+
+    bool ifProfileIDCAlreadyFilled = false;
+
+    if (!doneWritingVPS) {
+        doneWritingVPS = true;
+        ALOGV("Writing VPS");
+        //8-bit, last 6 bit for NAL type
+        header[0] = 0x20; // NAL type is VPS
+        //16-bit, number of nal Units
+        uint16_t vidParamSetLength = vidParamSets.size();
+        header[1] = vidParamSetLength >> 8;
+        header[2] = vidParamSetLength & 0xff;
+
+        header += 3;
+        count  += 3;
+
+        for (List<HEVCParamSet>::iterator it = vidParamSets.begin();
+            it != vidParamSets.end(); ++it) {
+            // 16-bit video parameter set length
+            uint16_t vidParamSetLength = it->mLength;
+            header[0] = vidParamSetLength >> 8;
+            header[1] = vidParamSetLength & 0xff;
+
+            extractNALRBSPData(it->mData, it->mLength,
+                               (uint8_t **)&codecConfigData,
+                               &ifProfileIDCAlreadyFilled);
+
+            // VPS NAL unit (video parameter length bytes)
+            memcpy(&header[2], it->mData, vidParamSetLength);
+            header += (2 + vidParamSetLength);
+            count  += (2 + vidParamSetLength);
+        }
+    }
+
+    if (!doneWritingSPS) {
+        doneWritingSPS = true;
+        ALOGV("Writting SPS");
+        //8-bit, last 6 bit for NAL type
+        header[0] = 0x21; // NAL type is SPS
+        //16-bit, number of nal Units
+        uint16_t seqParamSetLength = seqParamSets.size();
+        header[1] = seqParamSetLength >> 8;
+        header[2] = seqParamSetLength & 0xff;
+
+        header += 3;
+        count  += 3;
+
+        for (List<HEVCParamSet>::iterator it = seqParamSets.begin();
+              it != seqParamSets.end(); ++it) {
+            // 16-bit sequence parameter set length
+            uint16_t seqParamSetLength = it->mLength;
+
+            // 16-bit number of NAL units of this type
+            header[0] = seqParamSetLength >> 8;
+            header[1] = seqParamSetLength & 0xff;
+
+            extractNALRBSPData(it->mData, it->mLength,
+                               (uint8_t **)&codecConfigData,
+                               &ifProfileIDCAlreadyFilled);
+
+            // SPS NAL unit (sequence parameter length bytes)
+            memcpy(&header[2], it->mData, seqParamSetLength);
+            header += (2 + seqParamSetLength);
+            count  += (2 + seqParamSetLength);
+        }
+    }
+
+    if (!doneWritingPPS) {
+        doneWritingPPS = true;
+        ALOGV("writing PPS");
+        //8-bit, last 6 bit for NAL type
+        header[0] = 0x22; // NAL type is PPS
+        //16-bit, number of nal Units
+        uint16_t picParamSetLength = picParamSets.size();
+        header[1] = picParamSetLength >> 8;
+        header[2] = picParamSetLength & 0xff;
+
+        header += 3;
+        count  += 3;
+
+        for (List<HEVCParamSet>::iterator it = picParamSets.begin();
+             it != picParamSets.end(); ++it) {
+            // 16-bit picture parameter set length
+            uint16_t picParamSetLength = it->mLength;
+            header[0] = picParamSetLength >> 8;
+            header[1] = picParamSetLength & 0xff;
+
+            // PPS Nal unit (picture parameter set length bytes)
+            memcpy(&header[2], it->mData, picParamSetLength);
+            header += (2 + picParamSetLength);
+            count  += (2 + picParamSetLength);
+        }
+    }
+    *codecSpecificData = codecConfigData;
+    return OK;
 }
 
-const char *AVUtils::HEVCMuxer::getFourCCForMime(const char * /*mime*/) {
+const char *AVUtils::HEVCMuxer::getFourCCForMime(const char * mime) {
+    if (isVideoHEVC(mime)) {
+        return "hvc1";
+    }
     return NULL;
 }
 
-void AVUtils::HEVCMuxer::writeHvccBox(MPEG4Writer * /*writer*/,
-        void * /*codecSpecificData*/, size_t /*codecSpecificDataSize*/,
-        bool /*useNalLengthFour*/) {
-    return;
+void AVUtils::HEVCMuxer::writeHvccBox(MPEG4Writer *writer,
+        void *codecSpecificData, size_t codecSpecificDataSize,
+        bool useNalLengthFour) {
+    ALOGV("writeHvccBox called");
+    CHECK(codecSpecificData);
+    CHECK_GE(codecSpecificDataSize, 23);
+
+    // Patch hvcc's lengthSize field to match the number
+    // of bytes we use to indicate the size of a nal unit.
+    uint8_t *ptr = (uint8_t *)codecSpecificData;
+    ptr[21] = (ptr[21] & 0xfc) | (useNalLengthFour? 3 : 1);
+    writer->beginBox("hvcC");
+    writer->write(codecSpecificData, codecSpecificDataSize);
+    writer->endBox();  // hvcC
 }
 
-bool AVUtils::HEVCMuxer::isVideoHEVC(const char * /*mime*/) {
-    return false;
+bool AVUtils::HEVCMuxer::isVideoHEVC(const char * mime) {
+    return (!strncasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC,
+                         strlen(MEDIA_MIMETYPE_VIDEO_HEVC)));
+}
+
+status_t AVUtils::HEVCMuxer::extractNALRBSPData(const uint8_t *data,
+                                            size_t size,
+                                            uint8_t **header,
+                                            bool *alreadyFilled) {
+    ALOGV("extractNALRBSPData called");
+    CHECK_GE(size, 2);
+
+    uint8_t type = data[0] >> 1;
+    type = 0x3f & type;
+
+    //start parsing here
+    size_t rbspSize = 0;
+    uint8_t *rbspData = (uint8_t *) malloc(size);
+
+    if (rbspData == NULL) {
+        ALOGE("allocation failed");
+        return UNKNOWN_ERROR;
+    }
+
+    //populate rbsp data start from i+2, search for 0x000003,
+    //and ignore emulation_prevention byte
+    size_t itt = 2;
+    while (itt < size) {
+        if ((itt+2 < size) && (!memcmp("\x00\x00\x03", &data[itt], 3) )) {
+            rbspData[rbspSize++] = data[itt++];
+            rbspData[rbspSize++] = data[itt++];
+            itt++;
+        } else {
+            rbspData[rbspSize++] = data[itt++];
+        }
+    }
+
+    uint8_t maxSubLayerMinus1 = 0;
+
+    //parser profileTierLevel
+    if (type == kHEVCNalUnitTypeVidParamSet) { // if VPS
+        ALOGV("its VPS ... start with 5th byte");
+        if (rbspSize < 5) {
+            free(rbspData);
+            return ERROR_MALFORMED;
+        }
+
+        maxSubLayerMinus1 = 0x0E & rbspData[1];
+        maxSubLayerMinus1 = maxSubLayerMinus1 >> 1;
+        parserProfileTierLevel(&rbspData[4], rbspSize - 4, header, alreadyFilled);
+
+    } else if (type == kHEVCNalUnitTypeSeqParamSet) {
+        ALOGV("its SPS .. start with 2nd byte");
+        if (rbspSize < 2) {
+            free(rbspData);
+            return ERROR_MALFORMED;
+        }
+
+        maxSubLayerMinus1 = 0x0E & rbspData[0];
+        maxSubLayerMinus1 = maxSubLayerMinus1 >> 1;
+
+        parserProfileTierLevel(&rbspData[1], rbspSize - 1, header, alreadyFilled);
+    }
+    free(rbspData);
+    return OK;
+}
+
+status_t AVUtils::HEVCMuxer::parserProfileTierLevel(const uint8_t *data, size_t size,
+                                                     uint8_t **header, bool *alreadyFilled) {
+    CHECK_GE(size, 12);
+    uint8_t *tmpHeader = *header;
+    ALOGV("parserProfileTierLevel called");
+    uint8_t generalProfileSpace; //2 bit
+    uint8_t generalTierFlag;     //1 bit
+    uint8_t generalProfileIdc;   //5 bit
+    uint8_t generalProfileCompatibilityFlag[4];
+    uint8_t generalConstraintIndicatorFlag[6];
+    uint8_t generalLevelIdc;     //8 bit
+
+    // Need first 12 bytes
+
+    // First byte will give below info
+    generalProfileSpace = 0xC0 & data[0];
+    generalProfileSpace = generalProfileSpace > 6;
+    generalTierFlag = 0x20 & data[0];
+    generalTierFlag = generalTierFlag > 5;
+    generalProfileIdc = 0x1F & data[0];
+
+    // Next 4 bytes is compatibility flag
+    memcpy(&generalProfileCompatibilityFlag, &data[1], 4);
+
+    // Next 6 bytes is constraint indicator flag
+    memcpy(&generalConstraintIndicatorFlag, &data[5], 6);
+
+    // Next 1 byte is general Level IDC
+    generalLevelIdc = data[11];
+
+    if (*alreadyFilled) {
+        bool overwriteTierValue = false;
+
+        //find profile space
+        uint8_t prvGeneralProfileSpace; //2 bit
+        prvGeneralProfileSpace = 0xC0 & tmpHeader[1];
+        prvGeneralProfileSpace = prvGeneralProfileSpace > 6;
+        //prev needs to be same as current
+        if (prvGeneralProfileSpace != generalProfileSpace) {
+            ALOGW("Something wrong!!! profile space mismatch");
+        }
+
+        uint8_t prvGeneralTierFlag = 0x20 & tmpHeader[1];
+        prvGeneralTierFlag = prvGeneralTierFlag > 5;
+
+        if (prvGeneralTierFlag < generalTierFlag) {
+            overwriteTierValue = true;
+            ALOGV("Found higher tier value, replacing old one");
+        }
+
+        uint8_t prvGeneralProfileIdc = 0x1F & tmpHeader[1];
+
+        if (prvGeneralProfileIdc != generalProfileIdc) {
+            ALOGW("Something is wrong!!! profile space mismatch");
+        }
+
+        if (overwriteTierValue) {
+            tmpHeader[1] = data[0];
+        }
+
+        //general level IDC should be set highest among all
+        if (tmpHeader[12] < data[11]) {
+            tmpHeader[12] = data[11];
+            ALOGV("Found higher level IDC value, replacing old one");
+        }
+
+    } else {
+        *alreadyFilled = true;
+        tmpHeader[1] = data[0];
+        memcpy(&tmpHeader[2], &data[1], 4);
+        memcpy(&tmpHeader[6], &data[5], 6);
+        tmpHeader[12] = data[11];
+    }
+
+    char printCodecConfig[PROPERTY_VALUE_MAX];
+    property_get("hevc.mux.print.codec.config", printCodecConfig, "0");
+
+    if (atoi(printCodecConfig)) {
+        //if property enabled, print these values
+        ALOGI("Start::-----------------");
+        ALOGI("generalProfileSpace = %2x", generalProfileSpace);
+        ALOGI("generalTierFlag     = %2x", generalTierFlag);
+        ALOGI("generalProfileIdc   = %2x", generalProfileIdc);
+        ALOGI("generalLevelIdc     = %2x", generalLevelIdc);
+        ALOGI("generalProfileCompatibilityFlag = %2x %2x %2x %2x", generalProfileCompatibilityFlag[0],
+               generalProfileCompatibilityFlag[1], generalProfileCompatibilityFlag[2],
+               generalProfileCompatibilityFlag[3]);
+        ALOGI("generalConstraintIndicatorFlag = %2x %2x %2x %2x %2x %2x", generalConstraintIndicatorFlag[0],
+               generalConstraintIndicatorFlag[1], generalConstraintIndicatorFlag[2],
+               generalConstraintIndicatorFlag[3], generalConstraintIndicatorFlag[4],
+               generalConstraintIndicatorFlag[5]);
+        ALOGI("End::-----------------");
+    }
+
+    return OK;
+}
+static const uint8_t *findNextStartCode(
+       const uint8_t *data, size_t length) {
+    ALOGV("findNextStartCode: %p %d", data, length);
+
+    size_t bytesLeft = length;
+
+    while (bytesLeft > 4 &&
+            memcmp("\x00\x00\x00\x01", &data[length - bytesLeft], 4)) {
+        --bytesLeft;
+    }
+
+    if (bytesLeft <= 4) {
+        bytesLeft = 0; // Last parameter set
+    }
+
+    return &data[length - bytesLeft];
+}
+
+const uint8_t *AVUtils::HEVCMuxer::parseHEVCParamSet(
+        const uint8_t *data, size_t length, List<HEVCParamSet> &paramSetList, size_t *paramSetLen) {
+    ALOGV("parseHEVCParamSet called");
+    const uint8_t *nextStartCode = findNextStartCode(data, length);
+    *paramSetLen = nextStartCode - data;
+    if (*paramSetLen == 0) {
+        ALOGE("Param set is malformed, since its length is 0");
+        return NULL;
+    }
+
+    HEVCParamSet paramSet(*paramSetLen, data);
+    paramSetList.push_back(paramSet);
+
+    return nextStartCode;
+}
+
+static void getHEVCNalUnitType(uint8_t byte, uint8_t* type) {
+    ALOGV("getNalUnitType: %d", (int)byte);
+    // nal_unit_type: 6-bit unsigned integer
+    *type = (byte & 0x7E) >> 1;
+}
+
+size_t AVUtils::HEVCMuxer::parseHEVCCodecSpecificData(
+        const uint8_t *data, size_t size,List<HEVCParamSet> &vidParamSet,
+        List<HEVCParamSet> &seqParamSet, List<HEVCParamSet> &picParamSet ) {
+    ALOGV("parseHEVCCodecSpecificData called");
+    // Data starts with a start code.
+    // VPS, SPS and PPS are separated with start codes.
+    uint8_t type = kHEVCNalUnitTypeVidParamSet;
+    bool gotVps = false;
+    bool gotSps = false;
+    bool gotPps = false;
+    const uint8_t *tmp = data;
+    const uint8_t *nextStartCode = data;
+    size_t bytesLeft = size;
+    size_t paramSetLen = 0;
+    size_t codecSpecificDataSize = 0;
+    while (bytesLeft > 4 && !memcmp("\x00\x00\x00\x01", tmp, 4)) {
+        getHEVCNalUnitType(*(tmp + 4), &type);
+        if (type == kHEVCNalUnitTypeVidParamSet) {
+            nextStartCode = parseHEVCParamSet(tmp + 4, bytesLeft - 4, vidParamSet, &paramSetLen);
+            if (!gotVps) {
+                gotVps = true;
+            }
+        } else if (type == kHEVCNalUnitTypeSeqParamSet) {
+            nextStartCode = parseHEVCParamSet(tmp + 4, bytesLeft - 4, seqParamSet, &paramSetLen);
+            if (!gotSps) {
+                gotSps = true;
+            }
+
+        } else if (type == kHEVCNalUnitTypePicParamSet) {
+            nextStartCode = parseHEVCParamSet(tmp + 4, bytesLeft - 4, picParamSet, &paramSetLen);
+            if (!gotPps) {
+                gotPps = true;
+            }
+        } else {
+            ALOGE("Only VPS, SPS and PPS Nal units are expected");
+            return ERROR_MALFORMED;
+        }
+
+        if (nextStartCode == NULL) {
+            ALOGE("Next start code is NULL");
+            return ERROR_MALFORMED;
+        }
+
+        // Move on to find the next parameter set
+        bytesLeft -= nextStartCode - tmp;
+        tmp = nextStartCode;
+        codecSpecificDataSize += (2 + paramSetLen);
+    }
+
+#if 0
+//not adding this check now, but might be needed
+    if (!gotVps || !gotVps || !gotVps ) {
+        return 0;
+    }
+#endif
+
+    return codecSpecificDataSize;
 }
 
 void AVUtils::HEVCMuxer::getHEVCCodecSpecificDataFromInputFormatIfPossible(
-        sp<MetaData> /*meta*/, void ** /*codecSpecificData*/,
-        size_t * /*codecSpecificDataSize*/, bool * /*gotAllCodecSpecificData*/) {
-    return;
+    sp<MetaData> meta, void ** codecSpecificData,
+    size_t * codecSpecificDataSize, bool * gotAllCodecSpecificData) {
+    uint32_t type;
+    const void *data;
+    size_t size;
+    //kKeyHVCC needs to be populated
+    if (meta->findData(kKeyHVCC, &type, &data, &size)) {
+        *codecSpecificData = malloc(size);
+        CHECK(*codecSpecificData != NULL);
+        *codecSpecificDataSize = size;
+        memcpy(*codecSpecificData, data, size);
+        *gotAllCodecSpecificData = true;
+    } else {
+        ALOGW("getHEVCCodecConfigData:: failed to find kKeyHvcc");
+    }
 }
 
 bool AVUtils::isAudioMuxFormatSupported(const char *) {
@@ -440,7 +999,7 @@ AVUtils::~AVUtils() {}
 
 //static
 AVUtils *AVUtils::sInst =
-        ExtensionsLoader<AVUtils>::createInstance("createExtendedUtils");
+        ExtensionsLoader<AVUtils>::createInstance("createAVUtils");
 
 } //namespace android
 
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index fae9b7d..df396bd 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -1278,7 +1278,8 @@ status_t StagefrightRecorder::checkVideoEncoderCapabilities() {
             (mVideoEncoder == VIDEO_ENCODER_H263 ? MEDIA_MIMETYPE_VIDEO_H263 :
              mVideoEncoder == VIDEO_ENCODER_MPEG_4_SP ? MEDIA_MIMETYPE_VIDEO_MPEG4 :
              mVideoEncoder == VIDEO_ENCODER_VP8 ? MEDIA_MIMETYPE_VIDEO_VP8 :
-             mVideoEncoder == VIDEO_ENCODER_H264 ? MEDIA_MIMETYPE_VIDEO_AVC : ""),
+             mVideoEncoder == VIDEO_ENCODER_H264 ? MEDIA_MIMETYPE_VIDEO_AVC :
+             mVideoEncoder == VIDEO_ENCODER_H265 ? MEDIA_MIMETYPE_VIDEO_HEVC : ""),
             false /* decoder */, true /* hwCodec */, &codecs);
 
     if (!mCaptureFpsEnable) {
@@ -1365,8 +1366,10 @@ void StagefrightRecorder::setDefaultVideoEncoderIfNecessary() {
             int videoCodec = mEncoderProfiles->getCamcorderProfileParamByName(
                     "vid.codec", mCameraId, CAMCORDER_QUALITY_LOW);
 
-            if (videoCodec > VIDEO_ENCODER_DEFAULT &&
-                videoCodec < VIDEO_ENCODER_LIST_END) {
+            if ((videoCodec > VIDEO_ENCODER_DEFAULT &&
+                 videoCodec < VIDEO_ENCODER_LIST_END) ||
+                (videoCodec > VIDEO_ENCODER_LIST_VENDOR_START &&
+                 videoCodec < VIDEO_ENCODER_LIST_VENDOR_END)) {
                 mVideoEncoder = (video_encoder)videoCodec;
             } else {
                 // default to H.264 if camcorder profile not available
@@ -1544,8 +1547,12 @@ status_t StagefrightRecorder::setupCameraSource(
     return OK;
 }
 
-bool StagefrightRecorder::setCustomVideoEncoderMime(const video_encoder /*videoEncoder*/,
-        sp<AMessage> /*format*/) {
+bool StagefrightRecorder::setCustomVideoEncoderMime(const video_encoder videoEncoder,
+        sp<AMessage> format) {
+    if (videoEncoder == VIDEO_ENCODER_H265) {
+        format->setString("mime", MEDIA_MIMETYPE_VIDEO_HEVC);
+        return true;
+    }
     return false;
 }
 
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 602c4f0..2785d7b 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -93,7 +93,7 @@ uint64_t hton64(uint64_t x) {
     return ((uint64_t)htonl(x & 0xffffffff) << 32) | htonl(x >> 32);
 }
 
-static status_t copyNALUToABuffer(sp<ABuffer> *buffer, const uint8_t *ptr, size_t length) {
+status_t copyNALUToABuffer(sp<ABuffer> *buffer, const uint8_t *ptr, size_t length) {
     if (((*buffer)->size() + 4 + length) > ((*buffer)->capacity() - (*buffer)->offset())) {
         sp<ABuffer> tmpBuffer = new (std::nothrow) ABuffer((*buffer)->size() + 4 + length + 1024);
         if (tmpBuffer.get() == NULL || tmpBuffer->base() == NULL) {
-- 
2.7.4


From b250df4efc489876d80cc44042b25941fb0bdd11 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sun, 13 Dec 2015 13:03:56 -0800
Subject: [PATCH 060/119] stagefright: Finish "Port AOSP fixes"

 * Fill in stubs for CAF commit bd019775a921ae9165e924e4d37bc838a7ef5781

Change-Id: Ia97d965d121aa3c3c2fc0ab8b164244416852ca5
---
 media/libavextensions/stagefright/AVUtils.cpp | 42 ++++++++++++++++++++++++---
 media/libstagefright/ACodec.cpp               |  2 +-
 2 files changed, 39 insertions(+), 5 deletions(-)

diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index b153573..cd1d4c6 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -29,6 +29,7 @@
 
 #define LOG_TAG "AVUtils"
 #include <utils/Log.h>
+#include <utils/StrongPointer.h>
 
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/foundation/AMessage.h>
@@ -49,6 +50,9 @@
 #endif
 #endif
 
+#include <binder/IPCThreadState.h>
+#include <camera/CameraParameters.h>
+
 #include "common/ExtensionsLoader.hpp"
 #include "stagefright/AVExtensions.h"
 
@@ -966,12 +970,42 @@ void AVUtils::HEVCMuxer::getHEVCCodecSpecificDataFromInputFormatIfPossible(
     }
 }
 
-bool AVUtils::isAudioMuxFormatSupported(const char *) {
-    return true;
+bool AVUtils::isAudioMuxFormatSupported(const char * mime) {
+    if (mime == NULL) {
+        ALOGE("NULL audio mime type");
+        return false;
+    }
+
+    if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_NB, mime)
+            || !strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_WB, mime)
+            || !strcasecmp(MEDIA_MIMETYPE_AUDIO_AAC, mime)) {
+        return true;
+    }
+    return false;
 }
 
-void AVUtils::cacheCaptureBuffers(sp<ICamera>, video_encoder) {
-    return;
+void AVUtils::cacheCaptureBuffers(sp<ICamera> camera, video_encoder encoder) {
+    if (camera != NULL) {
+        char mDeviceName[PROPERTY_VALUE_MAX];
+        property_get("ro.board.platform", mDeviceName, "0");
+        if (!strncmp(mDeviceName, "msm8909", 7)) {
+            int64_t token = IPCThreadState::self()->clearCallingIdentity();
+            String8 s = camera->getParameters();
+            CameraParameters params(s);
+            const char *enable;
+            if (encoder == VIDEO_ENCODER_H263 ||
+                encoder == VIDEO_ENCODER_MPEG_4_SP) {
+                enable = "1";
+            } else {
+                enable = "0";
+            }
+            params.set("cache-video-buffers", enable);
+            if (camera->setParameters(params.flatten()) != OK) {
+                ALOGE("Failed to enabled cached camera buffers");
+            }
+            IPCThreadState::self()->restoreCallingIdentity(token);
+        }
+    }
 }
 
 const char *AVUtils::getCustomCodecsLocation() {
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 9ec0f68..31f1d76 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -3867,7 +3867,7 @@ status_t ACodec::setupErrorCorrectionParameters() {
 
     errorCorrectionType.bEnableHEC = OMX_FALSE;
     errorCorrectionType.bEnableResync = OMX_TRUE;
-    errorCorrectionType.nResynchMarkerSpacing = 256;
+    errorCorrectionType.nResynchMarkerSpacing = 0;
     errorCorrectionType.bEnableDataPartitioning = OMX_FALSE;
     errorCorrectionType.bEnableRVLC = OMX_FALSE;
 
-- 
2.7.4


From 4cbb15d5e8fa187c8041662038f8dcc5d7e1b4a2 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sun, 13 Dec 2015 16:01:02 -0800
Subject: [PATCH 061/119] stagefright: Check vendor list for allowed encoders

Change-Id: Ie9ff0d275fc5f853c18fe4d5e590443d0c316e99
---
 media/libmediaplayerservice/StagefrightRecorder.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index df396bd..9c07fc6 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -185,7 +185,8 @@ status_t StagefrightRecorder::setAudioEncoder(audio_encoder ae) {
 status_t StagefrightRecorder::setVideoEncoder(video_encoder ve) {
     ALOGV("setVideoEncoder: %d", ve);
     if (ve < VIDEO_ENCODER_DEFAULT ||
-        ve >= VIDEO_ENCODER_LIST_END) {
+        (ve >= VIDEO_ENCODER_LIST_END && ve <= VIDEO_ENCODER_LIST_VENDOR_START) ||
+        ve >= VIDEO_ENCODER_LIST_VENDOR_END) {
         ALOGE("Invalid video encoder: %d", ve);
         return BAD_VALUE;
     }
-- 
2.7.4


From ebd11dba4122dbbb8b7b8d990f7f460f5fe66a6f Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 14 Dec 2015 01:24:54 -0800
Subject: [PATCH 062/119] stagefright: Additional fixes for extended offload
 support

 * Fix compilation with debug enabled
 * Allow FLAC offload to be enabled independent of QCOM_HARDWARE,
   tested with the Nexus 5X and is working!
 * Disable the FLACExtractor if offload is enabled since it can
   only output decoded PCM. This will force FFMPEG to be used,
   which does everything we need for FLAC offload

Change-Id: I7d71c153a6a6ea7df8e32bc73f5cbe9f51cdcf64
---
 media/libavextensions/Android.mk                          | 4 ++--
 media/libavextensions/stagefright/AVUtils.cpp             | 4 ++--
 media/libmediaplayerservice/nuplayer/StreamingSource.cpp  | 1 +
 media/libstagefright/Android.mk                           | 3 ++-
 media/libstagefright/DataSource.cpp                       | 2 ++
 media/libstagefright/MediaExtractor.cpp                   | 2 ++
 media/libstagefright/Utils.cpp                            | 3 +++
 services/audiopolicy/common/managerdefinitions/Android.mk | 2 --
 8 files changed, 14 insertions(+), 7 deletions(-)

diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
index 22cf8d9..923257c 100644
--- a/media/libavextensions/Android.mk
+++ b/media/libavextensions/Android.mk
@@ -18,15 +18,15 @@ LOCAL_C_INCLUDES:= \
 
 LOCAL_CFLAGS += -Wno-multichar -Werror
 
-ifeq ($(call is-vendor-board-platform,QCOM),true)
 LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/mm-audio
+
 ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
        LOCAL_CFLAGS += -DENABLE_AV_ENHANCEMENTS
 endif
+
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_FLAC_OFFLOAD)),true)
        LOCAL_CFLAGS += -DFLAC_OFFLOAD_ENABLED
 endif
-endif
 
 LOCAL_MODULE:= libavextensions
 LOCAL_CFLAGS += -DLOG_NDEBUG=0
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index cd1d4c6..fe2c519 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -42,7 +42,7 @@
 #include <media/stagefright/MPEG4Writer.h>
 #include <media/stagefright/Utils.h>
 
-#ifdef QCOM_HARDWARE
+#if defined(QCOM_HARDWARE) || defined(FLAC_OFFLOAD_ENABLED)
 #include "QCMediaDefs.h"
 #include "QCMetaData.h"
 #ifdef FLAC_OFFLOAD_ENABLED
@@ -97,13 +97,13 @@ static const MetaKeyEntry MetaKeyTable[] {
    {kKeyUseArbitraryMode     , "use-arbitrary-mode"     , INT32},  //bool (int32_t)
    {kKeySmoothStreaming      , "smooth-streaming"       , INT32},  //bool (int32_t)
    {kKeyHFR                  , "hfr"                    , INT32},  // int32_t
+#endif
 #ifdef FLAC_OFFLOAD_ENABLED
    {kKeyMinBlkSize           , "min-block-size"         , INT32},
    {kKeyMaxBlkSize           , "max-block-size"         , INT32},
    {kKeyMinFrmSize           , "min-frame-size"         , INT32},
    {kKeyMaxFrmSize           , "max-frame-size"         , INT32},
 #endif
-#endif
 
 
    {kKeyBitRate              , "bitrate"                , INT32},
diff --git a/media/libmediaplayerservice/nuplayer/StreamingSource.cpp b/media/libmediaplayerservice/nuplayer/StreamingSource.cpp
index 23bed9e..04f6b53 100644
--- a/media/libmediaplayerservice/nuplayer/StreamingSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/StreamingSource.cpp
@@ -29,6 +29,7 @@
 #include <media/stagefright/foundation/AMessage.h>
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MetaData.h>
+#include <inttypes.h>
 
 namespace android {
 
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 029d42d..cebe7c9 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -176,10 +176,11 @@ LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/mm-audio
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_EXTN_FLAC_DECODER)),true)
     LOCAL_CFLAGS += -DQTI_FLAC_DECODER
 endif
+endif
+
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_FLAC_OFFLOAD)),true)
     LOCAL_CFLAGS += -DFLAC_OFFLOAD_ENABLED
 endif
-endif
 
 LOCAL_CLANG := true
 
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 8b49d18..f32bb7e 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -232,7 +232,9 @@ void DataSource::RegisterDefaultSniffers() {
     RegisterSniffer_l(SniffMatroska);
     RegisterSniffer_l(SniffOgg);
     RegisterSniffer_l(SniffWAV);
+#ifndef FLAC_OFFLOAD_ENABLED
     RegisterSniffer_l(SniffFLAC);
+#endif
     RegisterSniffer_l(SniffAMR);
     RegisterSniffer_l(SniffMPEG2TS);
     RegisterSniffer_l(SniffMP3);
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index fc96e2f..cd0acfa 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -117,8 +117,10 @@ retry:
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)
             || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) {
         ret = new AMRExtractor(source);
+#ifndef FLAC_OFFLOAD_ENABLED
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
         ret = new FLACExtractor(source);
+#endif
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) {
         ret = new WAVExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) {
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 2785d7b..9fae724 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -821,6 +821,9 @@ static const struct mime_conv_t mimeLookup[] = {
     { MEDIA_MIMETYPE_AUDIO_AAC,         AUDIO_FORMAT_AAC },
     { MEDIA_MIMETYPE_AUDIO_VORBIS,      AUDIO_FORMAT_VORBIS },
     { MEDIA_MIMETYPE_AUDIO_OPUS,        AUDIO_FORMAT_OPUS},
+#ifdef FLAC_OFFLOAD_ENABLED
+    { MEDIA_MIMETYPE_AUDIO_FLAC,        AUDIO_FORMAT_FLAC},
+#endif
 #ifdef DOLBY_ENABLE
     { MEDIA_MIMETYPE_AUDIO_AC3,         AUDIO_FORMAT_AC3},
     { MEDIA_MIMETYPE_AUDIO_EAC3,        AUDIO_FORMAT_E_AC3},
diff --git a/services/audiopolicy/common/managerdefinitions/Android.mk b/services/audiopolicy/common/managerdefinitions/Android.mk
index 8c6a53c..f88b72c 100644
--- a/services/audiopolicy/common/managerdefinitions/Android.mk
+++ b/services/audiopolicy/common/managerdefinitions/Android.mk
@@ -31,7 +31,6 @@ LOCAL_C_INCLUDES += \
 LOCAL_EXPORT_C_INCLUDE_DIRS := \
     $(LOCAL_PATH)/include
 
-ifeq ($(call is-vendor-board-platform,QCOM),true)
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_FLAC_OFFLOAD)),true)
 LOCAL_CFLAGS     += -DFLAC_OFFLOAD_ENABLED
 endif
@@ -50,7 +49,6 @@ endif
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_AAC_ADTS_OFFLOAD)),true)
 LOCAL_CFLAGS     += -DAAC_ADTS_OFFLOAD_ENABLED
 endif
-endif
 
 LOCAL_MODULE := libaudiopolicycomponents
 
-- 
2.7.4


From c76bf6bdd9159a75e26fb54789ac53e9539aa796 Mon Sep 17 00:00:00 2001
From: Sharad Sangle <assangle@codeaurora.org>
Date: Thu, 19 Mar 2015 18:33:17 +0530
Subject: [PATCH 063/119] NuPlayerDriver: Maintain the timeStamp after seek

 While offload playback is going on, if user pause
 and seeks to new position before offload tear-down,
 on resume playback starts from old time-stamp

 Once tear-down happens NuPlayer loses updated time-stamp
 so while resuming it resumes playback with stale time-stamp.
 Make sure the updated time-stamp is maintained in
 NuPlayerDriver wich is used while starting the playback
 after resume.

Change-Id: I3451051f569264b21a43be81b01798fabed0182e
---
 media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
index 030094e..885210d 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
@@ -409,6 +409,7 @@ status_t NuPlayerDriver::seekTo(int msec) {
         {
             mAtEOS = false;
             mSeekInProgress = true;
+            mStartupSeekTimeUs = seekTimeUs;
             // seeks can take a while, so we essentially paused
             notifyListener_l(MEDIA_PAUSED);
             mPlayer->seekToAsync(seekTimeUs, true /* needNotify */);
-- 
2.7.4


From f88d9e9302bee398173fb5dae03eaeb8cdf5c896 Mon Sep 17 00:00:00 2001
From: Sharad Sangle <assangle@codeaurora.org>
Date: Tue, 7 Apr 2015 15:04:55 +0530
Subject: [PATCH 064/119] NuPlayer: Don't maintain timeStamp if state is
 running

  While offload playback is going on, if user seeks
  to new position and after playback for some time,
  pauses till offload tear-down happens then playback
  resumes with old seek position

  The book-keeping of seektime for start of playback
  mStartupSeekTimeUs is also done in running state,
  it should be done only if current state is paused.

Change-Id: I4173a2ee4244bcc6794822dde24c467f0189b84f
---
 media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
index 885210d..5dd5087 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
@@ -409,7 +409,9 @@ status_t NuPlayerDriver::seekTo(int msec) {
         {
             mAtEOS = false;
             mSeekInProgress = true;
-            mStartupSeekTimeUs = seekTimeUs;
+            if (mState == STATE_PAUSED) {
+               mStartupSeekTimeUs = seekTimeUs;
+            }
             // seeks can take a while, so we essentially paused
             notifyListener_l(MEDIA_PAUSED);
             mPlayer->seekToAsync(seekTimeUs, true /* needNotify */);
-- 
2.7.4


From 12bd8b9793e69be34db861bfc4928e190973564e Mon Sep 17 00:00:00 2001
From: Xiaoming Yang <xmyang@codeaurora.org>
Date: Mon, 30 Mar 2015 18:05:45 +0800
Subject: [PATCH 065/119] nuplayer: Fix audio EOS notifiy on AudioSink not
 ready

Audio EOS won't be notified by renderer if AudioSink is not ready
and first buffer itself has EOS. Playback complete won't happen
due to missing audio EOS. Hence, audio EOS needs to be handled
and notified.

Change-Id: I779c7034d1964485c2b064c0179d3cd341af5a5f
CRs-Fixed: 801121
---
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index b7a2573..955333f 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -852,6 +852,18 @@ bool NuPlayer::Renderer::onDrainAudioQueue() {
     // immediately after start. Investigate error message
     // "vorbis_dsp_synthesis returned -135", along with RTSP.
     uint32_t numFramesPlayed;
+    if(!mAudioSink->ready() && !mAudioQueue.empty()) {
+        while (!mAudioQueue.empty()) {
+            QueueEntry *entry = &*mAudioQueue.begin();
+            if (entry->mBuffer == NULL) {
+                notifyEOS(true /* audio */, entry->mFinalResult);
+            }
+            mAudioQueue.erase(mAudioQueue.begin());
+            entry = NULL;
+        }
+        return false;
+    }
+
     if (mAudioSink->getPosition(&numFramesPlayed) != OK) {
         // When getPosition fails, renderer will not reschedule the draining
         // unless new samples are queued.
-- 
2.7.4


From a6f2c9740158e9a7216ee42cc12f67e2e16fe075 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 14 Dec 2015 02:54:24 -0800
Subject: [PATCH 066/119] nuplayer: PCM offload fixes

 * Fix PCM offload when passthrough isn't used (OMX decoder)
 * Fix resume of PCM offload after pause timeout

Change-Id: I742eafd6ae8656fb214ba6b81cc63af57590c28c
---
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp         | 13 +++++++------
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp | 10 ++++++----
 2 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index e642cf5..e8ef39d 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -1303,7 +1303,7 @@ void NuPlayer::onResume() {
     } 
     // |mAudioDecoder| may have been released due to the pause timeout, so re-create it if
     // needed.
-    if (audioDecoderStillNeeded() && mAudioDecoder == NULL && !mOffloadDecodedPCM) {
+    if (audioDecoderStillNeeded() && mAudioDecoder == NULL) {
         instantiateDecoder(true /* audio */, &mAudioDecoder);
     }
     if (mRenderer != NULL) {
@@ -1379,8 +1379,8 @@ void NuPlayer::onStart(int64_t startPositionUs) {
 
     mOffloadAudio =
         canOffloadStream(audioMeta, (videoFormat != NULL), mSource->isStreaming(), streamType);
-    if (!mOffloadAudio) {
-        mOffloadAudio = canOffloadDecodedPCMStream(audioMeta, (videoFormat != NULL), mSource->isStreaming(), streamType);
+    if (!mOffloadAudio && (audioMeta != NULL)) {
+        mOffloadDecodedPCM = mOffloadAudio = canOffloadDecodedPCMStream(audioMeta, (videoFormat != NULL), mSource->isStreaming(), streamType);
     }
 
     if (mOffloadAudio) {
@@ -1523,6 +1523,7 @@ void NuPlayer::tryOpenAudioSinkForOffload(const sp<AMessage> &format, bool hasVi
     if (err != OK) {
         // Any failure we turn off mOffloadAudio.
         mOffloadAudio = false;
+        mOffloadDecodedPCM = false;
     } else if (mOffloadAudio) {
         sp<MetaData> audioMeta =
                 mSource->getFormatMeta(true /* audio */);
@@ -1542,6 +1543,7 @@ void NuPlayer::determineAudioModeChange() {
     if (mRenderer == NULL) {
         ALOGW("No renderer can be used to determine audio mode. Use non-offload for safety.");
         mOffloadAudio = false;
+        mOffloadDecodedPCM = false;
         return;
     }
 
@@ -1552,7 +1554,7 @@ void NuPlayer::determineAudioModeChange() {
     bool canOffload = canOffloadStream(
             audioMeta, hasVideo, mSource->isStreaming(), streamType);
     if (!canOffload) {
-        canOffload = canOffloadDecodedPCMStream(audioMeta, (videoFormat != NULL), mSource->isStreaming(), streamType);
+        mOffloadDecodedPCM = canOffload = canOffloadDecodedPCMStream(audioMeta, (videoFormat != NULL), mSource->isStreaming(), streamType);
     }
     if (canOffload) {
         if (!mOffloadAudio) {
@@ -1565,7 +1567,6 @@ void NuPlayer::determineAudioModeChange() {
         if (mOffloadAudio) {
             mRenderer->signalDisableOffloadAudio();
             mOffloadAudio = false;
-            setDecodedPcmOffload(false);
         }
     }
 }
@@ -2493,7 +2494,7 @@ bool NuPlayer::canOffloadDecodedPCMStream(const sp<MetaData> audioMeta,
                 AVNuUtils::get()->createPCMMetaFromSource(audioMeta);
 
         ALOGI("canOffloadDecodedPCMStream");
-        audioMeta->dumpToLog();
+        audioPCMMeta->dumpToLog();
         mOffloadDecodedPCM =
                 ((mime && !AVNuUtils::get()->pcmOffloadException(audioMeta)) &&
                 canOffloadStream(audioPCMMeta, hasVideo, isStreaming, streamType));
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 955333f..2eb5473 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1790,8 +1790,10 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
         onDisableOffloadAudio();
     } else {
         audioFormat = AVUtils::get()->updateAudioFormat(audioFormat, format);
-
         bitWidth = AVUtils::get()->getAudioSampleBits(format);
+        ALOGV("Mime \"%s\" mapped to audio_format 0x%x",
+                mime.c_str(), audioFormat);
+
         int avgBitRate = -1;
         format->findInt32("bitrate", &avgBitRate);
 
@@ -1811,6 +1813,8 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
             }
         }
 
+        ALOGV("onOpenAudioSink: %s", format->debugString().c_str());
+
         int32_t offloadBufferSize =
                                 AVUtils::get()->getAudioMaxInputBufferSize(
                                                audioFormat,
@@ -1857,9 +1861,6 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
 
         if (err == OK) {
             err = mAudioSink->setPlaybackRate(mPlaybackSettings);
-        }
-
-        if (err == OK) {
             // If the playback is offloaded to h/w, we pass
             // the HAL some metadata information.
             // We don't want to do this for PCM because it
@@ -1871,6 +1872,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
                 err = mAudioSink->start();
             }
             ALOGV_IF(err == OK, "openAudioSink: offload succeeded");
+            mFlags |= FLAG_OFFLOAD_AUDIO;
         }
         if (err != OK) {
             // Clean up, fall back to non offload mode.
-- 
2.7.4


From 2687597aa2fe8476ecc3a135f2ff14bf91462ffa Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 15 Dec 2015 05:07:21 -0500
Subject: [PATCH 067/119] nuplayer: Fix the neverending offload

 * This code should have been left inside the conditional
 * Also fix a misplaced flag which remained set even if opening
   in offload mode failed

Change-Id: Id72c17051db601e37b2289e6d904ce8f75ba6878
---
 .../nuplayer/NuPlayerRenderer.cpp                  | 195 +++++++++++----------
 1 file changed, 100 insertions(+), 95 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 2eb5473..ccb292d 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1781,108 +1781,113 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
     AString mime;
     CHECK(format->findString("mime", &mime));
 
-    audio_format_t audioFormat = AUDIO_FORMAT_PCM_16_BIT;
-    status_t err = mapMimeToAudioFormat(audioFormat, mime.c_str());
+    if (offloadingAudio()) {
+        audio_format_t audioFormat = AUDIO_FORMAT_PCM_16_BIT;
+        status_t err = mapMimeToAudioFormat(audioFormat, mime.c_str());
 
-    if (err != OK) {
-        ALOGE("Couldn't map mime \"%s\" to a valid "
-                "audio_format", mime.c_str());
-        onDisableOffloadAudio();
-    } else {
-        audioFormat = AVUtils::get()->updateAudioFormat(audioFormat, format);
-        bitWidth = AVUtils::get()->getAudioSampleBits(format);
-        ALOGV("Mime \"%s\" mapped to audio_format 0x%x",
-                mime.c_str(), audioFormat);
-
-        int avgBitRate = -1;
-        format->findInt32("bitrate", &avgBitRate);
-
-        int32_t aacProfile = -1;
-        if (audioFormat == AUDIO_FORMAT_AAC
-                && format->findInt32("aac-profile", &aacProfile)) {
-            // Redefine AAC format as per aac profile
-            int32_t isADTSSupported;
-            isADTSSupported = AVUtils::get()->mapAACProfileToAudioFormat(format,
-                                      audioFormat,
-                                      aacProfile);
-            if (!isADTSSupported) {
-                mapAACProfileToAudioFormat(audioFormat,
-                        aacProfile);
-            } else {
-                ALOGV("Format is AAC ADTS\n");
+        if (err != OK) {
+            ALOGE("Couldn't map mime \"%s\" to a valid "
+                    "audio_format", mime.c_str());
+            onDisableOffloadAudio();
+        } else {
+            audioFormat = AVUtils::get()->updateAudioFormat(audioFormat, format);
+            bitWidth = AVUtils::get()->getAudioSampleBits(format);
+            ALOGV("Mime \"%s\" mapped to audio_format 0x%x",
+                    mime.c_str(), audioFormat);
+
+            int avgBitRate = -1;
+            format->findInt32("bitrate", &avgBitRate);
+
+            int32_t aacProfile = -1;
+            if (audioFormat == AUDIO_FORMAT_AAC
+                    && format->findInt32("aac-profile", &aacProfile)) {
+                // Redefine AAC format as per aac profile
+                int32_t isADTSSupported;
+                isADTSSupported = AVUtils::get()->mapAACProfileToAudioFormat(format,
+                                          audioFormat,
+                                          aacProfile);
+                if (!isADTSSupported) {
+                    mapAACProfileToAudioFormat(audioFormat,
+                            aacProfile);
+                } else {
+                    ALOGV("Format is AAC ADTS\n");
+                }
             }
-        }
 
-        ALOGV("onOpenAudioSink: %s", format->debugString().c_str());
-
-        int32_t offloadBufferSize =
-                                AVUtils::get()->getAudioMaxInputBufferSize(
-                                               audioFormat,
-                                               format);
-        audio_offload_info_t offloadInfo = AUDIO_INFO_INITIALIZER;
-
-        offloadInfo.duration_us = -1;
-        format->findInt64(
-                "durationUs", &offloadInfo.duration_us);
-        offloadInfo.sample_rate = sampleRate;
-        offloadInfo.channel_mask = channelMask;
-        offloadInfo.format = audioFormat;
-        offloadInfo.stream_type = AUDIO_STREAM_MUSIC;
-        offloadInfo.bit_rate = avgBitRate;
-        offloadInfo.has_video = hasVideo;
-        offloadInfo.is_streaming = isStreaming;
-        offloadInfo.bit_width = bitWidth;
-        offloadInfo.offload_buffer_size = offloadBufferSize;
-
-        if (memcmp(&mCurrentOffloadInfo, &offloadInfo, sizeof(offloadInfo)) == 0) {
-            ALOGV("openAudioSink: no change in offload mode");
-            // no change from previous configuration, everything ok.
-            return OK;
-        }
-        mCurrentPcmInfo = AUDIO_PCMINFO_INITIALIZER;
+            ALOGV("onOpenAudioSink: %s", format->debugString().c_str());
+
+            int32_t offloadBufferSize =
+                                    AVUtils::get()->getAudioMaxInputBufferSize(
+                                                   audioFormat,
+                                                   format);
+            audio_offload_info_t offloadInfo = AUDIO_INFO_INITIALIZER;
+
+            offloadInfo.duration_us = -1;
+            format->findInt64(
+                    "durationUs", &offloadInfo.duration_us);
+            offloadInfo.sample_rate = sampleRate;
+            offloadInfo.channel_mask = channelMask;
+            offloadInfo.format = audioFormat;
+            offloadInfo.stream_type = AUDIO_STREAM_MUSIC;
+            offloadInfo.bit_rate = avgBitRate;
+            offloadInfo.has_video = hasVideo;
+            offloadInfo.is_streaming = isStreaming;
+            offloadInfo.bit_width = bitWidth;
+            offloadInfo.offload_buffer_size = offloadBufferSize;
+
+            if (memcmp(&mCurrentOffloadInfo, &offloadInfo, sizeof(offloadInfo)) == 0) {
+                ALOGV("openAudioSink: no change in offload mode");
+                // no change from previous configuration, everything ok.
+                return OK;
+            }
+            mCurrentPcmInfo = AUDIO_PCMINFO_INITIALIZER;
 
-        ALOGV("openAudioSink: try to open AudioSink in offload mode");
-        uint32_t offloadFlags = flags;
-        offloadFlags |= AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD;
-        offloadFlags &= ~AUDIO_OUTPUT_FLAG_DEEP_BUFFER;
-        audioSinkChanged = true;
-        mAudioSink->close();
+            ALOGV("openAudioSink: try to open AudioSink in offload mode");
+            uint32_t offloadFlags = flags;
+            offloadFlags |= AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD;
+            offloadFlags &= ~AUDIO_OUTPUT_FLAG_DEEP_BUFFER;
+            audioSinkChanged = true;
+            mAudioSink->close();
 
-        err = mAudioSink->open(
-                sampleRate,
-                numChannels,
-                (audio_channel_mask_t)channelMask,
-                audioFormat,
-                0 /* bufferCount - unused */,
-                &NuPlayer::Renderer::AudioSinkCallback,
-                this,
-                (audio_output_flags_t)offloadFlags,
-                &offloadInfo);
+            err = mAudioSink->open(
+                    sampleRate,
+                    numChannels,
+                    (audio_channel_mask_t)channelMask,
+                    audioFormat,
+                    0 /* bufferCount - unused */,
+                    &NuPlayer::Renderer::AudioSinkCallback,
+                    this,
+                    (audio_output_flags_t)offloadFlags,
+                    &offloadInfo);
 
-        if (err == OK) {
-            err = mAudioSink->setPlaybackRate(mPlaybackSettings);
-            // If the playback is offloaded to h/w, we pass
-            // the HAL some metadata information.
-            // We don't want to do this for PCM because it
-            // will be going through the AudioFlinger mixer
-            // before reaching the hardware.
-            // TODO
-            mCurrentOffloadInfo = offloadInfo;
-            if (!mPaused) { // for preview mode, don't start if paused
-                err = mAudioSink->start();
+            if (err == OK) {
+                err = mAudioSink->setPlaybackRate(mPlaybackSettings);
+            }
+
+            if (err == OK) {
+                // If the playback is offloaded to h/w, we pass
+                // the HAL some metadata information.
+                // We don't want to do this for PCM because it
+                // will be going through the AudioFlinger mixer
+                // before reaching the hardware.
+                // TODO
+                mCurrentOffloadInfo = offloadInfo;
+                if (!mPaused) { // for preview mode, don't start if paused
+                    err = mAudioSink->start();
+                }
+                ALOGV_IF(err == OK, "openAudioSink: offload succeeded");
+            }
+            if (err != OK) {
+                // Clean up, fall back to non offload mode.
+                mAudioSink->close();
+                onDisableOffloadAudio();
+                mCurrentOffloadInfo = AUDIO_INFO_INITIALIZER;
+                ALOGV("openAudioSink: offload failed");
+            } else {
+                mUseAudioCallback = true;  // offload mode transfers data through callback
+                ++mAudioDrainGeneration;  // discard pending kWhatDrainAudioQueue message.
+                mFlags |= FLAG_OFFLOAD_AUDIO;
             }
-            ALOGV_IF(err == OK, "openAudioSink: offload succeeded");
-            mFlags |= FLAG_OFFLOAD_AUDIO;
-        }
-        if (err != OK) {
-            // Clean up, fall back to non offload mode.
-            mAudioSink->close();
-            onDisableOffloadAudio();
-            mCurrentOffloadInfo = AUDIO_INFO_INITIALIZER;
-            ALOGV("openAudioSink: offload failed");
-        } else {
-            mUseAudioCallback = true;  // offload mode transfers data through callback
-            ++mAudioDrainGeneration;  // discard pending kWhatDrainAudioQueue message.
         }
     }
     if (!offloadOnly && !offloadingAudio()) {
-- 
2.7.4


From fee112f65fad03802ca89083a7facd6b9d4dc89b Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 15 Dec 2015 05:44:18 -0500
Subject: [PATCH 068/119] nuplayer: Avoid crash when codec fails to load

 * Remove unnecessary check condition.

Change-Id: I3267a0c13165d74a2ea90333b42f000b51ace98b
---
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index e8ef39d..edaa658 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -1997,9 +1997,6 @@ void NuPlayer::performDecoderFlush(FlushCommand audio, FlushCommand video) {
 void NuPlayer::performReset() {
     ALOGV("performReset");
 
-    CHECK(mAudioDecoder == NULL);
-    CHECK(mVideoDecoder == NULL);
-
     cancelPollDuration();
 
     ++mScanSourcesGeneration;
-- 
2.7.4


From 195961476cd4a350f545c5af3b82ddc8d6ad0bb6 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 14 Dec 2015 20:57:31 -0600
Subject: [PATCH 069/119] nuplayer: Improve offload format conversions

 * Annotate source buffers with the audio format
 * Add support for 32-bit signed PCM offload (zero copy)

Change-Id: Id758830784740c0a038452d383c8ec8e3e4593bb
---
 .../mediaplayerservice/AVNuUtils.cpp               | 53 ++++++++++------------
 .../nuplayer/NuPlayerDecoder.h                     |  9 +++-
 .../nuplayer/NuPlayerDecoderPassThrough.h          |  4 +-
 3 files changed, 34 insertions(+), 32 deletions(-)

diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index d7b951f..7bf68ea 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -138,7 +138,11 @@ bool AVNuUtils::pcmOffloadException(const sp<MetaData> &meta) {
         ALOGV("%s: no audio mime present, ignoring pcm offload", __func__);
         return true;
     }
-//#if defined (PCM_OFFLOAD_ENABLED) || defined (PCM_OFFLOAD_ENABLED_24)
+
+    if (!is24bitPCMOffloadEnabled() && !is16bitPCMOffloadEnabled()) {
+        return true;
+    }
+
     const char * const ExceptionTable[] = {
         MEDIA_MIMETYPE_AUDIO_AMR_NB,
         MEDIA_MIMETYPE_AUDIO_AMR_WB,
@@ -257,7 +261,10 @@ status_t AVNuUtils::convertToSinkFormatIfNeeded(
         audio_format_t sinkFormat, bool isOffload) {
 
     audio_format_t srcFormat = AUDIO_FORMAT_INVALID;
-    if (!buffer->meta()->findInt32("pcm-format", (int32_t *)&srcFormat)) {
+    if (!isOffload
+            || !audio_is_offload_pcm(sinkFormat)
+            || !buffer->meta()->findInt32("pcm-format", (int32_t *)&srcFormat)
+            || ((int32_t)srcFormat < 0)) {
         newBuffer = buffer;
         return OK;
     }
@@ -280,37 +287,25 @@ status_t AVNuUtils::convertToSinkFormatIfNeeded(
           buffer->size(), frames, srcFormat);
 
     audio_format_t dstFormat;
-    if (isOffload) {
-        switch (sinkFormat) {
-            case AUDIO_FORMAT_PCM_16_BIT_OFFLOAD:
-                dstFormat = AUDIO_FORMAT_PCM_16_BIT;
-                break;
-            case AUDIO_FORMAT_PCM_24_BIT_OFFLOAD:
-                if (srcFormat != AUDIO_FORMAT_PCM_24_BIT_PACKED &&
-                    srcFormat != AUDIO_FORMAT_PCM_8_24_BIT) {
-                        ALOGE("Invalid src format for 24 bit conversion");
-                        return INVALID_OPERATION;
-                }
+    switch (sinkFormat) {
+        case AUDIO_FORMAT_PCM_16_BIT_OFFLOAD:
+            dstFormat = AUDIO_FORMAT_PCM_16_BIT;
+            break;
+        case AUDIO_FORMAT_PCM_24_BIT_OFFLOAD:
+            if (srcFormat == AUDIO_FORMAT_PCM_32_BIT)
+                dstFormat = AUDIO_FORMAT_PCM_32_BIT;
+            else
                 dstFormat = AUDIO_FORMAT_PCM_24_BIT_OFFLOAD;
-                break;
-            case AUDIO_FORMAT_DEFAULT:
-                ALOGI("OffloadInfo not yet initialized, retry");
-                return NO_INIT;
-            default:
-                ALOGE("Invalid offload format %x given for conversion",
-                      sinkFormat);
-                return INVALID_OPERATION;
-        }
-    } else {
-        if (sinkFormat == AUDIO_FORMAT_INVALID) {
-            ALOGD("PCM Info not yet initialized, drop buffer");
+            break;
+        case AUDIO_FORMAT_DEFAULT:
+            ALOGI("OffloadInfo not yet initialized, retry");
+            return NO_INIT;
+        default:
+            ALOGE("Invalid offload format %x given for conversion",
+                  sinkFormat);
             return INVALID_OPERATION;
-        }
-
-        dstFormat = sinkFormat;
     }
     if (srcFormat == dstFormat) {
-        ALOGV("same format");
         newBuffer = buffer;
         return OK;
     }
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
index ba25041..67cc310 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
@@ -36,9 +36,13 @@
 #ifndef NUPLAYER_DECODER_H_
 #define NUPLAYER_DECODER_H_
 
-#include "NuPlayer.h"
+#include <media/stagefright/foundation/AMessage.h>
 
+#include "NuPlayer.h"
 #include "NuPlayerDecoderBase.h"
+#include "NuPlayerSource.h"
+
+#include "mediaplayerservice/AVNuExtensions.h"
 
 namespace android {
 
@@ -68,7 +72,8 @@ protected:
     virtual void onFlush();
     virtual void onShutdown(bool notifyComplete);
     virtual bool doRequestBuffers();
-    virtual void setPcmFormat(const sp<AMessage> & /*format*/) {}
+    virtual void setPcmFormat(const sp<AMessage> &format) { format->setInt32("pcm-format",
+            AVNuUtils::get()->getKeyPCMFormat(mSource->getFormatMeta(true))); }
 
     enum {
         kWhatCodecNotify         = 'cdcN',
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
index 13a7c61..5f9c404 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
@@ -18,6 +18,8 @@
 
 #define NUPLAYER_DECODER_PASS_THROUGH_H_
 
+#include <media/stagefright/foundation/AMessage.h>
+
 #include "NuPlayer.h"
 
 #include "NuPlayerDecoderBase.h"
@@ -43,7 +45,7 @@ protected:
     virtual void onFlush();
     virtual void onShutdown(bool notifyComplete);
     virtual bool doRequestBuffers();
-    virtual void setPcmFormat(const sp<AMessage> & /*format*/) {}
+    virtual void setPcmFormat(const sp<AMessage> &format) { format->setInt32("pcm-format", mPCMFormat); }
     virtual sp<ABuffer> aggregateBuffer(const sp<ABuffer> &accessUnit);
 
     enum {
-- 
2.7.4


From eb75cdde033012f75e01c7c1e227f9eaae6ae07c Mon Sep 17 00:00:00 2001
From: "Christopher N. Hesse" <raymanfx@gmail.com>
Date: Tue, 20 Jan 2015 18:34:43 +0100
Subject: [PATCH 070/119] stagefright: add Samsung S3D support

Taken from insignal:
http://git.insignal.co.kr/insignal/arndale_octa-jb_mr1.1/android/platform/frameworks/av/commit/?h=arndale_octa-jb_mr1.1&id=f3667253827f206e455b54df47234a2d4db05826

Requires a device specific gralloc header with the following define:
GRALLOC_USAGE_PRIVATE_NONSECURE.

Change-Id: Ie1bb31b8b6fa38cfc263e2b327eb914e476c912c
---
 media/libstagefright/Android.mk   | 22 ++++++++++++++++++++
 media/libstagefright/OMXCodec.cpp | 43 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 65 insertions(+)

diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index cebe7c9..da71ce8 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -146,6 +146,28 @@ LOCAL_STATIC_LIBRARIES := \
 
 LOCAL_WHOLE_STATIC_LIBRARIES := libavextensions
 
+ifeq ($(BOARD_USE_S3D_SUPPORT), true)
+ifeq ($(BOARD_USES_HWC_SERVICES), true)
+LOCAL_CFLAGS += -DUSE_S3D_SUPPORT -DHWC_SERVICES
+LOCAL_C_INCLUDES += \
+        $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include \
+        $(TOP)/hardware/samsung_slsi/openmax/include/exynos \
+        $(TOP)/hardware/samsung_slsi/$(TARGET_BOARD_PLATFORM)-insignal/libhwcService \
+        $(TOP)/hardware/samsung_slsi/$(TARGET_BOARD_PLATFORM)-insignal/libhwc \
+        $(TOP)/hardware/samsung_slsi/$(TARGET_BOARD_PLATFORM)-insignal/include \
+        $(TOP)/hardware/samsung_slsi/$(TARGET_SOC)/libhwcmodule \
+        $(TOP)/hardware/samsung_slsi/$(TARGET_SOC)/include \
+        $(TOP)/hardware/samsung_slsi/exynos/libexynosutils \
+        $(TOP)/hardware/samsung_slsi/exynos/include
+
+LOCAL_ADDITIONAL_DEPENDENCIES := \
+        $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
+
+LOCAL_SHARED_LIBRARIES += \
+        libExynosHWCService
+endif
+endif
+
 LOCAL_SHARED_LIBRARIES += \
         libstagefright_enc_common \
         libstagefright_avc_common \
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 8fd3951..71f4546 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -101,6 +101,11 @@
 #include "include/OMX_Audio_DTS.h"
 #endif
 
+#ifdef USE_S3D_SUPPORT
+#include "Exynos_OMX_Def.h"
+#include "ExynosHWCService.h"
+#endif
+
 namespace android {
 
 // Treat time out as an error if we have not received any output
@@ -1865,6 +1870,10 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
 
     if (mFlags & kEnableGrallocUsageProtected) {
         usage |= GRALLOC_USAGE_PROTECTED;
+#ifdef GRALLOC_USAGE_PRIVATE_NONSECURE
+        if (!(mFlags & kUseSecureInputBuffers))
+            usage |= GRALLOC_USAGE_PRIVATE_NONSECURE;
+#endif
     }
 
     err = setNativeWindowSizeFormatAndUsage(
@@ -2425,7 +2434,41 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
             break;
         }
 #endif
+#ifdef USE_S3D_SUPPORT
+        case (OMX_EVENTTYPE)OMX_EventS3DInformation:
+        {
+            if (mFlags & kClientNeedsFramebuffer)
+                break;
 
+            sp<IServiceManager> sm = defaultServiceManager();
+            sp<android::IExynosHWCService> hwc = interface_cast<android::IExynosHWCService>(
+                    sm->getService(String16("Exynos.HWCService")));
+            if (hwc != NULL) {
+                if (data1 == OMX_TRUE) {
+                    int eS3DMode;
+                    switch (data2) {
+                    case OMX_SEC_FPARGMT_SIDE_BY_SIDE:
+                        eS3DMode = S3D_SBS;
+                        break;
+                    case OMX_SEC_FPARGMT_TOP_BOTTOM:
+                        eS3DMode = S3D_TB;
+                        break;
+                    case OMX_SEC_FPARGMT_CHECKERBRD_INTERL: // unsupport format at HDMI
+                    case OMX_SEC_FPARGMT_COLUMN_INTERL:
+                    case OMX_SEC_FPARGMT_ROW_INTERL:
+                    case OMX_SEC_FPARGMT_TEMPORAL_INTERL:
+                    default:
+                        eS3DMode = S3D_NONE;
+                    }
+
+                    hwc->setHdmiResolution(0, eS3DMode);
+                }
+            } else {
+                ALOGE("Exynos.HWCService is unavailable");
+            }
+            break;
+        }
+#endif
         default:
         {
             CODEC_LOGV("EVENT(%d, %u, %u)", event, data1, data2);
-- 
2.7.4


From 6ee01c848272163bc57ec86b6e5c6c86bafe73bf Mon Sep 17 00:00:00 2001
From: Ethan Chen <intervigil@gmail.com>
Date: Fri, 14 Aug 2015 14:11:44 -0700
Subject: [PATCH 071/119] stagefright: Update makefile for Exynos variants.

Change-Id: I1f6a2797156eba00e8f4cc1a5728b8e274ce965f
---
 media/libstagefright/Android.mk | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index da71ce8..8a1e729 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -151,14 +151,15 @@ ifeq ($(BOARD_USES_HWC_SERVICES), true)
 LOCAL_CFLAGS += -DUSE_S3D_SUPPORT -DHWC_SERVICES
 LOCAL_C_INCLUDES += \
         $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include \
-        $(TOP)/hardware/samsung_slsi/openmax/include/exynos \
-        $(TOP)/hardware/samsung_slsi/$(TARGET_BOARD_PLATFORM)-insignal/libhwcService \
-        $(TOP)/hardware/samsung_slsi/$(TARGET_BOARD_PLATFORM)-insignal/libhwc \
-        $(TOP)/hardware/samsung_slsi/$(TARGET_BOARD_PLATFORM)-insignal/include \
-        $(TOP)/hardware/samsung_slsi/$(TARGET_SOC)/libhwcmodule \
-        $(TOP)/hardware/samsung_slsi/$(TARGET_SOC)/include \
-        $(TOP)/hardware/samsung_slsi/exynos/libexynosutils \
-        $(TOP)/hardware/samsung_slsi/exynos/include
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/openmax/include/exynos \
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/$(TARGET_BOARD_PLATFORM)/libhwcService \
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/$(TARGET_BOARD_PLATFORM)/libhwc \
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/$(TARGET_BOARD_PLATFORM)/include \
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/$(TARGET_SOC)/libhwcmodule \
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/$(TARGET_SOC)/include \
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/exynos/libexynosutils \
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/exynos/include \
+        $(TOP)/hardware/samsung_slsi-$(TARGET_SLSI_VARIANT)/exynos/libhwc
 
 LOCAL_ADDITIONAL_DEPENDENCIES := \
         $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
-- 
2.7.4


From a52bdfe744327da95bf6d9737a41884948604325 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Wed, 9 Dec 2015 16:47:54 -0800
Subject: [PATCH 072/119] stagefright: Fix videot thumbnail retrival for wmv

We override some h/w decoders in video configure
since we know some h/w decoder does not support
certain types of video. e.g. WMV7/8.
But we did not do that when application retrieving
video frame for thumbnail causing video frame retrieved
is corrupted.

Fix it by calling FFMPEGSoftCodec::overrideComponentName
when we retrieve a single video frame for thumbnail purpose.

Change-Id: I334698c331dfd3d49bb5d8b8e9c1fe381b304179
---
 media/libstagefright/FFMPEGSoftCodec.cpp           | 34 ++++++++++++++++++++++
 .../StagefrightMetadataRetriever.cpp               | 10 +++++++
 2 files changed, 44 insertions(+)

diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index d899351..f0ca563 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -192,6 +192,40 @@ static void InitOMXParams(T *params) {
     params->nVersion.s.nStep = 0;
 }
 
+const char* FFMPEGSoftCodec::overrideComponentName(
+        uint32_t /*quirks*/, const sp<MetaData> &meta, const char *mime, bool isEncoder) {
+    const char* componentName = NULL;
+
+    int32_t wmvVersion = 0;
+    if (!strncasecmp(mime, MEDIA_MIMETYPE_VIDEO_WMV, strlen(MEDIA_MIMETYPE_VIDEO_WMV)) &&
+            meta->findInt32(kKeyWMVVersion, &wmvVersion)) {
+        ALOGD("Found WMV version key %d", wmvVersion);
+        if (wmvVersion != 2) {
+            ALOGD("Use FFMPEG for unsupported WMV track");
+            componentName = "OMX.ffmpeg.wmv.decoder";
+        }
+    }
+
+    int32_t encodeOptions = 0;
+    if (!isEncoder && !strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_WMA, strlen(MEDIA_MIMETYPE_AUDIO_WMA)) &&
+            !meta->findInt32(kKeyWMAEncodeOpt, &encodeOptions)) {
+        ALOGD("Use FFMPEG for unsupported WMA track");
+        componentName = "OMX.ffmpeg.wma.decoder";
+    }
+
+    // Google's decoder doesn't support MAIN profile
+    int32_t aacProfile = 0;
+    if (!isEncoder && !strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC, strlen(MEDIA_MIMETYPE_AUDIO_AAC)) &&
+            meta->findInt32(kKeyAACAOT, &aacProfile)) {
+        if (aacProfile == OMX_AUDIO_AACObjectMain) {
+            ALOGD("Use FFMPEG for AAC MAIN profile");
+            componentName = "OMX.ffmpeg.aac.decoder";
+        }
+    }
+
+    return componentName;
+}
+
 void FFMPEGSoftCodec::overrideComponentName(
         uint32_t /*quirks*/, const sp<AMessage> &msg, AString* componentName, AString* mime, int32_t isEncoder) {
 
diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
index 7384c7b..d39f34b 100644
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -28,6 +28,8 @@
 #include <media/ICrypto.h>
 #include <media/IMediaHTTPService.h>
 
+#include <media/stagefright/FFMPEGSoftCodec.h>
+
 #include <media/stagefright/foundation/ABuffer.h>
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/foundation/AMessage.h>
@@ -509,6 +511,14 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
 
     for (size_t i = 0; i < matchingCodecs.size(); ++i) {
         const char *componentName = matchingCodecs[i].mName.string();
+        const char *ffmpegComponentName;
+        /* determine whether ffmpeg should override a broken h/w codec */
+        ffmpegComponentName = FFMPEGSoftCodec::overrideComponentName(0, trackMeta, mime, false);
+        if (ffmpegComponentName) {
+            ALOGV("override compoent %s to %s for video frame extraction.", componentName, ffmpegComponentName);
+            componentName = ffmpegComponentName;
+        }
+
         VideoFrame *frame =
             extractVideoFrame(componentName, trackMeta, source, timeUs, option);
 
-- 
2.7.4


From d7e73a72848ddfd8852beb9161c5dc49feff5d5f Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Wed, 16 Dec 2015 12:02:04 -0800
Subject: [PATCH 073/119] stagefright: Fix some aac file cannot be played back

The AACExtractor does not pass the aacprofile via
kKeyAACAOT and google aac decoder does not support LTP profile.
Solve by setting the kKeyAACAOT profile and use ffmpeg
when it is aac LTP profile.

Change-Id: I79762bd23e3bcc34f2ea56e35686162f1630c06b
---
 media/libstagefright/AACExtractor.cpp    | 1 +
 media/libstagefright/FFMPEGSoftCodec.cpp | 8 ++++----
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/media/libstagefright/AACExtractor.cpp b/media/libstagefright/AACExtractor.cpp
index 1353e3f..2115eb4 100644
--- a/media/libstagefright/AACExtractor.cpp
+++ b/media/libstagefright/AACExtractor.cpp
@@ -167,6 +167,7 @@ AACExtractor::AACExtractor(
     channel = (header[0] & 0x1) << 2 | (header[1] >> 6);
 
     mMeta = MakeAACCodecSpecificData(profile, sf_index, channel);
+    mMeta->setInt32(kKeyAACAOT, profile + 1);
 
     off64_t streamSize, numFrames = 0;
     size_t frameSize = 0;
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index f0ca563..7fdbb2c 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -217,8 +217,8 @@ const char* FFMPEGSoftCodec::overrideComponentName(
     int32_t aacProfile = 0;
     if (!isEncoder && !strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC, strlen(MEDIA_MIMETYPE_AUDIO_AAC)) &&
             meta->findInt32(kKeyAACAOT, &aacProfile)) {
-        if (aacProfile == OMX_AUDIO_AACObjectMain) {
-            ALOGD("Use FFMPEG for AAC MAIN profile");
+        if ((aacProfile == OMX_AUDIO_AACObjectMain) || (aacProfile == OMX_AUDIO_AACObjectLTP)) {
+            ALOGD("Use FFMPEG for AAC Main/LTP profile");
             componentName = "OMX.ffmpeg.aac.decoder";
         }
     }
@@ -250,8 +250,8 @@ void FFMPEGSoftCodec::overrideComponentName(
     int32_t aacProfile = 0;
     if (!isEncoder && !strncasecmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_AAC, strlen(MEDIA_MIMETYPE_AUDIO_AAC)) &&
             msg->findInt32(getMsgKey(kKeyAACAOT), &aacProfile)) {
-        if (aacProfile == OMX_AUDIO_AACObjectMain) {
-            ALOGD("Use FFMPEG for AAC MAIN profile");
+        if ((aacProfile == OMX_AUDIO_AACObjectMain) || (aacProfile == OMX_AUDIO_AACObjectLTP)) {
+            ALOGD("Use FFMPEG for AAC Main/LTP profile");
             componentName->setTo("OMX.ffmpeg.aac.decoder");
         }
     }
-- 
2.7.4


From 7e9346fe41bbf2e30478e87adfbec0f83e2d2bd0 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 17 Dec 2015 15:18:04 -0500
Subject: [PATCH 074/119] nuplayer: Error checks for PCM format extensions

Change-Id: Ie9a3a8c335611d11c84bf24cb50c73c1644ad381
---
 .../mediaplayerservice/AVNuUtils.cpp               | 24 +++++++++++++---------
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |  2 +-
 2 files changed, 15 insertions(+), 11 deletions(-)

diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index 7bf68ea..77ace83 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -202,7 +202,8 @@ bool AVNuUtils::isVorbisFormat(const sp<MetaData> &) {
 int AVNuUtils::updateAudioBitWidth(audio_format_t audioFormat,
         const sp<AMessage> &format){
     int bits = 16;
-    if (audio_is_linear_pcm(audioFormat) || audio_is_offload_pcm(audioFormat)) {
+    if (format.get() &&
+            (audio_is_linear_pcm(audioFormat) || audio_is_offload_pcm(audioFormat))) {
         bits = audio_bytes_per_sample(audioFormat) * 8;
         format->setInt32("bits-per-sample", bits);
     }
@@ -211,42 +212,45 @@ int AVNuUtils::updateAudioBitWidth(audio_format_t audioFormat,
 
 audio_format_t AVNuUtils::getKeyPCMFormat(const sp<MetaData> &meta) {
     audio_format_t pcmFormat = AUDIO_FORMAT_INVALID;
-    meta->findInt32('pfmt', (int32_t *)&pcmFormat);
+    if (meta.get())
+        meta->findInt32('pfmt', (int32_t *)&pcmFormat);
     return pcmFormat;
 }
 
 void AVNuUtils::setKeyPCMFormat(const sp<MetaData> &meta, audio_format_t audioFormat) {
-    if (meta != NULL && audio_is_linear_pcm(audioFormat))
+    if (meta.get() && audio_is_linear_pcm(audioFormat))
         meta->setInt32('pfmt', audioFormat);
 }
 
 audio_format_t AVNuUtils::getPCMFormat(const sp<AMessage> &format) {
     audio_format_t pcmFormat = AUDIO_FORMAT_INVALID;
-    format->findInt32("pcm-format", (int32_t *)&pcmFormat);
+    if (format.get())
+        format->findInt32("pcm-format", (int32_t *)&pcmFormat);
     return pcmFormat;
 }
 
 void AVNuUtils::setPCMFormat(const sp<AMessage> &format, audio_format_t audioFormat) {
-    if (audio_is_linear_pcm(audioFormat) || audio_is_offload_pcm(audioFormat))
+    if (format.get() &&
+            (audio_is_linear_pcm(audioFormat) || audio_is_offload_pcm(audioFormat)))
         format->setInt32("pcm-format", audioFormat);
 }
 
 void AVNuUtils::setSourcePCMFormat(const sp<MetaData> &audioMeta) {
-    if (!isRAWFormat(audioMeta))
+    if (!audioMeta.get() || !isRAWFormat(audioMeta))
         return;
 
     audio_format_t pcmFormat = getKeyPCMFormat(audioMeta);
-    ALOGI("setSourcePCMFormat fmt=%x", pcmFormat);
-    audioMeta->dumpToLog();
     if (pcmFormat == AUDIO_FORMAT_INVALID) {
         int32_t bits = 16;
         if (audioMeta->findInt32(kKeyBitsPerSample, &bits)) {
             if (bits == 8)
                 pcmFormat = AUDIO_FORMAT_PCM_8_BIT;
-            if (bits == 24)
+            else if (bits == 24)
                 pcmFormat = AUDIO_FORMAT_PCM_32_BIT;
-            if (bits == 32)
+            else if (bits == 32)
                 pcmFormat = AUDIO_FORMAT_PCM_FLOAT;
+            else
+                pcmFormat = AUDIO_FORMAT_PCM_16_BIT;
             setKeyPCMFormat(audioMeta, pcmFormat);
         }
     }
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index edaa658..c5a7b52 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -1369,7 +1369,7 @@ void NuPlayer::onStart(int64_t startPositionUs) {
     ALOGV("onStart");
     sp<MetaData> audioMeta = mSource->getFormatMeta(true /* audio */);
     AVNuUtils::get()->setSourcePCMFormat(audioMeta);
-    audioMeta->dumpToLog();
+
     audio_stream_type_t streamType = AUDIO_STREAM_MUSIC;
     if (mAudioSink != NULL) {
         streamType = mAudioSink->getAudioStreamType();
-- 
2.7.4


From 7e25cb8f7e0552bcee501401b34975fe6c5d5724 Mon Sep 17 00:00:00 2001
From: Ethan Chen <intervigil@gmail.com>
Date: Thu, 17 Dec 2015 15:25:26 -0800
Subject: [PATCH 075/119] media: Disable extra debug

Change-Id: I63b78d3cabf981111cf9eb3a2816805db7d105e1
---
 media/libavextensions/Android.mk | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
index 923257c..3d697da 100644
--- a/media/libavextensions/Android.mk
+++ b/media/libavextensions/Android.mk
@@ -29,7 +29,6 @@ ifeq ($(strip $(AUDIO_FEATURE_ENABLED_FLAC_OFFLOAD)),true)
 endif
 
 LOCAL_MODULE:= libavextensions
-LOCAL_CFLAGS += -DLOG_NDEBUG=0
 
 LOCAL_MODULE_TAGS := optional
 
@@ -58,7 +57,6 @@ ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
 endif
 
 LOCAL_MODULE:= libavmediaextentions
-LOCAL_CFLAGS += -DLOG_NDEBUG=0
 
 LOCAL_MODULE_TAGS := optional
 
@@ -97,7 +95,6 @@ ifeq ($(TARGET_BOARD_PLATFORM),msm8974)
 endif
 
 LOCAL_MODULE:= libavmediaserviceextensions
-LOCAL_CFLAGS += -DLOG_NDEBUG=0
 
 LOCAL_MODULE_TAGS := optional
 
-- 
2.7.4


From f0151a8ffa0048ad7503f8de69db1ff3539c4c38 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Thu, 17 Dec 2015 15:16:03 -0500
Subject: [PATCH 076/119] nuplayer: Fix priority inversion

 * Found using "perf sched latency"

Change-Id: I358a6f9baf3d52b9ed7f010c06893dbf839e1973
---
 media/libmediaplayerservice/nuplayer/GenericSource.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libmediaplayerservice/nuplayer/GenericSource.cpp b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
index f40ad7e..f6a4707 100644
--- a/media/libmediaplayerservice/nuplayer/GenericSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
@@ -367,7 +367,7 @@ void NuPlayer::GenericSource::prepareAsync() {
     if (mLooper == NULL) {
         mLooper = new ALooper;
         mLooper->setName("generic");
-        mLooper->start();
+        mLooper->start(false, false, PRIORITY_AUDIO);
 
         mLooper->registerHandler(this);
     }
-- 
2.7.4


From 3aaaa3e7603d87cc8a2dda9fa53f3382699bcd7b Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sun, 20 Dec 2015 23:19:52 -0500
Subject: [PATCH 077/119] stagefright: Fix AAC profile selection

 * Be consistent about AAC profile selection in both Stagefright an
   our custom plugin.
 * Also fix duplication in the override code.

Change-Id: I9d2724ea8861bc9d7db6a100a2f633f81d243c6c
---
 media/libstagefright/AACExtractor.cpp    |  2 +-
 media/libstagefright/FFMPEGSoftCodec.cpp | 49 ++++++++++++++------------------
 2 files changed, 23 insertions(+), 28 deletions(-)

diff --git a/media/libstagefright/AACExtractor.cpp b/media/libstagefright/AACExtractor.cpp
index 2115eb4..1764541 100644
--- a/media/libstagefright/AACExtractor.cpp
+++ b/media/libstagefright/AACExtractor.cpp
@@ -167,7 +167,7 @@ AACExtractor::AACExtractor(
     channel = (header[0] & 0x1) << 2 | (header[1] >> 6);
 
     mMeta = MakeAACCodecSpecificData(profile, sf_index, channel);
-    mMeta->setInt32(kKeyAACAOT, profile + 1);
+    mMeta->setInt32(kKeyAACAOT, profile);
 
     off64_t streamSize, numFrames = 0;
     size_t frameSize = 0;
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 7fdbb2c..20c8359 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -223,37 +223,32 @@ const char* FFMPEGSoftCodec::overrideComponentName(
         }
     }
 
-    return componentName;
-}
-
-void FFMPEGSoftCodec::overrideComponentName(
-        uint32_t /*quirks*/, const sp<AMessage> &msg, AString* componentName, AString* mime, int32_t isEncoder) {
-
-    int32_t wmvVersion = 0;
-    if (!strncasecmp(mime->c_str(), MEDIA_MIMETYPE_VIDEO_WMV, strlen(MEDIA_MIMETYPE_VIDEO_WMV)) &&
-            msg->findInt32(getMsgKey(kKeyWMVVersion), &wmvVersion)) {
-        ALOGD("Found WMV version key %d", wmvVersion);
-        if (wmvVersion == 1) {
-            ALOGD("Use FFMPEG for unsupported WMV track");
-            componentName->setTo("OMX.ffmpeg.wmv.decoder");
+    // Use FFMPEG for high-res formats which other decoders can't handle
+    int32_t bits = 16;
+    if (!isEncoder && meta->findInt32(kKeyBitsPerSample, &bits)) {
+        if (bits > 16) {
+            if (!strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC, strlen(MEDIA_MIMETYPE_AUDIO_AAC))) {
+                componentName = "OMX.ffmpeg.aac.decoder";
+                ALOGD("Use FFMPEG for high-res AAC format");
+            } else if (!strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC, strlen(MEDIA_MIMETYPE_AUDIO_FLAC))) {
+                componentName = "OMX.ffmpeg.flac.decoder";
+                ALOGD("Use FFMPEG for high-res FLAC format");
+            }
         }
     }
 
-    int32_t encodeOptions = 0;
-    if (!isEncoder && !strncasecmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_WMA, strlen(MEDIA_MIMETYPE_AUDIO_WMA)) &&
-            !msg->findInt32(getMsgKey(kKeyWMAEncodeOpt), &encodeOptions)) {
-        ALOGD("Use FFMPEG for unsupported WMA track");
-        componentName->setTo("OMX.ffmpeg.wma.decoder");
-    }
+    return componentName;
+}
 
-    // Google's decoder doesn't support MAIN profile
-    int32_t aacProfile = 0;
-    if (!isEncoder && !strncasecmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_AAC, strlen(MEDIA_MIMETYPE_AUDIO_AAC)) &&
-            msg->findInt32(getMsgKey(kKeyAACAOT), &aacProfile)) {
-        if ((aacProfile == OMX_AUDIO_AACObjectMain) || (aacProfile == OMX_AUDIO_AACObjectLTP)) {
-            ALOGD("Use FFMPEG for AAC Main/LTP profile");
-            componentName->setTo("OMX.ffmpeg.aac.decoder");
-        }
+void FFMPEGSoftCodec::overrideComponentName(
+        uint32_t quirks, const sp<AMessage> &msg, AString* componentName, AString* mime, int32_t isEncoder) {
+
+    sp<MetaData> meta = new MetaData;
+    convertMessageToMetaData(msg, meta);
+    const char *updated = overrideComponentName(
+                quirks, meta, mime->c_str(), isEncoder);
+    if (updated != NULL) {
+        componentName->setTo(updated);
     }
 }
 
-- 
2.7.4


From 3169cb71e36d1c9fb8aabf0d3864fb447f3511dd Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 21 Dec 2015 05:13:15 -0500
Subject: [PATCH 078/119] stagefright: Deal with output format of other AAC
 decoders

 * Pass the bits-per-sample value when setting up the raw PCM
   output in case FFMPEG is decoding as it will produce floats.

Change-Id: If5a8cc43a1c41e522324e77871823c9084f92169
---
 include/media/stagefright/ACodec.h |  2 +-
 media/libstagefright/ACodec.cpp    | 11 +++++++----
 2 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index f4b0710..d27202f 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -367,7 +367,7 @@ protected:
             int32_t numChannels, int32_t sampleRate, int32_t bitRate,
             int32_t aacProfile, bool isADTS, int32_t sbrMode,
             int32_t maxOutputChannelCount, const drcParams_t& drc,
-            int32_t pcmLimiterEnable);
+            int32_t pcmLimiterEnable, int32_t bitsPerSample = 16);
 
     status_t setupAC3Codec(bool encoder, int32_t numChannels, int32_t sampleRate,
             int32_t bitsPerSample = 16);
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 31f1d76..a7a5ed0 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -2153,6 +2153,7 @@ status_t ACodec::configureCodec(
             int32_t sbrMode;
             int32_t maxOutputChannelCount;
             int32_t pcmLimiterEnable;
+            int32_t bitsPerSample = 16;
             drcParams_t drc;
             if (!msg->findInt32("is-adts", &isADTS)) {
                 isADTS = 0;
@@ -2191,11 +2192,12 @@ status_t ACodec::configureCodec(
                 // value is unknown
                 drc.targetRefLevel = -1;
             }
+            msg->findInt32("bits-per-sample", &bitsPerSample);
 
             err = setupAACCodec(
                     encoder, numChannels, sampleRate, bitRate, aacProfile,
                     isADTS != 0, sbrMode, maxOutputChannelCount, drc,
-                    pcmLimiterEnable);
+                    pcmLimiterEnable, bitsPerSample);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)) {
         err = setupAMRCodec(encoder, false /* isWAMR */, bitRate);
@@ -2455,15 +2457,16 @@ status_t ACodec::setupAACCodec(
         bool encoder, int32_t numChannels, int32_t sampleRate,
         int32_t bitRate, int32_t aacProfile, bool isADTS, int32_t sbrMode,
         int32_t maxOutputChannelCount, const drcParams_t& drc,
-        int32_t pcmLimiterEnable) {
+        int32_t pcmLimiterEnable, int32_t bitsPerSample) {
     if (encoder && isADTS) {
         return -EINVAL;
     }
 
-    status_t err = setupRawAudioFormat(
+    status_t err = setupRawAudioFormatInternal(
             encoder ? kPortIndexInput : kPortIndexOutput,
             sampleRate,
-            numChannels);
+            numChannels,
+            bitsPerSample);
 
     if (err != OK) {
         return err;
-- 
2.7.4


From f0da2d4741f314d23c4fd452f597a0e485f96cbf Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 21 Dec 2015 05:15:04 -0500
Subject: [PATCH 079/119] stagefright: Correctly reassemble HVCC data

 * Remove bogus code and replace with proper reassembly.

Change-Id: I16a84eb94e5535fc2c4044875144f8007852a4d2
---
 media/libavextensions/stagefright/AVUtils.cpp | 56 +++------------------------
 1 file changed, 6 insertions(+), 50 deletions(-)

diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index fe2c519..bc43338 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -387,59 +387,15 @@ bool AVUtils::HEVCMuxer::reassembleHEVCCSD(const AString &mime, sp<ABuffer> csd0
     if (!isVideoHEVC(mime.c_str())) {
         return false;
     }
-    uint32_t type;
-    const void *data;
-    size_t size;
-    if (meta->findData(kKeyHVCC, &type, &data, &size)) {
-        const uint8_t *ptr = (const uint8_t *)data;
-
-        CHECK(size >= 7);
-        uint8_t profile = ptr[1] & 31;
-        uint8_t level = ptr[12];
-        ptr += 22;
-        size -= 22;
-
-
-        size_t numofArrays = (char)ptr[0];
-        ptr += 1;
-        size -= 1;
-        size_t j = 0, i = 0;
-
-        csd0->setRange(0, 0);
-
-        for (i = 0; i < numofArrays; i++) {
-            ptr += 1;
-            size -= 1;
+    void *csd = NULL;
+    size_t size = 0;
 
-            //Num of nals
-            size_t numofNals = U16_AT(ptr);
-
-            ptr += 2;
-            size -= 2;
-
-            for (j = 0; j < numofNals; j++) {
-                CHECK(size >= 2);
-                size_t length = U16_AT(ptr);
-
-                ptr += 2;
-                size -= 2;
-
-                if (size < length) {
-                    return false;
-                }
-                status_t err = copyNALUToABuffer(&csd0, ptr, length);
-                if (err != OK) {
-                    return false;
-                }
-
-                ptr += length;
-                size -= length;
-            }
-        }
-        csd0->meta()->setInt32("csd", true);
-        csd0->meta()->setInt64("timeUs", 0);
+    if (makeHEVCCodecSpecificData(csd0->data(), csd0->size(), &csd, &size) == OK) {
+        meta->setData(kKeyHVCC, kTypeHVCC, csd, size);
+        free(csd);
         return true;
     }
+    ALOGE("Failed to reassemble HVCC data");
     return false;
 }
 
-- 
2.7.4


From 76ede7ef85eb7bda9f96c1965da9490e768885b7 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Mon, 21 Dec 2015 09:27:38 -0800
Subject: [PATCH 080/119] stagefright: Fix audio profile retrieved

The aac audio profile retrieved from the AACExtractor
is ranged from 0-3.
However the corresponding OMX header definition
is from 1-4:
typedef enum OMX_AUDIO_AACPROFILETYPE{
...
OMX_AUDIO_AACObjectMain = 1,
OMX_AUDIO_AACObjectLC,
OMX_AUDIO_AACObjectSSR,
OMX_AUDIO_AACObjectLTP,
...

Change-Id: I1c8932abe19bff918acd5e4d8c2e39eaaac4f6c3
---
 media/libstagefright/AACExtractor.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/AACExtractor.cpp b/media/libstagefright/AACExtractor.cpp
index 1764541..2115eb4 100644
--- a/media/libstagefright/AACExtractor.cpp
+++ b/media/libstagefright/AACExtractor.cpp
@@ -167,7 +167,7 @@ AACExtractor::AACExtractor(
     channel = (header[0] & 0x1) << 2 | (header[1] >> 6);
 
     mMeta = MakeAACCodecSpecificData(profile, sf_index, channel);
-    mMeta->setInt32(kKeyAACAOT, profile);
+    mMeta->setInt32(kKeyAACAOT, profile + 1);
 
     off64_t streamSize, numFrames = 0;
     size_t frameSize = 0;
-- 
2.7.4


From 7207d82f423a87ff04955dc4a172d2852a6b97ed Mon Sep 17 00:00:00 2001
From: Niel Alejandro Paz <niel.paz.hernandez@intel.com>
Date: Mon, 15 Jun 2015 13:14:39 -0500
Subject: [PATCH 081/119] Validation of Number of Channels on WAV files.

Corrects the validation of the number of channels that was causing a floating
point exception when this number is zero.
It also corrects the range of admitted channels on WAV files.

Change-Id: I21f005d1f30c1fd93206c6bce0d3be4b8307059c
Signed-off-by: Niel Alejandro Paz <niel.paz.hernandez@intel.com>
Signed-off-by: Vineela Tummalapalli <vineela.tummalapalli@intel.com>
Signed-off-by: Zhiquan Liu <zhiquan.liu@intel.com>
---
 media/libstagefright/WAVExtractor.cpp | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/media/libstagefright/WAVExtractor.cpp b/media/libstagefright/WAVExtractor.cpp
index 16c16c1..62bb416 100644
--- a/media/libstagefright/WAVExtractor.cpp
+++ b/media/libstagefright/WAVExtractor.cpp
@@ -194,17 +194,17 @@ status_t WAVExtractor::init() {
             }
 
             mNumChannels = U16_LE_AT(&formatSpec[2]);
+
+            if (mNumChannels < 1 || mNumChannels > 8) {
+                ALOGE("Unsupported number of channels (%d)", mNumChannels);
+                return ERROR_UNSUPPORTED;
+            }
+
             if (mWaveFormat != WAVE_FORMAT_EXTENSIBLE) {
-                if (mNumChannels == 0) {
-                    return ERROR_UNSUPPORTED;
-                } else if (mNumChannels != 1 && mNumChannels != 2) {
+                if (mNumChannels != 1 && mNumChannels != 2) {
                     ALOGW("More than 2 channels (%d) in non-WAVE_EXT, unknown channel mask",
                             mNumChannels);
                 }
-            } else {
-                if (mNumChannels < 1 || mNumChannels > 8) {
-                    return ERROR_UNSUPPORTED;
-                }
             }
 
             mSampleRate = U32_LE_AT(&formatSpec[4]);
-- 
2.7.4


From ec9c7f4d8588b2eb1282de26375298ccb23bed06 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 26 Dec 2015 16:52:22 -0800
Subject: [PATCH 082/119] stagefright: Copy the thumbnail time

 * In case we do a conversion, we need this to seek the extractor
   to the right position for extracting a thumbnail.

Change-Id: I003a599c15890aeeb6d2494b219f170ba5b278d8
---
 media/libstagefright/FFMPEGSoftCodec.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 20c8359..9d72609 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -74,6 +74,7 @@ static const MetaKeyEntry MetaKeyTable[] {
    {kKeyWMVVersion           , "wmv-version"            , INT32},
    {kKeyPCMFormat            , "pcm-format"             , INT32},
    {kKeyDivXVersion          , "divx-version"           , INT32},
+   {kKeyThumbnailTime        , "thumbnail-time"         , INT64},
 };
 
 const char* FFMPEGSoftCodec::getMsgKey(int key) {
-- 
2.7.4


From 36010a87e942ff57d65f302ffe202bc9c1979c82 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 26 Dec 2015 16:57:16 -0800
Subject: [PATCH 083/119] stagefright: Remove special case for FLAC offload

 * FFMPEG will now handle this automatically. Remove the workaround.

Change-Id: I7007af16ce1fe43358b9c1e3b3b469b717df0100
---
 media/libstagefright/DataSource.cpp     |  2 --
 media/libstagefright/FLACExtractor.cpp  | 11 -----------
 media/libstagefright/MediaExtractor.cpp |  2 --
 3 files changed, 15 deletions(-)

diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index f32bb7e..8b49d18 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -232,9 +232,7 @@ void DataSource::RegisterDefaultSniffers() {
     RegisterSniffer_l(SniffMatroska);
     RegisterSniffer_l(SniffOgg);
     RegisterSniffer_l(SniffWAV);
-#ifndef FLAC_OFFLOAD_ENABLED
     RegisterSniffer_l(SniffFLAC);
-#endif
     RegisterSniffer_l(SniffAMR);
     RegisterSniffer_l(SniffMPEG2TS);
     RegisterSniffer_l(SniffMP3);
diff --git a/media/libstagefright/FLACExtractor.cpp b/media/libstagefright/FLACExtractor.cpp
index 51a502d..55ce566 100644
--- a/media/libstagefright/FLACExtractor.cpp
+++ b/media/libstagefright/FLACExtractor.cpp
@@ -32,11 +32,6 @@
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MediaBuffer.h>
 
-#ifdef FLAC_OFFLOAD_ENABLED
-#include "QCMediaDefs.h"
-#include "QCMetaData.h"
-#endif
-
 #include <system/audio.h>
 
 namespace android {
@@ -553,12 +548,6 @@ status_t FLACParser::init()
             mTrackMetadata->setInt64(kKeyDuration,
                     (getTotalSamples() * 1000000LL) / getSampleRate());
             mTrackMetadata->setInt32(kKeyBitsPerSample, getBitsPerSample());
-#ifdef FLAC_OFFLOAD_ENABLED
-            mTrackMetadata->setInt32(kKeyMinBlkSize, getMinBlockSize());
-            mTrackMetadata->setInt32(kKeyMaxBlkSize, getMaxBlockSize());
-            mTrackMetadata->setInt32(kKeyMinFrmSize, getMinFrameSize());
-            mTrackMetadata->setInt32(kKeyMaxFrmSize, getMaxFrameSize());
-#endif
         }
     } else {
         ALOGE("missing STREAMINFO");
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index cd0acfa..fc96e2f 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -117,10 +117,8 @@ retry:
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)
             || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) {
         ret = new AMRExtractor(source);
-#ifndef FLAC_OFFLOAD_ENABLED
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
         ret = new FLACExtractor(source);
-#endif
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) {
         ret = new WAVExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) {
-- 
2.7.4


From da9ecbe876eb0efa6cb87b4d3df89d0f2532a427 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 26 Dec 2015 22:07:56 -0800
Subject: [PATCH 084/119] stagefright: Add more hardware codec support for our
 extractor

 * Additional cases for timestamp reordering (smooth out AVI playback)
 * Enable hardware thumbnailer

Change-Id: If828181850a5627dc1f91b118974905d22ab24e9
---
 include/media/stagefright/FFMPEGSoftCodec.h |   1 +
 media/libstagefright/ACodec.cpp             |  18 ++--
 media/libstagefright/FFMPEGSoftCodec.cpp    | 127 +++++++++++++++++++---------
 3 files changed, 96 insertions(+), 50 deletions(-)

diff --git a/include/media/stagefright/FFMPEGSoftCodec.h b/include/media/stagefright/FFMPEGSoftCodec.h
index 79ea229..c6b6482 100644
--- a/include/media/stagefright/FFMPEGSoftCodec.h
+++ b/include/media/stagefright/FFMPEGSoftCodec.h
@@ -60,6 +60,7 @@ struct FFMPEGSoftCodec {
             sp<IOMX> OMXhandle, IOMX::node_id nodeID);
 
     static status_t setVideoFormat(
+            status_t status,
             const sp<AMessage> &msg, const char* mime,
             sp<IOMX> OMXhandle,IOMX::node_id nodeID,
             bool isEncoder, OMX_VIDEO_CODINGTYPE *compressionFormat,
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index a7a5ed0..5f1761b 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -3055,13 +3055,11 @@ status_t ACodec::setupVideoDecoder(
     OMX_VIDEO_CODINGTYPE compressionFormat;
     status_t err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
-    if (err != OK) {
-        err = FFMPEGSoftCodec::setVideoFormat(
+    err = FFMPEGSoftCodec::setVideoFormat(err,
                     msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat,
                     mComponentName.c_str());
-        if (err != OK) {
-            return err;
-        }
+    if (err != OK) {
+        return err;
     }
 
     err = setVideoPortFormatType(
@@ -3210,14 +3208,12 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
     OMX_VIDEO_CODINGTYPE compressionFormat;
     err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
-    if (err != OK) {
-        err = FFMPEGSoftCodec::setVideoFormat(
+    err = FFMPEGSoftCodec::setVideoFormat(err,
                 msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat,
                 mComponentName.c_str());
-        if (err != OK) {
-            ALOGE("Not a supported video mime type: %s", mime);
-            return err;
-        }
+    if (err != OK) {
+        ALOGE("Not a supported video mime type: %s", mime);
+        return err;
     }
 
     err = setVideoPortFormatType(
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 9d72609..26afd89 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -254,56 +254,63 @@ void FFMPEGSoftCodec::overrideComponentName(
 }
 
 status_t FFMPEGSoftCodec::setVideoFormat(
+        status_t status,
         const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
         IOMX::node_id nodeID, bool isEncoder,
         OMX_VIDEO_CODINGTYPE *compressionFormat,
         const char* componentName) {
     status_t err = OK;
 
-    if (isEncoder) {
-        ALOGE("Encoding not supported");
-        err = BAD_VALUE;
-    
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)) {
-        if (strncmp(componentName, "OMX.ffmpeg.", 11) == 0) {
-            err = setWMVFormat(msg, OMXhandle, nodeID);
+    //ALOGD("setVideoFormat: %s", msg->debugString(0).c_str());
+
+    /* status passed in is the result of the normal codec lookup */
+    if (status != OK) {
+
+        if (isEncoder) {
+            ALOGE("Encoding not supported");
+            err = BAD_VALUE;
+
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)) {
+            if (strncmp(componentName, "OMX.ffmpeg.", 11) == 0) {
+                err = setWMVFormat(msg, OMXhandle, nodeID);
+                if (err != OK) {
+                    ALOGE("setWMVFormat() failed (err = %d)", err);
+                }
+            }
+            *compressionFormat = OMX_VIDEO_CodingWMV;
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_RV, mime)) {
+            err = setRVFormat(msg, OMXhandle, nodeID);
             if (err != OK) {
-                ALOGE("setWMVFormat() failed (err = %d)", err);
+                ALOGE("setRVFormat() failed (err = %d)", err);
+            } else {
+                *compressionFormat = OMX_VIDEO_CodingRV;
             }
-        }
-        *compressionFormat = OMX_VIDEO_CodingWMV;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_RV, mime)) {
-        err = setRVFormat(msg, OMXhandle, nodeID);
-        if (err != OK) {
-            ALOGE("setRVFormat() failed (err = %d)", err);
-        } else {
-            *compressionFormat = OMX_VIDEO_CodingRV;
-        }
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VC1, mime)) {
-        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVC1;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FLV1, mime)) {
-        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingFLV1;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
-        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VC1, mime)) {
+            *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVC1;
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FLV1, mime)) {
+            *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingFLV1;
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
+            *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
 #ifdef QCOM_HARDWARE
-    // compressionFormat will be override later
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)) {
-        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
-        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+        // compressionFormat will be override later
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)) {
+            *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+            *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
 #endif
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
-        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingHEVC;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FFMPEG, mime)) {
-        ALOGV("Setting the OMX_VIDEO_PARAM_FFMPEGTYPE params");
-        err = setFFmpegVideoFormat(msg, OMXhandle, nodeID);
-        if (err != OK) {
-            ALOGE("setFFmpegVideoFormat() failed (err = %d)", err);
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
+            *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingHEVC;
+        } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FFMPEG, mime)) {
+            ALOGV("Setting the OMX_VIDEO_PARAM_FFMPEGTYPE params");
+            err = setFFmpegVideoFormat(msg, OMXhandle, nodeID);
+            if (err != OK) {
+                ALOGE("setFFmpegVideoFormat() failed (err = %d)", err);
+            } else {
+                *compressionFormat = OMX_VIDEO_CodingAutoDetect;
+            }
         } else {
-            *compressionFormat = OMX_VIDEO_CodingAutoDetect;
+            err = BAD_TYPE;
         }
-    } else {
-        err = BAD_TYPE;
     }
 
 #ifdef QCOM_HARDWARE
@@ -312,7 +319,7 @@ status_t FFMPEGSoftCodec::setVideoFormat(
     // from the CAF L release. It was unfortunately moved to a proprietary
     // blob and an architecture which is hellish for OEMs who wish to
     // customize the platform.
-    if (err != BAD_TYPE && (!strncmp(componentName, "OMX.qcom.", 9))) {
+    if (err == OK && (!strncmp(componentName, "OMX.qcom.", 9))) {
         status_t xerr = OK;
 
 
@@ -344,13 +351,29 @@ status_t FFMPEGSoftCodec::setVideoFormat(
 
         // Enable timestamp reordering for mpeg4 and vc1 codec types, the AVI file
         // type, and hevc content in the ts container
+        AString container;
+        const char * containerStr = NULL;
+        if (msg->findString("file-format", &container)) {
+            containerStr = container.c_str();
+        }
+
         bool tsReorder = false;
         const char* roleVC1 = "OMX.qcom.video.decoder.vc1";
         const char* roleMPEG4 = "OMX.qcom.video.decoder.mpeg4";
+        const char* roleHEVC = "OMX.qcom.video.decoder.hevc";
         if (!strncmp(componentName, roleVC1, strlen(roleVC1)) ||
                 !strncmp(componentName, roleMPEG4, strlen(roleMPEG4))) {
             // The codec requires timestamp reordering
             tsReorder = true;
+        } else if (containerStr != NULL) {
+            if (!strncmp(containerStr, MEDIA_MIMETYPE_CONTAINER_AVI,
+                    strlen(MEDIA_MIMETYPE_CONTAINER_AVI))) {
+                tsReorder = true;
+            } else if (!strncmp(containerStr, MEDIA_MIMETYPE_CONTAINER_MPEG2TS,
+                        strlen(MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) ||
+                       !strncmp(componentName, roleHEVC, strlen(roleHEVC))) {
+                tsReorder = true;
+            }
         }
 
         if (tsReorder) {
@@ -368,6 +391,32 @@ status_t FFMPEGSoftCodec::setVideoFormat(
             }
         }
 
+        // Enable Sync-frame decode mode for thumbnails
+        int32_t thumbnailMode = 0;
+        if (msg->findInt32("thumbnail-mode", &thumbnailMode) &&
+                thumbnailMode > 0) {
+            ALOGV("Enabling thumbnail mode.");
+            QOMX_ENABLETYPE enableType;
+            OMX_INDEXTYPE indexType;
+
+            status_t err = OMXhandle->getExtensionIndex(
+                    nodeID, OMX_QCOM_INDEX_PARAM_VIDEO_SYNCFRAMEDECODINGMODE,
+                    &indexType);
+            if (err != OK) {
+                ALOGW("Failed to get extension for SYNCFRAMEDECODINGMODE");
+            } else {
+
+                enableType.bEnable = OMX_TRUE;
+                err = OMXhandle->setParameter(nodeID,indexType,
+                           (void *)&enableType, sizeof(enableType));
+                if (err != OK) {
+                    ALOGW("Failed to get extension for SYNCFRAMEDECODINGMODE");
+                } else {
+                    ALOGI("Thumbnail mode enabled.");
+                }
+            }
+        }
+
         // MediaCodec clients can request decoder extradata by setting
         // "enable-extradata-<type>" in MediaFormat.
         // Following <type>s are supported:
-- 
2.7.4


From c986345f6a0950e3b2a179ac637c3a8673d5dfa3 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sat, 26 Dec 2015 17:02:29 -0800
Subject: [PATCH 085/119] stagefright: Remove special handling of FFMPEG
 extractor

 * Extractor now checks if Stagefright already reported a high
   confidence level. Treat it as a first class citizen.

Change-Id: Id41af84a0f9f9c51df4602f283776b5d19bf666b
---
 media/libstagefright/DataSource.cpp     | 35 ++-------------------------------
 media/libstagefright/MediaExtractor.cpp | 20 +++----------------
 2 files changed, 5 insertions(+), 50 deletions(-)

diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 8b49d18..3d8688f 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -131,19 +131,11 @@ status_t DataSource::getSize(off64_t *size) {
 
 Mutex DataSource::gSnifferMutex;
 List<DataSource::SnifferFunc> DataSource::gSniffers;
-List<DataSource::SnifferFunc> DataSource::gExtraSniffers;
 bool DataSource::gSniffersRegistered = false;
 
 bool DataSource::sniff(
         String8 *mimeType, float *confidence, sp<AMessage> *meta) {
 
-    bool forceExtraSniffers = false;
-
-    if (*confidence == 3.14f) {
-       // Magic value, as set by MediaExtractor when a video container looks incomplete
-       forceExtraSniffers = true;
-    }
-
     *mimeType = "";
     *confidence = 0.0f;
     meta->clear();
@@ -169,23 +161,6 @@ bool DataSource::sniff(
         }
     }
 
-    /* Only do the deeper sniffers if the results are null or in doubt */
-    if (mimeType->length() == 0 || *confidence < 0.21f || forceExtraSniffers) {
-        for (List<SnifferFunc>::iterator it = gExtraSniffers.begin();
-                it != gExtraSniffers.end(); ++it) {
-            String8 newMimeType;
-            float newConfidence;
-            sp<AMessage> newMeta;
-            if ((*it)(this, &newMimeType, &newConfidence, &newMeta)) {
-                if (newConfidence > *confidence) {
-                    *mimeType = newMimeType;
-                    *confidence = newConfidence;
-                    *meta = newMeta;
-                }
-            }
-        }
-    }
-
     return *confidence > 0.0;
 }
 
@@ -210,14 +185,7 @@ void DataSource::RegisterSnifferPlugin() {
         getExtractorPlugin(plugin);
     }
     if (plugin->sniff) {
-        for (List<SnifferFunc>::iterator it = gExtraSniffers.begin();
-             it != gExtraSniffers.end(); ++it) {
-            if (*it == plugin->sniff) {
-                return;
-            }
-        }
-
-        gExtraSniffers.push_back(plugin->sniff);
+        RegisterSniffer_l(plugin->sniff);
     }
 }
 
@@ -248,6 +216,7 @@ void DataSource::RegisterDefaultSniffers() {
             && (!strcmp(value, "1") || !strcasecmp(value, "true"))) {
         RegisterSniffer_l(SniffDRM);
     }
+
     gSniffersRegistered = true;
 }
 
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index fc96e2f..ef0524a 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -60,15 +60,9 @@ sp<MediaExtractor> MediaExtractor::Create(
         const uint32_t flags) {
     sp<AMessage> meta;
 
-    bool secondPass = false;
-
     String8 tmp;
-retry:
-    if (secondPass || mime == NULL) {
+    if (mime == NULL) {
         float confidence;
-        if (secondPass) {
-            confidence = 3.14f;
-        }
         if (!source->sniff(&tmp, &confidence, &meta)) {
             ALOGV("FAILED to autodetect media content.");
 
@@ -102,9 +96,10 @@ retry:
         }
     }
 
-    sp<MediaExtractor> ret = NULL;
+    sp<MediaExtractor> ret;
     AString extractorName;
     if ((ret = AVFactory::get()->createExtendedExtractor(source, mime, meta, flags)) != NULL) {
+        ALOGI("Using extended extractor");
     } else if (meta.get() && meta->findString("extended-extractor-use", &extractorName)
             && sPlugin.create) {
         ALOGI("Use extended extractor for the special mime(%s) or codec", mime);
@@ -149,15 +144,6 @@ retry:
        }
     }
 
-    if (ret != NULL) {
-
-        if (!secondPass && ( ret->countTracks() == 0 ||
-                    (!strncasecmp("video/", mime, 6) && ret->countTracks() < 2) ) ) {
-            secondPass = true;
-            goto retry;
-        }
-    }
-
     return ret;
 }
 
-- 
2.7.4


From f8fd2e1df958a991c65c23c9b4aa6d6bac75409b Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 28 Dec 2015 01:59:36 -0800
Subject: [PATCH 086/119] nuplayer: Pass along the sniffed metadata from
 GenericSource

 * When the extended sniffer detects a file type that only it can
   handle, it will set a flag in the metadata. In some cases,
   an extractor exists in Android already for the filetype however
   it may be known to fail or we may want different behavior.
 * This flag is checked in MediaExtractor, but GenericSource does
   a little dance in order to stack DataSources for DRM and was
   throwing out this metadata (it's not really used by AOSP), so
   the desired behavior was not seen for some cases.
 * Add a new optional argument when creating the MediaExtractor to
   pass in the metadata from the original sniff so that the extended
   extractor is used where necessary for streaming formats.
 * This fixes FLAC offload with Tidal.

Change-Id: I7d6b875346ce63b60cd3c37572b779665bfe217c
---
 include/media/stagefright/MediaExtractor.h             | 2 +-
 media/libmediaplayerservice/nuplayer/GenericSource.cpp | 8 ++++----
 media/libstagefright/MediaExtractor.cpp                | 5 ++++-
 3 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/include/media/stagefright/MediaExtractor.h b/include/media/stagefright/MediaExtractor.h
index 2f2057f..e83defa 100644
--- a/include/media/stagefright/MediaExtractor.h
+++ b/include/media/stagefright/MediaExtractor.h
@@ -42,7 +42,7 @@ public:
 
     static sp<MediaExtractor> Create(
             const sp<DataSource> &source, const char *mime = NULL,
-            const uint32_t flags = 0);
+            const uint32_t flags = 0, const sp<AMessage> *meta = NULL);
 
     virtual size_t countTracks() = 0;
     virtual sp<MediaSource> getTrack(size_t index) = 0;
diff --git a/media/libmediaplayerservice/nuplayer/GenericSource.cpp b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
index f6a4707..949c12f 100644
--- a/media/libmediaplayerservice/nuplayer/GenericSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/GenericSource.cpp
@@ -141,14 +141,14 @@ status_t NuPlayer::GenericSource::initFromDataSource() {
     sp<MediaExtractor> extractor;
     String8 mimeType;
     float confidence;
-    sp<AMessage> dummy;
+    sp<AMessage> meta;
     bool isWidevineStreaming = false;
 
     CHECK(mDataSource != NULL);
 
     if (mIsWidevine) {
         isWidevineStreaming = SniffWVM(
-                mDataSource, &mimeType, &confidence, &dummy);
+                mDataSource, &mimeType, &confidence, &meta);
         if (!isWidevineStreaming ||
                 strcasecmp(
                     mimeType.string(), MEDIA_MIMETYPE_CONTAINER_WVM)) {
@@ -161,7 +161,7 @@ status_t NuPlayer::GenericSource::initFromDataSource() {
             Mutex::Autolock _l(mSourceLock);
             dataSource = mDataSource;
         }
-        if (!dataSource->sniff(&mimeType, &confidence, &dummy)) {
+        if (!dataSource->sniff(&mimeType, &confidence, &meta)) {
             return UNKNOWN_ERROR;
         }
         isWidevineStreaming = !strcasecmp(
@@ -186,7 +186,7 @@ status_t NuPlayer::GenericSource::initFromDataSource() {
 #endif
         extractor = MediaExtractor::Create(mDataSource,
                 mimeType.isEmpty() ? NULL : mimeType.string(),
-                mIsStreaming ? 0 : flags);
+                mIsStreaming ? 0 : flags, &meta);
     }
 
     if (extractor == NULL) {
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index ef0524a..ac6decd 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -57,7 +57,8 @@ uint32_t MediaExtractor::flags() const {
 // static
 sp<MediaExtractor> MediaExtractor::Create(
         const sp<DataSource> &source, const char *mime,
-        const uint32_t flags) {
+        const uint32_t flags, const sp<AMessage> *prevMeta) {
+
     sp<AMessage> meta;
 
     String8 tmp;
@@ -72,6 +73,8 @@ sp<MediaExtractor> MediaExtractor::Create(
         mime = tmp.string();
         ALOGV("Autodetected media content as '%s' with confidence %.2f",
              mime, confidence);
+    } else if (prevMeta != NULL) {
+        meta = *prevMeta;
     }
 
     bool isDrm = false;
-- 
2.7.4


From 5db63235640a7344be58d3d8340c7994b4223642 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 28 Dec 2015 13:08:26 -0800
Subject: [PATCH 087/119] stagefright: Those who cannot remember history are
 doomed to repeat it

 * A new sniffer might want to defer it's work based on the
   knowledge already gained by those who have already sniffed.
 * This is the case for our FFMPEG sniffer, which is pretty awesome
   in that it is able to fill in all the gaps and detect almost
   anything, however the cost is additional latency during scanning
   and startup.
 * As we cycle thru each sniffer, feed the current score to the next.
   It is up to the extractor to use this knowledge wisely.
 * Additionally, print some metrics on how long the sniff took.

Change-Id: I5dc8de11ed4939a01eabb0cae0b4e1e71d991eea
---
 media/libstagefright/DataSource.cpp     | 17 ++++++++++++++---
 media/libstagefright/MediaExtractor.cpp |  6 ++++--
 2 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 3d8688f..b833f9e 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -136,6 +136,7 @@ bool DataSource::gSniffersRegistered = false;
 bool DataSource::sniff(
         String8 *mimeType, float *confidence, sp<AMessage> *meta) {
 
+
     *mimeType = "";
     *confidence = 0.0f;
     meta->clear();
@@ -147,11 +148,18 @@ bool DataSource::sniff(
         }
     }
 
+    String8 newMimeType;
+    if (mimeType != NULL) {
+        newMimeType.setTo(*mimeType);
+    }
+    float newConfidence = *confidence;
+
     for (List<SnifferFunc>::iterator it = gSniffers.begin();
          it != gSniffers.end(); ++it) {
-        String8 newMimeType;
-        float newConfidence;
-        sp<AMessage> newMeta;
+        int64_t sniffStart = ALooper::GetNowUs();
+        String8 newMimeType = *mimeType;
+        float newConfidence = *confidence;
+        sp<AMessage> newMeta = *meta;
         if ((*it)(this, &newMimeType, &newConfidence, &newMeta)) {
             if (newConfidence > *confidence) {
                 *mimeType = newMimeType;
@@ -159,6 +167,9 @@ bool DataSource::sniff(
                 *meta = newMeta;
             }
         }
+        ALOGV("Sniffer (%p) completed in %.2f ms (mime=%s confidence=%.2f",
+                this, ((float)(ALooper::GetNowUs() - sniffStart) / 1000.0f),
+                mimeType == NULL ? NULL : (*mimeType).string(), *confidence);
     }
 
     return *confidence > 0.0;
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index ac6decd..8c63de2 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -63,6 +63,7 @@ sp<MediaExtractor> MediaExtractor::Create(
 
     String8 tmp;
     if (mime == NULL) {
+        int64_t sniffStart = ALooper::GetNowUs();
         float confidence;
         if (!source->sniff(&tmp, &confidence, &meta)) {
             ALOGV("FAILED to autodetect media content.");
@@ -71,8 +72,9 @@ sp<MediaExtractor> MediaExtractor::Create(
         }
 
         mime = tmp.string();
-        ALOGV("Autodetected media content as '%s' with confidence %.2f",
-             mime, confidence);
+        ALOGV("Autodetected media content as '%s' with confidence %.2f (%.2f ms)",
+                mime, confidence,
+                ((float)(ALooper::GetNowUs() - sniffStart) / 1000.0f));
     } else if (prevMeta != NULL) {
         meta = *prevMeta;
     }
-- 
2.7.4


From 980029b30c652ac7895a2d344f4db09b7b6efe3b Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 29 Dec 2015 03:48:19 -0800
Subject: [PATCH 088/119] nuplayer: Enable PCM offload for any source

 * Use the raw PCM format to perform the early open of the audio sink.
   This ensures that the renderer will do the same.
 * Fill in stubs for timestamp and position calculation. This fixes
   underruns and other issues.

Change-Id: I8d761e523194cc12f387b4b2aa1594536e56da01
---
 include/media/AudioTrack.h                         |  2 +-
 media/libavextensions/media/AVMediaExtensions.h    | 29 ++++++++++++++++------
 .../mediaplayerservice/AVNuUtils.cpp               | 14 ++---------
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  | 14 ++++++++---
 4 files changed, 35 insertions(+), 24 deletions(-)

diff --git a/include/media/AudioTrack.h b/include/media/AudioTrack.h
index 191802d..6f07f98 100644
--- a/include/media/AudioTrack.h
+++ b/include/media/AudioTrack.h
@@ -624,7 +624,7 @@ private:
      */
             status_t    obtainBuffer(Buffer* audioBuffer, const struct timespec *requested,
                                      struct timespec *elapsed = NULL, size_t *nonContig = NULL);
-     friend struct ExtendedMediaUtils;
+     friend struct AVMediaUtils;
 public:
 
     /* Public API for TRANSFER_OBTAIN mode.
diff --git a/media/libavextensions/media/AVMediaExtensions.h b/media/libavextensions/media/AVMediaExtensions.h
index d48feec..9622253 100644
--- a/media/libavextensions/media/AVMediaExtensions.h
+++ b/media/libavextensions/media/AVMediaExtensions.h
@@ -47,18 +47,33 @@ struct AVMediaUtils {
     virtual bool AudioTrackIsPcmOffloaded(const audio_format_t format) {
         return audio_is_offload_pcm(format);
     }
-    virtual status_t AudioTrackGetPosition(AudioTrack* /*track*/,
-            uint32_t* /*position*/) {
-        return NO_INIT;
+
+    virtual status_t AudioTrackGetPosition(AudioTrack* track,
+            uint32_t* position) {
+        uint32_t tempPos = (track->mState == AudioTrack::STATE_STOPPED ||
+                 track->mState == AudioTrack::STATE_FLUSHED) ? 0 :
+                 track->updateAndGetPosition_l();
+        *position = (tempPos /
+                 (track->channelCount() * audio_bytes_per_sample(track->format())));
+        return NO_ERROR;
     }
 
-    virtual status_t AudioTrackGetTimestamp(AudioTrack* /*track*/,
-            AudioTimestamp* /*timestamp*/) {
-        return NO_INIT;
+    virtual status_t AudioTrackGetTimestamp(AudioTrack* track,
+            AudioTimestamp* timestamp) {
+        if (!AudioTrackIsPcmOffloaded(track->format())) {
+            return NO_INIT;
+        }
+        uint32_t tempPos = (track->mState == AudioTrack::STATE_STOPPED ||
+                 track->mState == AudioTrack::STATE_FLUSHED) ? 0 :
+                 track->updateAndGetPosition_l();
+        timestamp->mPosition = (tempPos / (track->channelCount() *
+                 audio_bytes_per_sample(track->format())));
+        clock_gettime(CLOCK_MONOTONIC, &timestamp->mTime);
+        return NO_ERROR;
     }
 
     virtual size_t AudioTrackGetOffloadFrameCount(size_t frameCount) {
-        return frameCount;
+        return frameCount * 2;
     }
 
     virtual bool AudioTrackIsTrackOffloaded(audio_io_handle_t /*output*/) {
diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index 77ace83..dcd05af 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -55,21 +55,11 @@
 namespace android {
 
 static bool is24bitPCMOffloadEnabled() {
-    char propPCMOfload[PROPERTY_VALUE_MAX] = {0};
-    property_get("audio.offload.pcm.24bit.enable", propPCMOfload, "0");
-    if (!strncmp(propPCMOfload, "true", 4) || atoi(propPCMOfload))
-        return true;
-    else
-        return false;
+    return property_get_bool("audio.offload.pcm.24bit.enable", false);
 }
 
 static bool is16bitPCMOffloadEnabled() {
-    char propPCMOfload[PROPERTY_VALUE_MAX] = {0};
-    property_get("audio.offload.pcm.16bit.enable", propPCMOfload, "0");
-    if (!strncmp(propPCMOfload, "true", 4) || atoi(propPCMOfload))
-        return true;
-    else
-        return false;
+    return property_get_bool("audio.offload.pcm.16bit.enable", false);
 }
 
 sp<MetaData> AVNuUtils::createPCMMetaFromSource(const sp<MetaData> &sMeta) {
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index c5a7b52..bc12177 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -1517,16 +1517,22 @@ void NuPlayer::postScanSources() {
 void NuPlayer::tryOpenAudioSinkForOffload(const sp<AMessage> &format, bool hasVideo) {
     // Note: This is called early in NuPlayer to determine whether offloading
     // is possible; otherwise the decoders call the renderer openAudioSink directly.
-
+    sp<MetaData> audioMeta = mSource->getFormatMeta(true /* audio */);
+    sp<AMessage> pcmFormat;
+    if (mOffloadDecodedPCM) {
+        sp<MetaData> pcm = AVNuUtils::get()->createPCMMetaFromSource(audioMeta);
+        audioMeta = pcm;
+        convertMetaDataToMessage(pcm, &pcmFormat);
+    }
     status_t err = mRenderer->openAudioSink(
-            format, true /* offloadOnly */, hasVideo, AUDIO_OUTPUT_FLAG_NONE, &mOffloadAudio, mSource->isStreaming());
+            mOffloadDecodedPCM ? pcmFormat : format,
+            true /* offloadOnly */, hasVideo, AUDIO_OUTPUT_FLAG_NONE,
+            &mOffloadAudio, mSource->isStreaming());
     if (err != OK) {
         // Any failure we turn off mOffloadAudio.
         mOffloadAudio = false;
         mOffloadDecodedPCM = false;
     } else if (mOffloadAudio) {
-        sp<MetaData> audioMeta =
-                mSource->getFormatMeta(true /* audio */);
         sendMetaDataToHal(mAudioSink, audioMeta);
     }
 }
-- 
2.7.4


From cfcc69986414f62e10e0e23bb5783ad5ba48d513 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 5 Jan 2016 15:21:14 -0800
Subject: [PATCH 089/119] stagefright: Forward-port HFR and HSR support

 * CAF commit bd42a7ac3a60c0d8a079b4567484c9b006bac8ad upstream

Change-Id: I457ccab603647f3139ea2199a544f64ac3d1a214
---
 include/media/stagefright/MPEG4Writer.h            |   3 +
 media/libavextensions/stagefright/AVExtensions.h   |  58 +++++++++-
 media/libavextensions/stagefright/AVUtils.cpp      | 125 +++++++++++++++++++++
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  13 ++-
 media/libmediaplayerservice/StagefrightRecorder.h  |   4 +-
 media/libstagefright/MPEG4Writer.cpp               |  15 ++-
 media/libstagefright/MediaCodecSource.cpp          |   5 +
 7 files changed, 213 insertions(+), 10 deletions(-)

diff --git a/include/media/stagefright/MPEG4Writer.h b/include/media/stagefright/MPEG4Writer.h
index 541531f..09a48f9 100644
--- a/include/media/stagefright/MPEG4Writer.h
+++ b/include/media/stagefright/MPEG4Writer.h
@@ -190,6 +190,9 @@ private:
     // To use 3gp4 box for clips with AMR audio
     bool mIsAudioAMR;
 
+    // HFR scale
+    uint32_t mHFRRatio;
+
     void lock();
     void unlock();
 
diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
index 0ea3a4c..c80813b 100644
--- a/media/libavextensions/stagefright/AVExtensions.h
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -159,7 +159,7 @@ struct AVUtils {
             uint64_t /*eAacProfile*/);
 
     virtual void extractCustomCameraKeys(
-            const CameraParameters& /*params*/, sp<MetaData> &/*meta*/) {}
+            const CameraParameters& /*params*/, sp<MetaData> &/*meta*/);
     virtual void printFileName(int /*fd*/) {}
     virtual void addDecodingTimesFromBatch(MediaBuffer * /*buf*/,
             List<int64_t> &/*decodeTimeQueue*/) {}
@@ -236,12 +236,66 @@ struct AVUtils {
     // Used by ATSParser
     virtual bool IsHevcIDR(const sp<ABuffer> &accessUnit);
 
+    /*
+     * This class is a placeholder for the set of methods used
+     * to enable HFR (High Frame Rate) Recording
+     *
+     * HFR is a slow-motion recording feature where framerate
+     * is increased at capture, but file is composed to play
+     * back at normal rate, giving a net result of slow-motion.
+     * If HFR factor = N
+     *   framerate (at capture and encoder) = N * actual value
+     *   bitrate = N * actual value
+     *      (as the encoder still gets actual timestamps)
+     *   timeStamps (at composition) = actual value
+     *   timeScale (at composition) = actual value / N
+     *      (when parser re-generates timestamps, they will be
+     *       up-scaled by factor N, which results in slow-motion)
+     *
+     * HSR is a high-framerate recording variant where timestamps
+     * are not meddled with, yielding a video mux'ed at captured
+     * fps
+     */
+    struct HFR {
+        // set kKeyHFR when 'video-hfr' paramater is enabled
+        // or set kKeyHSR when 'video-hsr' paramater is enabled
+        virtual void setHFRIfEnabled(
+                const CameraParameters& params, sp<MetaData> &meta);
+
+        // recalculate file-duration when HFR is enabled
+        virtual status_t initializeHFR(
+                const sp<MetaData> &meta, sp<AMessage> &format,
+                int64_t &maxFileDurationUs, video_encoder videoEncoder);
+
+        virtual void setHFRRatio(
+                sp<MetaData> &meta, const int32_t hfrRatio);
+
+        virtual int32_t getHFRRatio(
+                const sp<MetaData> &meta);
+
+        protected:
+        HFR() {};
+        virtual ~HFR() {};
+        friend struct AVUtils;
+
+        private:
+        // Query supported capabilities from target-specific profiles
+        virtual int32_t getHFRCapabilities(
+                video_encoder codec,
+                int& maxHFRWidth, int& maxHFRHeight, int& maxHFRFps,
+                int& maxBitrate);
+    };
+    virtual inline HFR& HFRUtils() {
+         return mHFR;
+    }
+
 private:
     HEVCMuxer mHEVCMuxer;
+    HFR mHFR;
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
     DECLARE_LOADABLE_SINGLETON(AVUtils);
-};
 
+};
 }
 
 #endif // _AV_EXTENSIONS__H_
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index bc43338..5412708 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -41,6 +41,7 @@
 #include <media/stagefright/MediaCodec.h>
 #include <media/stagefright/MPEG4Writer.h>
 #include <media/stagefright/Utils.h>
+#include <media/MediaProfiles.h>
 
 #if defined(QCOM_HARDWARE) || defined(FLAC_OFFLOAD_ENABLED)
 #include "QCMediaDefs.h"
@@ -982,6 +983,130 @@ bool AVUtils::IsHevcIDR(const sp<ABuffer> &) {
    return false;
 }
 
+void AVUtils::HFR::setHFRIfEnabled(
+        const CameraParameters& params,
+        sp<MetaData> &meta) {
+    const char *hfrParam = params.get("video-hfr");
+    int32_t hfr = -1;
+    if (hfrParam != NULL) {
+        hfr = atoi(hfrParam);
+        if (hfr > 0) {
+            ALOGI("Enabling HFR @ %d fps", hfr);
+            meta->setInt32(kKeyHFR, hfr);
+            return;
+        } else {
+            ALOGI("Invalid HFR rate specified : %d", hfr);
+        }
+    }
+
+    const char *hsrParam = params.get("video-hsr");
+    int32_t hsr = -1;
+    if (hsrParam != NULL ) {
+        hsr = atoi(hsrParam);
+        if (hsr > 0) {
+            ALOGI("Enabling HSR @ %d fps", hsr);
+            meta->setInt32(kKeyHSR, hsr);
+        } else {
+            ALOGI("Invalid HSR rate specified : %d", hfr);
+        }
+    }
+}
+
+status_t AVUtils::HFR::initializeHFR(
+        const sp<MetaData> &meta, sp<AMessage> &format,
+        int64_t & /*maxFileDurationUs*/, video_encoder videoEncoder) {
+    status_t retVal = OK;
+
+    int32_t hsr = 0;
+    if (meta->findInt32(kKeyHSR, &hsr) && hsr > 0) {
+        ALOGI("HSR cue found. Override encode fps to %d", hsr);
+        format->setInt32("frame-rate", hsr);
+        return retVal;
+    }
+
+    int32_t hfr = 0;
+    if (!meta->findInt32(kKeyHFR, &hfr) || (hfr <= 0)) {
+        ALOGW("Invalid HFR rate specified");
+        return retVal;
+    }
+
+    int32_t width = 0, height = 0;
+    CHECK(meta->findInt32(kKeyWidth, &width));
+    CHECK(meta->findInt32(kKeyHeight, &height));
+
+    int maxW, maxH, MaxFrameRate, maxBitRate = 0;
+    if (getHFRCapabilities(videoEncoder,
+            maxW, maxH, MaxFrameRate, maxBitRate) < 0) {
+        ALOGE("Failed to query HFR target capabilities");
+        return ERROR_UNSUPPORTED;
+    }
+
+    if ((width * height * hfr) > (maxW * maxH * MaxFrameRate)) {
+        ALOGE("HFR request [%d x %d @%d fps] exceeds "
+                "[%d x %d @%d fps]. Will stay disabled",
+                width, height, hfr, maxW, maxH, MaxFrameRate);
+        return ERROR_UNSUPPORTED;
+    }
+
+    int32_t frameRate = 0, bitRate = 0;
+    CHECK(meta->findInt32(kKeyFrameRate, &frameRate));
+    CHECK(format->findInt32("bitrate", &bitRate));
+
+    if (frameRate) {
+        // scale the bitrate proportional to the hfr ratio
+        // to maintain quality, but cap it to max-supported.
+        bitRate = (hfr * bitRate) / frameRate;
+        bitRate = bitRate > maxBitRate ? maxBitRate : bitRate;
+        format->setInt32("bitrate", bitRate);
+
+        int32_t hfrRatio = hfr / frameRate;
+        format->setInt32("frame-rate", hfr);
+        format->setInt32("hfr-ratio", hfrRatio);
+    } else {
+        ALOGE("HFR: Invalid framerate");
+        return BAD_VALUE;
+    }
+
+    return retVal;
+}
+
+void AVUtils::HFR::setHFRRatio(
+        sp<MetaData> &meta, const int32_t hfrRatio) {
+    if (hfrRatio > 0) {
+        meta->setInt32(kKeyHFR, hfrRatio);
+    }
+}
+
+int32_t AVUtils::HFR::getHFRRatio(
+        const sp<MetaData> &meta) {
+    int32_t hfrRatio = 0;
+    meta->findInt32(kKeyHFR, &hfrRatio);
+    return hfrRatio ? hfrRatio : 1;
+}
+
+int32_t AVUtils::HFR::getHFRCapabilities(
+        video_encoder codec,
+        int& maxHFRWidth, int& maxHFRHeight, int& maxHFRFps,
+        int& maxBitRate) {
+    maxHFRWidth = maxHFRHeight = maxHFRFps = maxBitRate = 0;
+    MediaProfiles *profiles = MediaProfiles::getInstance();
+
+    if (profiles) {
+        maxHFRWidth = profiles->getVideoEncoderParamByName("enc.vid.hfr.width.max", codec);
+        maxHFRHeight = profiles->getVideoEncoderParamByName("enc.vid.hfr.height.max", codec);
+        maxHFRFps = profiles->getVideoEncoderParamByName("enc.vid.hfr.mode.max", codec);
+        maxBitRate = profiles->getVideoEncoderParamByName("enc.vid.bps.max", codec);
+    }
+
+    return (maxHFRWidth > 0) && (maxHFRHeight > 0) &&
+            (maxHFRFps > 0) && (maxBitRate > 0) ? 1 : -1;
+}
+
+void AVUtils::extractCustomCameraKeys(
+        const CameraParameters& params, sp<MetaData> &meta) {
+    mHFR.setHFRIfEnabled(params, meta);
+}
+
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVUtils::AVUtils() {}
 
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 9c07fc6..2075113 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -1622,12 +1622,12 @@ status_t StagefrightRecorder::setupVideoEncoder(
         }
     }
 
-    setupCustomVideoEncoderParams(cameraSource, format);
-
     format->setInt32("bitrate", mVideoBitRate);
     format->setInt32("frame-rate", mFrameRate);
     format->setInt32("i-frame-interval", mIFramesIntervalSec);
 
+    setupCustomVideoEncoderParams(cameraSource, format);
+
     if (mVideoTimeScale > 0) {
         format->setInt32("time-scale", mVideoTimeScale);
     }
@@ -2094,4 +2094,13 @@ status_t StagefrightRecorder::setSourcePause(bool pause) {
     }
     return err;
 }
+
+void StagefrightRecorder::setupCustomVideoEncoderParams(sp<MediaSource> cameraSource,
+        sp<AMessage> &format) {
+
+    // Setup HFR if needed
+    AVUtils::get()->HFRUtils().initializeHFR(cameraSource->getFormat(), format,
+            mMaxFileDurationUs, mVideoEncoder);
+}
+
 }  // namespace android
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index 72dc77b..d93fc3b 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -154,8 +154,8 @@ protected:
     status_t setupCameraSource(sp<CameraSource> *cameraSource);
     status_t setupAudioEncoder(const sp<MediaWriter>& writer);
     virtual status_t setupVideoEncoder(sp<MediaSource> cameraSource, sp<MediaSource> *source);
-    virtual void setupCustomVideoEncoderParams(sp<MediaSource> /*cameraSource*/,
-            sp<AMessage> &/*format*/) {}
+    virtual void setupCustomVideoEncoderParams(sp<MediaSource> cameraSource,
+            sp<AMessage> &format);
     virtual bool setCustomVideoEncoderMime(const video_encoder videoEncoder, sp<AMessage> format);
 
     // Encoding parameter handling utilities
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 3783fda..82f3c58 100644
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -321,6 +321,7 @@ private:
     // Simple validation on the codec specific data
     status_t checkCodecSpecificData() const;
     int32_t mRotation;
+    int32_t mHFRRatio;
 
     void updateTrackSizeEstimate();
     void addOneStscTableEntry(size_t chunkId, size_t sampleId);
@@ -390,7 +391,8 @@ MPEG4Writer::MPEG4Writer(int fd)
       mStartTimeOffsetMs(-1),
       mMetaKeys(new AMessage()),
       mIsVideoHEVC(false),
-      mIsAudioAMR(false) {
+      mIsAudioAMR(false),
+      mHFRRatio(1) {
     addDeviceMeta();
 
     // Verify mFd is seekable
@@ -532,6 +534,8 @@ status_t MPEG4Writer::addSource(const sp<MediaSource> &source) {
     Track *track = new Track(this, source, 1 + mTracks.size());
     mTracks.push_back(track);
 
+    mHFRRatio = AVUtils::get()->HFRUtils().getHFRRatio(source->getFormat());
+
     return OK;
 }
 
@@ -1033,7 +1037,7 @@ void MPEG4Writer::writeMvhdBox(int64_t durationUs) {
     writeInt32(0);             // version=0, flags=0
     writeInt32(now);           // creation time
     writeInt32(now);           // modification time
-    writeInt32(mTimeScale);    // mvhd timescale
+    writeInt32(mTimeScale / mHFRRatio);    // mvhd timescale
     int32_t duration = (durationUs * mTimeScale + 5E5) / 1E6;
     writeInt32(duration);
     writeInt32(0x10000);       // rate: 1.0
@@ -1481,7 +1485,8 @@ MPEG4Writer::Track::Track(
       mCodecSpecificDataSize(0),
       mGotAllCodecSpecificData(false),
       mReachedEOS(false),
-      mRotation(0) {
+      mRotation(0),
+      mHFRRatio(1) {
     getCodecSpecificDataFromInputFormatIfPossible();
 
     const char *mime;
@@ -1886,6 +1891,8 @@ status_t MPEG4Writer::Track::start(MetaData *params) {
     pthread_create(&mThread, &attr, ThreadWrapper, this);
     pthread_attr_destroy(&attr);
 
+    mHFRRatio = AVUtils::get()->HFRUtils().getHFRRatio(mMeta);
+
     return OK;
 }
 
@@ -3077,7 +3084,7 @@ void MPEG4Writer::Track::writeMdhdBox(uint32_t now) {
     mOwner->writeInt32(0);             // version=0, flags=0
     mOwner->writeInt32(now);           // creation time
     mOwner->writeInt32(now);           // modification time
-    mOwner->writeInt32(mTimeScale);    // media timescale
+    mOwner->writeInt32(mTimeScale / mHFRRatio);    // media timescale
     int32_t mdhdDuration = (trakDurationUs * mTimeScale + 5E5) / 1E6;
     mOwner->writeInt32(mdhdDuration);  // use media timescale
     // Language follows the three letter standard ISO-639-2/T
diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index aef6715..adbde54 100644
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -429,9 +429,14 @@ status_t MediaCodecSource::initEncoder() {
         return err;
     }
 
+    int32_t hfrRatio = 0;
+    mOutputFormat->findInt32("hfr-ratio", &hfrRatio);
+
     mEncoder->getOutputFormat(&mOutputFormat);
     convertMessageToMetaData(mOutputFormat, mMeta);
 
+    AVUtils::get()->HFRUtils().setHFRRatio(mMeta, hfrRatio);
+
     if (mFlags & FLAG_USE_SURFACE_INPUT) {
         CHECK(mIsVideo);
 
-- 
2.7.4


From 2835132849ea720ac3bb4f2f14dce6f5463b796c Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 5 Jan 2016 16:20:37 -0800
Subject: [PATCH 090/119] stagefright: Only include HFR/HSR on QCOM devices

Change-Id: Ib98c9c94cccc902708d25a9b8d81bc54fd6bbf7c
---
 media/libavextensions/stagefright/AVUtils.cpp | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index 5412708..71a1365 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -983,6 +983,7 @@ bool AVUtils::IsHevcIDR(const sp<ABuffer> &) {
    return false;
 }
 
+#ifdef QCOM_HARDWARE
 void AVUtils::HFR::setHFRIfEnabled(
         const CameraParameters& params,
         sp<MetaData> &meta) {
@@ -1101,6 +1102,32 @@ int32_t AVUtils::HFR::getHFRCapabilities(
     return (maxHFRWidth > 0) && (maxHFRHeight > 0) &&
             (maxHFRFps > 0) && (maxBitRate > 0) ? 1 : -1;
 }
+#else
+void AVUtils::HFR::setHFRIfEnabled(
+        const CameraParameters& /*params*/,
+        sp<MetaData> & /*meta*/) {}
+
+status_t AVUtils::HFR::initializeHFR(
+        const sp<MetaData> & /*meta*/, sp<AMessage> & /*format*/,
+        int64_t & /*maxFileDurationUs*/, video_encoder /*videoEncoder*/) {
+    return OK;
+}
+
+void AVUtils::HFR::setHFRRatio(
+        sp<MetaData> & /*meta*/, const int32_t /*hfrRatio*/) {}
+
+int32_t AVUtils::HFR::getHFRRatio(
+        const sp<MetaData> & /*meta */) {
+    return 1;
+}
+
+int32_t AVUtils::HFR::getHFRCapabilities(
+        video_encoder /*codec*/,
+        int& /*maxHFRWidth*/, int& /*maxHFRHeight*/, int& /*maxHFRFps*/,
+        int& /*maxBitRate*/) {
+    return -1;
+}
+#endif
 
 void AVUtils::extractCustomCameraKeys(
         const CameraParameters& params, sp<MetaData> &meta) {
-- 
2.7.4


From 706337d0dfb8e4ca4a07f59bda6c646fd80186f5 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 5 Jan 2016 16:45:30 -0800
Subject: [PATCH 091/119] stagefright: Add deferred release option

 * Fill in stub methods to improve video encoding performance.

Change-Id: I2bbf192e022043d161429c6cabf4a7d740802d20
---
 include/media/stagefright/MetaData.h             |  4 ++++
 media/libavextensions/stagefright/AVExtensions.h | 12 +++++++++---
 2 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index 0dd5995..2a3df22 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -205,6 +205,10 @@ enum {
 
     kKeyPCMFormat         = 'pfmt',
     kKeyArbitraryMode     = 'ArbM',
+
+    // Indicate if it is OK to hold on to the MediaBuffer and not
+    // release it immediately
+    kKeyCanDeferRelease   = 'drel', // bool (int32_t)
 };
 
 enum {
diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
index c80813b..d3af19b 100644
--- a/media/libavextensions/stagefright/AVExtensions.h
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -36,11 +36,11 @@
 #include <media/mediarecorder.h>
 #include <media/IOMX.h>
 #include <media/AudioParameter.h>
+#include <media/stagefright/MetaData.h>
 #include "ESQueue.h"
 
 namespace android {
 
-class MetaData;
 class MediaExtractor;
 class MPEG4Writer;
 struct ABuffer;
@@ -166,8 +166,14 @@ struct AVUtils {
 
     virtual bool useQCHWEncoder(const sp<AMessage> &, AString &) { return false; }
 
-    virtual bool canDeferRelease(const sp<MetaData> &/*meta*/) { return false; }
-    virtual void setDeferRelease(sp<MetaData> &/*meta*/) {}
+    virtual bool canDeferRelease(const sp<MetaData> &meta) {
+        int32_t deferRelease = false;
+        return meta->findInt32(kKeyCanDeferRelease, &deferRelease) && deferRelease;
+    }
+
+    virtual void setDeferRelease(sp<MetaData> &meta) {
+        meta->setInt32(kKeyCanDeferRelease, true);
+    }
 
     struct HEVCMuxer {
 
-- 
2.7.4


From fb0706e2768a9e6dec88bbf1b429fb086ac49c47 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Wed, 6 Jan 2016 14:55:28 -0800
Subject: [PATCH 092/119] stagefright: Fix crash on mediaserver

CameraSource can be null when we do setupCustomVideoEncoderParams,
add a null pointer checking for it.

Change-Id: Ie28018e67d623b03bb7c3c7dbc8a92669158b84b
---
 media/libmediaplayerservice/StagefrightRecorder.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 2075113..d58b500 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -1626,7 +1626,9 @@ status_t StagefrightRecorder::setupVideoEncoder(
     format->setInt32("frame-rate", mFrameRate);
     format->setInt32("i-frame-interval", mIFramesIntervalSec);
 
-    setupCustomVideoEncoderParams(cameraSource, format);
+    if (cameraSource != NULL) {
+        setupCustomVideoEncoderParams(cameraSource, format);
+    }
 
     if (mVideoTimeScale > 0) {
         format->setInt32("time-scale", mVideoTimeScale);
-- 
2.7.4


From 62760d7e22b8fb8c659f37252caf951f826db246 Mon Sep 17 00:00:00 2001
From: Chih-Hung Hsieh <chh@google.com>
Date: Wed, 19 Aug 2015 11:44:57 -0700
Subject: [PATCH 093/119] Use unified syntax to compile with both llvm and gas.

* Remove useless stab debug info directives .func and .endfunc,
  which are not recognized by clang/llvm integrated assembler.
* Replace require8 with REQUIRE8, preserve8 with PRESERVE8.
* Replace LDRNESB with LDRSBNE, LDREQSB with LDRSBEQ, etc.
* Replace VST1 {*.U8} with VST1.8 ..., VLD1 {*.U8} with VLD1.8,
  and VMOV with VMOV.I8.
* New assembler output code is identical or equivalent to old gas output.
  For example, the 3 references of
      LDR      r7, =0x80808080
  in omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Average_4x_Align_unsafe_s.S
  produced 3 instances of
      .word   0x80808080
  by llvm integrated assembler but only one by gas.

Change-Id: Ifdcd5bee915a7534198d7f219bceab72045f6a22
---
 media/libstagefright/codecs/on2/h264dec/Android.mk |   2 -
 .../src_gcc/armVCM4P10_Average_4x_Align_unsafe_s.S |   6 -
 .../src_gcc/armVCM4P10_DeblockingChroma_unsafe_s.S |   4 -
 .../src_gcc/armVCM4P10_DeblockingLuma_unsafe_s.S   |   4 -
 .../src_gcc/armVCM4P10_DecodeCoeffsToPair_s.S      |   2 -
 .../armVCM4P10_InterpolateLuma_Align_unsafe_s.S    |   4 -
 .../armVCM4P10_InterpolateLuma_Copy_unsafe_s.S     |   2 -
 .../armVCM4P10_InterpolateLuma_DiagCopy_unsafe_s.S |   4 -
 ...10_InterpolateLuma_HalfDiagHorVer4x4_unsafe_s.S |   2 -
 ...10_InterpolateLuma_HalfDiagVerHor4x4_unsafe_s.S |   2 -
 ...rmVCM4P10_InterpolateLuma_HalfHor4x4_unsafe_s.S |   2 -
 ...rmVCM4P10_InterpolateLuma_HalfVer4x4_unsafe_s.S |   2 -
 .../src_gcc/armVCM4P10_Interpolate_Chroma_s.S      |   2 -
 .../src_gcc/armVCM4P10_TransformResidual4x4_s.S    |   2 -
 .../vc/m4p10/src_gcc/armVCM4P10_UnpackBlock4x4_s.S |  11 +-
 .../vc/m4p10/src_gcc/omxVCM4P10_DeblockLuma_I.S    |   2 -
 ...4P10_DequantTransformResidualFromPairAndAdd_s.S |   2 -
 ...omxVCM4P10_FilterDeblockingChroma_HorEdge_I_s.S |   2 -
 ...omxVCM4P10_FilterDeblockingChroma_VerEdge_I_s.S |   2 -
 .../omxVCM4P10_FilterDeblockingLuma_HorEdge_I_s.S  |   2 -
 .../omxVCM4P10_FilterDeblockingLuma_VerEdge_I_s.S  |   2 -
 .../m4p10/src_gcc/omxVCM4P10_InterpolateLuma_s.S   |   2 -
 .../src_gcc/omxVCM4P10_PredictIntraChroma_8x8_s.S  |   2 -
 .../src_gcc/omxVCM4P10_PredictIntra_16x16_s.S      |   2 -
 .../m4p10/src_gcc/omxVCM4P10_PredictIntra_4x4_s.S  |   2 -
 ...omxVCM4P10_TransformDequantChromaDCFromPair_s.S |  11 +-
 .../omxVCM4P10_TransformDequantLumaDCFromPair_s.S  |   4 -
 .../h264dec/source/arm_neon_asm_gcc/asm_common.S   |   2 -
 .../source/arm_neon_asm_gcc/h264bsdClearMbLayer.S  |  14 +-
 .../arm_neon_asm_gcc/h264bsdCountLeadingZeros.S    |   2 +-
 .../source/arm_neon_asm_gcc/h264bsdFillRow7.S      |  40 ++---
 .../source/arm_neon_asm_gcc/h264bsdFlushBits.S     |   2 +-
 .../arm_neon_asm_gcc/h264bsdWriteMacroblock.S      | 161 ++++++++++-----------
 33 files changed, 119 insertions(+), 188 deletions(-)

diff --git a/media/libstagefright/codecs/on2/h264dec/Android.mk b/media/libstagefright/codecs/on2/h264dec/Android.mk
index e63b6b1..bf03ad9 100644
--- a/media/libstagefright/codecs/on2/h264dec/Android.mk
+++ b/media/libstagefright/codecs/on2/h264dec/Android.mk
@@ -94,8 +94,6 @@ ifeq ($(TARGET_ARCH),arm)
     LOCAL_C_INCLUDES += $(LOCAL_PATH)/./omxdl/arm_neon/api \
                         $(LOCAL_PATH)/./omxdl/arm_neon/vc/api \
                         $(LOCAL_PATH)/./omxdl/arm_neon/vc/m4p10/api
-    # h264bsdWriteMacroblock.S does not compile with Clang.
-    LOCAL_CLANG_ASFLAGS_arm += -no-integrated-as
   endif
 endif
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Average_4x_Align_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Average_4x_Align_unsafe_s.S
index 46e0018..e1ffb09 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Average_4x_Align_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Average_4x_Align_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_Average_4x4_Align0_unsafe
-    .func   armVCM4P10_Average_4x4_Align0_unsafe
 armVCM4P10_Average_4x4_Align0_unsafe:
     PUSH     {r4-r6,lr}
     LDR      r7, =0x80808080
@@ -55,10 +54,8 @@ armVCM4P10_Average_4x4_Align0_unsafe:
     EOR      r4,r4,r7
     STR      r4,[r2],r3
     POP      {r4-r6,pc}
-    .endfunc
 
     .global armVCM4P10_Average_4x4_Align2_unsafe
-    .func   armVCM4P10_Average_4x4_Align2_unsafe
 armVCM4P10_Average_4x4_Align2_unsafe:
     PUSH     {r4-r6,lr}
     LDR      r7, =0x80808080
@@ -99,10 +96,8 @@ armVCM4P10_Average_4x4_Align2_unsafe:
     EOR      r4,r4,r7
     STR      r4,[r2],r3
     POP      {r4-r6,pc}
-    .endfunc
 
     .global armVCM4P10_Average_4x4_Align3_unsafe
-    .func   armVCM4P10_Average_4x4_Align3_unsafe
 armVCM4P10_Average_4x4_Align3_unsafe:
     PUSH     {r4-r6,lr}
     LDR      r7, =0x80808080
@@ -143,7 +138,6 @@ armVCM4P10_Average_4x4_Align3_unsafe:
     EOR      r4,r4,r7
     STR      r4,[r2],r3
     POP      {r4-r6,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DeblockingChroma_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DeblockingChroma_unsafe_s.S
index ca64a02..40ea4a9 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DeblockingChroma_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DeblockingChroma_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_DeblockingChromabSLT4_unsafe
-    .func   armVCM4P10_DeblockingChromabSLT4_unsafe
 armVCM4P10_DeblockingChromabSLT4_unsafe:
     VLD1.32  {d18[0]},[r5]!
     VSUBL.U8 q11,d5,d9
@@ -50,10 +49,8 @@ armVCM4P10_DeblockingChromabSLT4_unsafe:
     VQMOVUN.S16 d29,q14
     VQMOVUN.S16 d24,q12
     BX       lr
-    .endfunc
 
     .global armVCM4P10_DeblockingChromabSGE4_unsafe
-    .func   armVCM4P10_DeblockingChromabSGE4_unsafe
 armVCM4P10_DeblockingChromabSGE4_unsafe:
     VHADD.U8 d13,d4,d9
     VHADD.U8 d31,d8,d5
@@ -63,7 +60,6 @@ armVCM4P10_DeblockingChromabSGE4_unsafe:
     VRHADD.U8 d13,d13,d5
     VRHADD.U8 d31,d31,d9
     BX       lr
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DeblockingLuma_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DeblockingLuma_unsafe_s.S
index 193bc5e..05fb2c5 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DeblockingLuma_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DeblockingLuma_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_DeblockingLumabSLT4_unsafe
-    .func   armVCM4P10_DeblockingLumabSLT4_unsafe
 armVCM4P10_DeblockingLumabSLT4_unsafe:
     VSUBL.U8 q11,d5,d9
     VLD1.8   {d18[]},[r5]!
@@ -66,10 +65,8 @@ armVCM4P10_DeblockingLumabSLT4_unsafe:
     VBIF     d24,d8,d16
     VBIF     d25,d9,d12
     BX       lr
-    .endfunc
 
     .global armVCM4P10_DeblockingLumabSGE4_unsafe
-    .func   armVCM4P10_DeblockingLumabSGE4_unsafe
 armVCM4P10_DeblockingLumabSGE4_unsafe:
     VSHR.U8  d19,d0,#2
     VADD.I8  d19,d19,d15
@@ -111,7 +108,6 @@ armVCM4P10_DeblockingLumabSGE4_unsafe:
     VBIF     d24,d8,d16
     VBIF     d28,d10,d12
     BX       lr
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DecodeCoeffsToPair_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DecodeCoeffsToPair_s.S
index 8e0db37..27c0452 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DecodeCoeffsToPair_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_DecodeCoeffsToPair_s.S
@@ -42,7 +42,6 @@
     .hidden   armVCM4P10_ZigZag_4x4
 
     .global armVCM4P10_DecodeCoeffsToPair
-    .func   armVCM4P10_DecodeCoeffsToPair
 armVCM4P10_DecodeCoeffsToPair:
     PUSH     {r4-r12,lr}
     SUB      sp,sp,#0x40
@@ -302,7 +301,6 @@ L0x344:
 L0x35c:
     ADD      sp,sp,#0x40
     POP      {r4-r12,pc}
-    .endfunc
 
 .LarmVCM4P10_CAVLCCoeffTokenTables:
     .word   armVCM4P10_CAVLCCoeffTokenTables-(P0+8)
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_Align_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_Align_unsafe_s.S
index 7206d76..1de9004 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_Align_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_Align_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_InterpolateLuma_HorAlign9x_unsafe
-    .func   armVCM4P10_InterpolateLuma_HorAlign9x_unsafe
 armVCM4P10_InterpolateLuma_HorAlign9x_unsafe:
     MOV      r12,r8
     AND      r7,r0,#3
@@ -83,10 +82,8 @@ CopyEnd:
     MOV      r0,r12
     MOV      r1,#0xc
     BX       lr
-    .endfunc
 
     .global armVCM4P10_InterpolateLuma_VerAlign4x_unsafe
-    .func   armVCM4P10_InterpolateLuma_VerAlign4x_unsafe
 armVCM4P10_InterpolateLuma_VerAlign4x_unsafe:
     AND      r7,r0,#3
     BIC      r0,r0,#3
@@ -132,7 +129,6 @@ CopyVEnd:
     SUB      r0,r8,#0x1c
     MOV      r1,#4
     BX       lr
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_Copy_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_Copy_unsafe_s.S
index e41d662..7ba2890 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_Copy_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_Copy_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_InterpolateLuma_Copy4x4_unsafe
-    .func   armVCM4P10_InterpolateLuma_Copy4x4_unsafe
 armVCM4P10_InterpolateLuma_Copy4x4_unsafe:
     PUSH     {r4-r6,lr}
     AND      r12,r0,#3
@@ -114,7 +113,6 @@ Copy4x4Align3:
     STR      r8,[r2],r3
 Copy4x4End:
     POP      {r4-r6,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_DiagCopy_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_DiagCopy_unsafe_s.S
index c8f5cda..8b2c678 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_DiagCopy_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_DiagCopy_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_InterpolateLuma_HorDiagCopy_unsafe
-    .func   armVCM4P10_InterpolateLuma_HorDiagCopy_unsafe
 armVCM4P10_InterpolateLuma_HorDiagCopy_unsafe:
     PUSH     {r4-r6,lr}
     MOV      lr,#4
@@ -57,10 +56,8 @@ LoopStart1:
     SUB      r0,r7,#0x20
     MOV      r1,#8
     POP      {r4-r6,pc}
-    .endfunc
 
     .global armVCM4P10_InterpolateLuma_VerDiagCopy_unsafe
-    .func   armVCM4P10_InterpolateLuma_VerDiagCopy_unsafe
 armVCM4P10_InterpolateLuma_VerDiagCopy_unsafe:
     PUSH     {r4-r6,lr}
     LDR      r6, =0xfe00fe0
@@ -116,7 +113,6 @@ LoopStart:
     SUB      r0,r7,#0x18
     MOV      r1,#4
     POP      {r4-r6,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfDiagHorVer4x4_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfDiagHorVer4x4_unsafe_s.S
index f5868c0..77aa927 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfDiagHorVer4x4_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfDiagHorVer4x4_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_InterpolateLuma_HalfDiagHorVer4x4_unsafe
-    .func   armVCM4P10_InterpolateLuma_HalfDiagHorVer4x4_unsafe
 armVCM4P10_InterpolateLuma_HalfDiagHorVer4x4_unsafe:
     PUSH     {r4-r12,lr}
     VLD1.8   {d0,d1},[r0],r1
@@ -173,7 +172,6 @@ armVCM4P10_InterpolateLuma_HalfDiagHorVer4x4_unsafe:
     VQMOVN.U16 d4,q2
     VQMOVN.U16 d6,q3
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfDiagVerHor4x4_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfDiagVerHor4x4_unsafe_s.S
index 065995d..e5f7f1c 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfDiagVerHor4x4_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfDiagVerHor4x4_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_InterpolateLuma_HalfDiagVerHor4x4_unsafe
-    .func   armVCM4P10_InterpolateLuma_HalfDiagVerHor4x4_unsafe
 armVCM4P10_InterpolateLuma_HalfDiagVerHor4x4_unsafe:
     PUSH     {r4-r12,lr}
     VLD1.8   {d0,d1},[r0],r1
@@ -128,7 +127,6 @@ armVCM4P10_InterpolateLuma_HalfDiagVerHor4x4_unsafe:
     VQMOVN.U16 d4,q2
     VQMOVN.U16 d6,q3
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfHor4x4_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfHor4x4_unsafe_s.S
index 1e2d16b..393d385 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfHor4x4_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfHor4x4_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_InterpolateLuma_HalfHor4x4_unsafe
-    .func   armVCM4P10_InterpolateLuma_HalfHor4x4_unsafe
 armVCM4P10_InterpolateLuma_HalfHor4x4_unsafe:
     PUSH     {r4-r12,lr}
     VLD1.8   {d22,d23},[r0],r1
@@ -81,7 +80,6 @@ armVCM4P10_InterpolateLuma_HalfHor4x4_unsafe:
     VQRSHRUN.S16 d26,q13,#5
     VQRSHRUN.S16 d28,q14,#5
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfVer4x4_unsafe_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfVer4x4_unsafe_s.S
index c7def2a..698e7b5 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfVer4x4_unsafe_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_InterpolateLuma_HalfVer4x4_unsafe_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_InterpolateLuma_HalfVer4x4_unsafe
-    .func   armVCM4P10_InterpolateLuma_HalfVer4x4_unsafe
 armVCM4P10_InterpolateLuma_HalfVer4x4_unsafe:
     PUSH     {r4-r12,lr}
     VLD1.8   {d7},[r0],r1
@@ -67,7 +66,6 @@ armVCM4P10_InterpolateLuma_HalfVer4x4_unsafe:
     VQRSHRUN.S16 d4,q2,#5
     VQRSHRUN.S16 d6,q3,#5
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Interpolate_Chroma_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Interpolate_Chroma_s.S
index 2f4293f..e469516 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Interpolate_Chroma_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_Interpolate_Chroma_s.S
@@ -38,7 +38,6 @@ armVCM4P10_WidthBranchTableMVIsZero:
     .word   WidthIs8MVIsZero-(P0+8)
 
     .global armVCM4P10_Interpolate_Chroma
-    .func   armVCM4P10_Interpolate_Chroma
 armVCM4P10_Interpolate_Chroma:
     PUSH     {r4-r12,lr}
     VPUSH    {d8-d15}
@@ -183,7 +182,6 @@ WidthIs2MVIsZero:
     MOV      r0,#0
     VPOP     {d8-d15}
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_TransformResidual4x4_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_TransformResidual4x4_s.S
index d4cedb5..e18bec7 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_TransformResidual4x4_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_TransformResidual4x4_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_TransformResidual4x4
-    .func   armVCM4P10_TransformResidual4x4
 armVCM4P10_TransformResidual4x4:
     VPUSH    {d8}
     VLD4.16  {d0,d1,d2,d3},[r1]
@@ -61,7 +60,6 @@ armVCM4P10_TransformResidual4x4:
     VST1.16  {d0,d1,d2,d3},[r0]
     VPOP     {d8}
     BX       lr
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_UnpackBlock4x4_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_UnpackBlock4x4_s.S
index 1652dc6..b97efcb 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_UnpackBlock4x4_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/armVCM4P10_UnpackBlock4x4_s.S
@@ -24,9 +24,9 @@
     .arm
     .fpu neon
     .text
+    .syntax unified
 
     .global armVCM4P10_UnpackBlock4x4
-    .func   armVCM4P10_UnpackBlock4x4
 armVCM4P10_UnpackBlock4x4:
     PUSH     {r4-r8,lr}
     LDR      r2,[r0,#0]
@@ -40,16 +40,15 @@ armVCM4P10_UnpackBlock4x4:
     STRD     r4,r5,[r1,#0x18]
 unpackLoop:
     TST      r3,#0x10
-    LDRNESB  r5,[r2,#1]
-    LDRNEB   r4,[r2],#2
+    LDRSBNE  r5,[r2,#1]
+    LDRBNE   r4,[r2],#2
     AND      r6,r7,r3,LSL #1
-    LDREQSB  r4,[r2],#1
+    LDRSBEQ  r4,[r2],#1
     ORRNE    r4,r4,r5,LSL #8
     TST      r3,#0x20
-    LDREQB   r3,[r2],#1
+    LDRBEQ   r3,[r2],#1
     STRH     r4,[r1,r6]
     BEQ      unpackLoop
     STR      r2,[r0,#0]
     POP      {r4-r8,pc}
-    .endfunc
     .end
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DeblockLuma_I.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DeblockLuma_I.S
index 90b0947..6a99bde 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DeblockLuma_I.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DeblockLuma_I.S
@@ -26,7 +26,6 @@
     .text
 
     .global omxVCM4P10_DeblockLuma_I
-    .func   omxVCM4P10_DeblockLuma_I
 omxVCM4P10_DeblockLuma_I:
     PUSH     {r4-r9,lr}
     MOVS     r6,r0
@@ -76,7 +75,6 @@ L0x64:
     BL       omxVCM4P10_FilterDeblockingLuma_HorEdge_I
     ADD      sp,sp,#0xc
     POP      {r4-r9,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DequantTransformResidualFromPairAndAdd_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DequantTransformResidualFromPairAndAdd_s.S
index 4a74594..17c5d8b 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DequantTransformResidualFromPairAndAdd_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DequantTransformResidualFromPairAndAdd_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global omxVCM4P10_DequantTransformResidualFromPairAndAdd
-    .func   omxVCM4P10_DequantTransformResidualFromPairAndAdd
 omxVCM4P10_DequantTransformResidualFromPairAndAdd:
     PUSH     {r4-r12,lr}
     VPUSH    {d8-d9}
@@ -131,7 +130,6 @@ L0x130:
     ADD      sp,sp,#0x20
     VPOP     {d8-d9}
     POP      {r4-r12,pc}
-    .endfunc
 
 .LarmVCM4P10_QPModuloTable:
     .word   armVCM4P10_QPModuloTable-(P0+8)
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingChroma_HorEdge_I_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingChroma_HorEdge_I_s.S
index f20fb78..4a83516 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingChroma_HorEdge_I_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingChroma_HorEdge_I_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global omxVCM4P10_FilterDeblockingChroma_HorEdge_I
-    .func   omxVCM4P10_FilterDeblockingChroma_HorEdge_I
 omxVCM4P10_FilterDeblockingChroma_HorEdge_I:
     PUSH     {r4-r10,lr}
     VPUSH    {d8-d15}
@@ -96,7 +95,6 @@ L0xe4:
     MOV      r0,#0
     VPOP     {d8-d15}
     POP      {r4-r10,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingChroma_VerEdge_I_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingChroma_VerEdge_I_s.S
index 003526e..fe10931 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingChroma_VerEdge_I_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingChroma_VerEdge_I_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global omxVCM4P10_FilterDeblockingChroma_VerEdge_I
-    .func   omxVCM4P10_FilterDeblockingChroma_VerEdge_I
 omxVCM4P10_FilterDeblockingChroma_VerEdge_I:
     PUSH     {r4-r12,lr}
     VPUSH    {d8-d15}
@@ -132,7 +131,6 @@ L0x170:
     MOV      r0,#0
     VPOP     {d8-d15}
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingLuma_HorEdge_I_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingLuma_HorEdge_I_s.S
index 7ddc42e..84ffad2 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingLuma_HorEdge_I_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingLuma_HorEdge_I_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global omxVCM4P10_FilterDeblockingLuma_HorEdge_I
-    .func   omxVCM4P10_FilterDeblockingLuma_HorEdge_I
 omxVCM4P10_FilterDeblockingLuma_HorEdge_I:
     PUSH     {r4-r12,lr}
     VPUSH    {d8-d15}
@@ -116,7 +115,6 @@ L0x130:
     MOV      r0,#0
     VPOP     {d8-d15}
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingLuma_VerEdge_I_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingLuma_VerEdge_I_s.S
index f71aceb..f2a3682 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingLuma_VerEdge_I_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_FilterDeblockingLuma_VerEdge_I_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global omxVCM4P10_FilterDeblockingLuma_VerEdge_I
-    .func   omxVCM4P10_FilterDeblockingLuma_VerEdge_I
 omxVCM4P10_FilterDeblockingLuma_VerEdge_I:
     PUSH     {r4-r12,lr}
     VPUSH    {d8-d15}
@@ -166,7 +165,6 @@ L0x1f0:
     MOV      r0,#0
     VPOP     {d8-d15}
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_InterpolateLuma_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_InterpolateLuma_s.S
index 000fbeb..314eabd 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_InterpolateLuma_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_InterpolateLuma_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global omxVCM4P10_InterpolateLuma
-    .func   omxVCM4P10_InterpolateLuma
 omxVCM4P10_InterpolateLuma:
     PUSH     {r4-r12,lr}
     VPUSH    {d8-d15}
@@ -332,7 +331,6 @@ L0x434:
     ADD      sp,sp,#0x10
     VPOP     {d8-d15}
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntraChroma_8x8_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntraChroma_8x8_s.S
index 4e2cff6..50d1350 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntraChroma_8x8_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntraChroma_8x8_s.S
@@ -36,7 +36,6 @@ armVCM4P10_MultiplierTableChroma8x8:
     .hword   1, 2, 3,4
 
     .global omxVCM4P10_PredictIntraChroma_8x8
-    .func   omxVCM4P10_PredictIntraChroma_8x8
 omxVCM4P10_PredictIntraChroma_8x8:
     PUSH     {r4-r10,lr}
     VPUSH    {d8-d15}
@@ -226,7 +225,6 @@ L0x28c:
     MOV      r0,#0
     VPOP     {d8-d15}
     POP      {r4-r10,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntra_16x16_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntra_16x16_s.S
index c71c93b..0044636 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntra_16x16_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntra_16x16_s.S
@@ -42,7 +42,6 @@ armVCM4P10_MultiplierTable16x16:
 
 
     .global omxVCM4P10_PredictIntra_16x16
-    .func   omxVCM4P10_PredictIntra_16x16
 omxVCM4P10_PredictIntra_16x16:
     PUSH     {r4-r12,lr}
     VPUSH    {d8-d15}
@@ -246,7 +245,6 @@ L0x2d4:
     MOV      r0,#0
     VPOP     {d8-d15}
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntra_4x4_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntra_4x4_s.S
index cd5d356..d4c8485 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntra_4x4_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_PredictIntra_4x4_s.S
@@ -35,7 +35,6 @@ armVCM4P10_pSwitchTable4x4:
     .word OMX_VC_4x4_HU-(P0+8)
 
     .global omxVCM4P10_PredictIntra_4x4
-    .func   omxVCM4P10_PredictIntra_4x4
 omxVCM4P10_PredictIntra_4x4:
     PUSH     {r4-r12,lr}
     VPUSH    {d8-d12}
@@ -270,6 +269,5 @@ L0x348:
     MOV      r0,#0
     VPOP     {d8-d12}
     POP      {r4-r12,pc}
-    .endfunc
 
     .end
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantChromaDCFromPair_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantChromaDCFromPair_s.S
index 5570892..74f5103 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantChromaDCFromPair_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantChromaDCFromPair_s.S
@@ -24,9 +24,9 @@
     .arm
     .fpu neon
     .text
+    .syntax unified
 
     .global omxVCM4P10_TransformDequantChromaDCFromPair
-    .func   omxVCM4P10_TransformDequantChromaDCFromPair
 omxVCM4P10_TransformDequantChromaDCFromPair:
     push    {r4-r10, lr}
     ldr     r9, [r0,#0]
@@ -36,13 +36,13 @@ omxVCM4P10_TransformDequantChromaDCFromPair:
     ldrb    r6, [r9], #1
 unpackLoop:
     tst     r6, #0x10
-    ldrnesb r5, [r9, #1]
-    ldrneb  r4, [r9], #2
+    ldrsbne r5, [r9, #1]
+    ldrbne  r4, [r9], #2
     and     r7, r8, r6, lsl #1
-    ldreqsb r4, [r9], #1
+    ldrsbeq r4, [r9], #1
     orrne   r4, r4, r5, lsl #8
     tst     r6, #0x20
-    ldreqb  r6, [r9], #1
+    ldrbeq  r6, [r9], #1
     strh    r4, [r1, r7]
     beq     unpackLoop
     ldmia   r1, {r3, r4}
@@ -66,7 +66,6 @@ P1: add     r6, pc
     vst1.16    {d2}, [r1]
     mov     r0, #0
     pop     {r4-r10, pc}
-    .endfunc
 
 .LarmVCM4P10_QPDivTable:
     .word armVCM4P10_QPDivTable-(P0+8)
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantLumaDCFromPair_s.S b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantLumaDCFromPair_s.S
index 5b6eee0..a01030a 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantLumaDCFromPair_s.S
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantLumaDCFromPair_s.S
@@ -26,7 +26,6 @@
     .text
 
     .global armVCM4P10_InvTransformDequantLumaDC4x4
-    .func   armVCM4P10_InvTransformDequantLumaDC4x4
 armVCM4P10_InvTransformDequantLumaDC4x4:
     PUSH     {r4-r6,lr}
     VPUSH    {d8-d13}
@@ -73,7 +72,6 @@ P1: ADD      r3, pc
     VST1.16  {d0,d1,d2,d3},[r0]
     VPOP     {d8-d13}
     POP      {r4-r6,pc}
-    .endfunc
 
 .LarmVCM4P10_QPDivTable:
     .word armVCM4P10_QPDivTable-(P0+8)
@@ -81,7 +79,6 @@ P1: ADD      r3, pc
     .word armVCM4P10_VMatrixQPModTable-(P1+8)
 
 .global omxVCM4P10_TransformDequantLumaDCFromPair
-.func   omxVCM4P10_TransformDequantLumaDCFromPair
 omxVCM4P10_TransformDequantLumaDCFromPair:
     PUSH     {r4-r6,lr}
     MOV      r4,r1
@@ -92,7 +89,6 @@ omxVCM4P10_TransformDequantLumaDCFromPair:
     BL       armVCM4P10_InvTransformDequantLumaDC4x4
     MOV      r0,#0
     POP      {r4-r6,pc}
-    .endfunc
 
     .end
 
diff --git a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/asm_common.S b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/asm_common.S
index f39f5c4..969a75c 100644
--- a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/asm_common.S
+++ b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/asm_common.S
@@ -31,11 +31,9 @@
     .global \name
 .endif
     .type   \name, %function
-    .func   \name
 \name:
     .endm
 
     .macro endfunction
-    .endfunc
     .endm
 
diff --git a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdClearMbLayer.S b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdClearMbLayer.S
index c8a940e..3c2752f 100644
--- a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdClearMbLayer.S
+++ b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdClearMbLayer.S
@@ -16,7 +16,7 @@
 
 #include "asm_common.S"
 
-    preserve8
+    PRESERVE8
 
     .fpu neon
     .text
@@ -29,7 +29,7 @@
 
 /* -- NEON registers -- */
 
-#define qZero   Q0.U8
+#define qZero   Q0
 
 /*------------------------------------------------------------------------------
 
@@ -47,17 +47,17 @@
 
 function h264bsdClearMbLayer, export=1
 
-    VMOV    qZero, #0
+    VMOV.I8 qZero, #0
     ADD     pTmp, pMbLayer, #16
     MOV     step, #32
     SUBS    size, size, #64
 
 loop:
-    VST1    {qZero}, [pMbLayer], step
+    VST1.8  {qZero}, [pMbLayer], step
     SUBS    size, size, #64
-    VST1    {qZero}, [pTmp], step
-    VST1    {qZero}, [pMbLayer], step
-    VST1    {qZero}, [pTmp], step
+    VST1.8  {qZero}, [pTmp], step
+    VST1.8  {qZero}, [pMbLayer], step
+    VST1.8  {qZero}, [pTmp], step
     BCS     loop
 
     BX      lr
diff --git a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdCountLeadingZeros.S b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdCountLeadingZeros.S
index 05253d0..b1c9f60 100644
--- a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdCountLeadingZeros.S
+++ b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdCountLeadingZeros.S
@@ -15,7 +15,7 @@
 @
 #include "asm_common.S"
 
-    preserve8
+    PRESERVE8
     .arm
     .text
 
diff --git a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdFillRow7.S b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdFillRow7.S
index 6955b9a..6ed6227 100644
--- a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdFillRow7.S
+++ b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdFillRow7.S
@@ -16,7 +16,7 @@
 
 #include "asm_common.S"
 
-    preserve8
+    PRESERVE8
 
     .fpu neon
     .text
@@ -33,12 +33,12 @@
 
 /* -- NEON registers -- */
 
-#define qTmp0     Q0.U8
-#define qTmp1     Q1.U8
-#define dTmp0     D0.U8
-#define dTmp1     D1.U8
-#define dTmp2     D2.U8
-#define dTmp3     D3.U8
+#define qTmp0     Q0
+#define qTmp1     Q1
+#define dTmp0     D0
+#define dTmp1     D1
+#define dTmp2     D2
+#define dTmp3     D3
 
 /*
 void h264bsdFillRow7(const u8 * ref, u8 * fill, i32 left, i32 center,
@@ -74,40 +74,40 @@ switch_center:
         B        case_8
 
 case_8:
-        VLD1    {qTmp0, qTmp1}, [ref]!
+        VLD1.8  {qTmp0, qTmp1}, [ref]!
         SUB     center, center, #32
-        VST1    {qTmp0}, [fill]!
-        VST1    {qTmp1}, [fill]!
+        VST1.8  {qTmp0}, [fill]!
+        VST1.8  {qTmp1}, [fill]!
         B       loop_center
 case_7:
-        VLD1    {dTmp0,dTmp1,dTmp2}, [ref]!
+        VLD1.8  {dTmp0,dTmp1,dTmp2}, [ref]!
         SUB     center, center, #28
         LDR     tmp2, [ref], #4
-        VST1    {dTmp0,dTmp1,dTmp2}, [fill]!
+        VST1.8  {dTmp0,dTmp1,dTmp2}, [fill]!
         STR     tmp2, [fill],#4
         B       loop_center
 case_6:
-        VLD1    {dTmp0,dTmp1,dTmp2}, [ref]!
+        VLD1.8  {dTmp0,dTmp1,dTmp2}, [ref]!
         SUB     center, center, #24
-        VST1    {dTmp0,dTmp1,dTmp2}, [fill]!
+        VST1.8  {dTmp0,dTmp1,dTmp2}, [fill]!
         B       loop_center
 case_5:
-        VLD1    {qTmp0}, [ref]!
+        VLD1.8  {qTmp0}, [ref]!
         SUB     center, center, #20
         LDR     tmp2, [ref], #4
-        VST1    {qTmp0}, [fill]!
+        VST1.8  {qTmp0}, [fill]!
         STR     tmp2, [fill],#4
         B       loop_center
 case_4:
-        VLD1    {qTmp0}, [ref]!
+        VLD1.8  {qTmp0}, [ref]!
         SUB     center, center, #16
-        VST1    {qTmp0}, [fill]!
+        VST1.8  {qTmp0}, [fill]!
         B       loop_center
 case_3:
-        VLD1    {dTmp0}, [ref]!
+        VLD1.8  {dTmp0}, [ref]!
         SUB     center, center, #12
         LDR     tmp2, [ref], #4
-        VST1    dTmp0, [fill]!
+        VST1.8  dTmp0, [fill]!
         STR     tmp2, [fill],#4
         B       loop_center
 case_2:
diff --git a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdFlushBits.S b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdFlushBits.S
index b3f3191..aa88471 100644
--- a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdFlushBits.S
+++ b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdFlushBits.S
@@ -16,7 +16,7 @@
 
 #include "asm_common.S"
 
-    preserve8
+    PRESERVE8
 
     .arm
     .text
diff --git a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdWriteMacroblock.S b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdWriteMacroblock.S
index 495d560..4093b92 100644
--- a/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdWriteMacroblock.S
+++ b/media/libstagefright/codecs/on2/h264dec/source/arm_neon_asm_gcc/h264bsdWriteMacroblock.S
@@ -16,8 +16,8 @@
 
 #include "asm_common.S"
 
-    require8
-    preserve8
+    REQUIRE8
+    PRESERVE8
 
     .arm
     .fpu neon
@@ -34,39 +34,39 @@
 
 /* -- NEON registers -- */
 
-#define qRow0     Q0.U8
-#define qRow1     Q1.U8
-#define qRow2     Q2.U8
-#define qRow3     Q3.U8
-#define qRow4     Q4.U8
-#define qRow5     Q5.U8
-#define qRow6     Q6.U8
-#define qRow7     Q7.U8
-#define qRow8     Q8.U8
-#define qRow9     Q9.U8
-#define qRow10    Q10.U8
-#define qRow11    Q11.U8
-#define qRow12    Q12.U8
-#define qRow13    Q13.U8
-#define qRow14    Q14.U8
-#define qRow15    Q15.U8
-
-#define dRow0     D0.U8
-#define dRow1     D1.U8
-#define dRow2     D2.U8
-#define dRow3     D3.U8
-#define dRow4     D4.U8
-#define dRow5     D5.U8
-#define dRow6     D6.U8
-#define dRow7     D7.U8
-#define dRow8     D8.U8
-#define dRow9     D9.U8
-#define dRow10    D10.U8
-#define dRow11    D11.U8
-#define dRow12    D12.U8
-#define dRow13    D13.U8
-#define dRow14    D14.U8
-#define dRow15    D15.U8
+#define qRow0     Q0
+#define qRow1     Q1
+#define qRow2     Q2
+#define qRow3     Q3
+#define qRow4     Q4
+#define qRow5     Q5
+#define qRow6     Q6
+#define qRow7     Q7
+#define qRow8     Q8
+#define qRow9     Q9
+#define qRow10    Q10
+#define qRow11    Q11
+#define qRow12    Q12
+#define qRow13    Q13
+#define qRow14    Q14
+#define qRow15    Q15
+
+#define dRow0     D0
+#define dRow1     D1
+#define dRow2     D2
+#define dRow3     D3
+#define dRow4     D4
+#define dRow5     D5
+#define dRow6     D6
+#define dRow7     D7
+#define dRow8     D8
+#define dRow9     D9
+#define dRow10    D10
+#define dRow11    D11
+#define dRow12    D12
+#define dRow13    D13
+#define dRow14    D14
+#define dRow15    D15
 
 /*------------------------------------------------------------------------------
 
@@ -99,59 +99,58 @@ function h264bsdWriteMacroblock, export=1
 
 
 @   Write luma
-    VLD1    {qRow0, qRow1}, [data]!
+    VLD1.8  {qRow0, qRow1}, [data]!
     LSL     width, width, #4
-    VLD1    {qRow2, qRow3}, [data]!
+    VLD1.8  {qRow2, qRow3}, [data]!
     LSR     cwidth, width, #1
-    VST1    {qRow0}, [luma,:128], width
-    VLD1    {qRow4, qRow5}, [data]!
-    VST1    {qRow1}, [luma,:128], width
-    VLD1    {qRow6, qRow7}, [data]!
-    VST1    {qRow2}, [luma,:128], width
-    VLD1    {qRow8, qRow9}, [data]!
-    VST1    {qRow3}, [luma,:128], width
-    VLD1    {qRow10, qRow11}, [data]!
-    VST1    {qRow4}, [luma,:128], width
-    VLD1    {qRow12, qRow13}, [data]!
-    VST1    {qRow5}, [luma,:128], width
-    VLD1    {qRow14, qRow15}, [data]!
-    VST1    {qRow6}, [luma,:128], width
-
-    VLD1    {qRow0, qRow1}, [data]! ;//cb rows 0,1,2,3
-    VST1    {qRow7}, [luma,:128], width
-    VLD1    {qRow2, qRow3}, [data]! ;//cb rows 4,5,6,7
-    VST1    {qRow8}, [luma,:128], width
-    VLD1    {qRow4, qRow5}, [data]! ;//cr rows 0,1,2,3
-    VST1    {qRow9}, [luma,:128], width
-    VLD1    {qRow6, qRow7}, [data]! ;//cr rows 4,5,6,7
-    VST1    {qRow10}, [luma,:128], width
-    VST1    {dRow0}, [cb,:64], cwidth
-    VST1    {dRow8}, [cr,:64], cwidth
-    VST1    {qRow11}, [luma,:128], width
-    VST1    {dRow1}, [cb,:64], cwidth
-    VST1    {dRow9}, [cr,:64], cwidth
-    VST1    {qRow12}, [luma,:128], width
-    VST1    {dRow2}, [cb,:64], cwidth
-    VST1    {dRow10}, [cr,:64], cwidth
-    VST1    {qRow13}, [luma,:128], width
-    VST1    {dRow3}, [cb,:64], cwidth
-    VST1    {dRow11}, [cr,:64], cwidth
-    VST1    {qRow14}, [luma,:128], width
-    VST1    {dRow4}, [cb,:64], cwidth
-    VST1    {dRow12}, [cr,:64], cwidth
-    VST1    {qRow15}, [luma]
-    VST1    {dRow5}, [cb,:64], cwidth
-    VST1    {dRow13}, [cr,:64], cwidth
-    VST1    {dRow6}, [cb,:64], cwidth
-    VST1    {dRow14}, [cr,:64], cwidth
-    VST1    {dRow7}, [cb,:64]
-    VST1    {dRow15}, [cr,:64]
+    VST1.8  {qRow0}, [luma,:128], width
+    VLD1.8  {qRow4, qRow5}, [data]!
+    VST1.8  {qRow1}, [luma,:128], width
+    VLD1.8  {qRow6, qRow7}, [data]!
+    VST1.8  {qRow2}, [luma,:128], width
+    VLD1.8  {qRow8, qRow9}, [data]!
+    VST1.8  {qRow3}, [luma,:128], width
+    VLD1.8  {qRow10, qRow11}, [data]!
+    VST1.8  {qRow4}, [luma,:128], width
+    VLD1.8  {qRow12, qRow13}, [data]!
+    VST1.8  {qRow5}, [luma,:128], width
+    VLD1.8  {qRow14, qRow15}, [data]!
+    VST1.8  {qRow6}, [luma,:128], width
+
+    VLD1.8  {qRow0, qRow1}, [data]! ;//cb rows 0,1,2,3
+    VST1.8  {qRow7}, [luma,:128], width
+    VLD1.8  {qRow2, qRow3}, [data]! ;//cb rows 4,5,6,7
+    VST1.8  {qRow8}, [luma,:128], width
+    VLD1.8  {qRow4, qRow5}, [data]! ;//cr rows 0,1,2,3
+    VST1.8  {qRow9}, [luma,:128], width
+    VLD1.8  {qRow6, qRow7}, [data]! ;//cr rows 4,5,6,7
+    VST1.8  {qRow10}, [luma,:128], width
+    VST1.8  {dRow0}, [cb,:64], cwidth
+    VST1.8  {dRow8}, [cr,:64], cwidth
+    VST1.8  {qRow11}, [luma,:128], width
+    VST1.8  {dRow1}, [cb,:64], cwidth
+    VST1.8  {dRow9}, [cr,:64], cwidth
+    VST1.8  {qRow12}, [luma,:128], width
+    VST1.8  {dRow2}, [cb,:64], cwidth
+    VST1.8  {dRow10}, [cr,:64], cwidth
+    VST1.8  {qRow13}, [luma,:128], width
+    VST1.8  {dRow3}, [cb,:64], cwidth
+    VST1.8  {dRow11}, [cr,:64], cwidth
+    VST1.8  {qRow14}, [luma,:128], width
+    VST1.8  {dRow4}, [cb,:64], cwidth
+    VST1.8  {dRow12}, [cr,:64], cwidth
+    VST1.8  {qRow15}, [luma]
+    VST1.8  {dRow5}, [cb,:64], cwidth
+    VST1.8  {dRow13}, [cr,:64], cwidth
+    VST1.8  {dRow6}, [cb,:64], cwidth
+    VST1.8  {dRow14}, [cr,:64], cwidth
+    VST1.8  {dRow7}, [cb,:64]
+    VST1.8  {dRow15}, [cr,:64]
 
     VPOP    {q4-q7}
     POP     {r4-r6,pc}
 @    BX      lr
 
-    .endfunc
 
 
 
-- 
2.7.4


From cc3a9eb3a1c0f4c1f5f325659d4766d49f945e16 Mon Sep 17 00:00:00 2001
From: Yongqin Liu <yongqin.liu@linaro.org>
Date: Tue, 3 Nov 2015 17:44:40 +0800
Subject: [PATCH 094/119] codecs: update for check ifeq ($(TARGET_ARCH),arm)

This condition check will only pass when compile for 32bit platform.
It will not pass when generate the 32bit binary or libarary for 64bit platform.
update it with variants like LOCAL_SRC_FILES_arm to make it used by
32bit binary or library on 64biy platform as well

Change-Id: Ia887610a97c68fa58925d2d86c5eb29cb397d6ef
Signed-off-by: Yongqin Liu <yongqin.liu@linaro.org>
---
 media/libstagefright/Android.mk                    |  1 -
 media/libstagefright/codecs/aacenc/Android.mk      | 52 ++++++---------
 media/libstagefright/codecs/amrwbenc/Android.mk    | 78 +++++++++-------------
 media/libstagefright/codecs/common/Config.mk       | 24 -------
 media/libstagefright/codecs/mp3dec/Android.mk      | 13 ++--
 media/libstagefright/codecs/on2/h264dec/Android.mk | 14 ++--
 6 files changed, 69 insertions(+), 113 deletions(-)
 delete mode 100644 media/libstagefright/codecs/common/Config.mk

diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 8a1e729..c955d1f 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -20,7 +20,6 @@
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
-include frameworks/av/media/libstagefright/codecs/common/Config.mk
 
 LOCAL_SRC_FILES:=                         \
         ACodec.cpp                        \
diff --git a/media/libstagefright/codecs/aacenc/Android.mk b/media/libstagefright/codecs/aacenc/Android.mk
index 58ec3ba..530f6a7 100644
--- a/media/libstagefright/codecs/aacenc/Android.mk
+++ b/media/libstagefright/codecs/aacenc/Android.mk
@@ -1,6 +1,5 @@
 LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
-include frameworks/av/media/libstagefright/codecs/common/Config.mk
 
 AAC_LIBRARY = fraunhofer
 
@@ -35,24 +34,28 @@ LOCAL_SRC_FILES += \
 	src/transform.c \
 	src/memalign.c
 
-ifeq ($(VOTT), v5)
-LOCAL_SRC_FILES += \
-	src/asm/ARMV5E/AutoCorrelation_v5.s \
-	src/asm/ARMV5E/band_nrg_v5.s \
-	src/asm/ARMV5E/CalcWindowEnergy_v5.s \
-	src/asm/ARMV5E/PrePostMDCT_v5.s \
-	src/asm/ARMV5E/R4R8First_v5.s \
-	src/asm/ARMV5E/Radix4FFT_v5.s
-endif
-
-ifeq ($(VOTT), v7)
-LOCAL_SRC_FILES += \
-	src/asm/ARMV5E/AutoCorrelation_v5.s \
-	src/asm/ARMV5E/band_nrg_v5.s \
-	src/asm/ARMV5E/CalcWindowEnergy_v5.s \
-	src/asm/ARMV7/PrePostMDCT_v7.s \
-	src/asm/ARMV7/R4R8First_v7.s \
-	src/asm/ARMV7/Radix4FFT_v7.s
+ifneq ($(ARCH_ARM_HAVE_NEON),true)
+    LOCAL_SRC_FILES_arm := \
+        src/asm/ARMV5E/AutoCorrelation_v5.s \
+        src/asm/ARMV5E/band_nrg_v5.s \
+        src/asm/ARMV5E/CalcWindowEnergy_v5.s \
+        src/asm/ARMV5E/PrePostMDCT_v5.s \
+        src/asm/ARMV5E/R4R8First_v5.s \
+        src/asm/ARMV5E/Radix4FFT_v5.s
+
+    LOCAL_CFLAGS_arm := -DARMV5E -DARM_INASM -DARMV5_INASM
+    LOCAL_C_INCLUDES_arm := $(LOCAL_PATH)/src/asm/ARMV5E
+else
+    LOCAL_SRC_FILES_arm := \
+        src/asm/ARMV5E/AutoCorrelation_v5.s \
+        src/asm/ARMV5E/band_nrg_v5.s \
+        src/asm/ARMV5E/CalcWindowEnergy_v5.s \
+        src/asm/ARMV7/PrePostMDCT_v7.s \
+        src/asm/ARMV7/R4R8First_v7.s \
+        src/asm/ARMV7/Radix4FFT_v7.s
+    LOCAL_CFLAGS_arm := -DARMV5E -DARMV7Neon -DARM_INASM -DARMV5_INASM -DARMV6_INASM
+    LOCAL_C_INCLUDES_arm := $(LOCAL_PATH)/src/asm/ARMV5E
+    LOCAL_C_INCLUDES_arm += $(LOCAL_PATH)/src/asm/ARMV7
 endif
 
 LOCAL_MODULE := libstagefright_aacenc
@@ -71,17 +74,6 @@ LOCAL_C_INCLUDES := \
 	$(LOCAL_PATH)/inc \
 	$(LOCAL_PATH)/basic_op
 
-ifeq ($(VOTT), v5)
-LOCAL_CFLAGS += -DARMV5E -DARM_INASM -DARMV5_INASM
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV5E
-endif
-
-ifeq ($(VOTT), v7)
-LOCAL_CFLAGS += -DARMV5E -DARMV7Neon -DARM_INASM -DARMV5_INASM -DARMV6_INASM
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV5E
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV7
-endif
-
 LOCAL_CFLAGS += -Werror
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/codecs/amrwbenc/Android.mk b/media/libstagefright/codecs/amrwbenc/Android.mk
index 024a292..859d765 100644
--- a/media/libstagefright/codecs/amrwbenc/Android.mk
+++ b/media/libstagefright/codecs/amrwbenc/Android.mk
@@ -1,8 +1,5 @@
 LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
-include frameworks/av/media/libstagefright/codecs/common/Config.mk
-
-
 
 LOCAL_SRC_FILES := \
 	src/autocorr.c \
@@ -53,37 +50,39 @@ LOCAL_SRC_FILES := \
 	src/weight_a.c \
 	src/mem_align.c
 
-
-ifeq ($(VOTT), v5)
-LOCAL_SRC_FILES += \
-	src/asm/ARMV5E/convolve_opt.s \
-	src/asm/ARMV5E/cor_h_vec_opt.s \
-	src/asm/ARMV5E/Deemph_32_opt.s \
-	src/asm/ARMV5E/Dot_p_opt.s \
-	src/asm/ARMV5E/Filt_6k_7k_opt.s \
-	src/asm/ARMV5E/Norm_Corr_opt.s \
-	src/asm/ARMV5E/pred_lt4_1_opt.s \
-	src/asm/ARMV5E/residu_asm_opt.s \
-	src/asm/ARMV5E/scale_sig_opt.s \
-	src/asm/ARMV5E/Syn_filt_32_opt.s \
-	src/asm/ARMV5E/syn_filt_opt.s
-
-endif
-
-ifeq ($(VOTT), v7)
-LOCAL_SRC_FILES += \
-	src/asm/ARMV7/convolve_neon.s \
-	src/asm/ARMV7/cor_h_vec_neon.s \
-	src/asm/ARMV7/Deemph_32_neon.s \
-	src/asm/ARMV7/Dot_p_neon.s \
-	src/asm/ARMV7/Filt_6k_7k_neon.s \
-	src/asm/ARMV7/Norm_Corr_neon.s \
-	src/asm/ARMV7/pred_lt4_1_neon.s \
-	src/asm/ARMV7/residu_asm_neon.s \
-	src/asm/ARMV7/scale_sig_neon.s \
-	src/asm/ARMV7/Syn_filt_32_neon.s \
-	src/asm/ARMV7/syn_filt_neon.s
-
+ifneq ($(ARCH_ARM_HAVE_NEON),true)
+    LOCAL_SRC_FILES_arm := \
+        src/asm/ARMV5E/convolve_opt.s \
+        src/asm/ARMV5E/cor_h_vec_opt.s \
+        src/asm/ARMV5E/Deemph_32_opt.s \
+        src/asm/ARMV5E/Dot_p_opt.s \
+        src/asm/ARMV5E/Filt_6k_7k_opt.s \
+        src/asm/ARMV5E/Norm_Corr_opt.s \
+        src/asm/ARMV5E/pred_lt4_1_opt.s \
+        src/asm/ARMV5E/residu_asm_opt.s \
+        src/asm/ARMV5E/scale_sig_opt.s \
+        src/asm/ARMV5E/Syn_filt_32_opt.s \
+        src/asm/ARMV5E/syn_filt_opt.s
+
+    LOCAL_CFLAGS_arm := -DARM -DASM_OPT
+    LOCAL_C_INCLUDES_arm = $(LOCAL_PATH)/src/asm/ARMV5E
+else
+    LOCAL_SRC_FILES_arm := \
+        src/asm/ARMV7/convolve_neon.s \
+        src/asm/ARMV7/cor_h_vec_neon.s \
+        src/asm/ARMV7/Deemph_32_neon.s \
+        src/asm/ARMV7/Dot_p_neon.s \
+        src/asm/ARMV7/Filt_6k_7k_neon.s \
+        src/asm/ARMV7/Norm_Corr_neon.s \
+        src/asm/ARMV7/pred_lt4_1_neon.s \
+        src/asm/ARMV7/residu_asm_neon.s \
+        src/asm/ARMV7/scale_sig_neon.s \
+        src/asm/ARMV7/Syn_filt_32_neon.s \
+        src/asm/ARMV7/syn_filt_neon.s
+
+    LOCAL_CFLAGS_arm := -DARM -DARMV7 -DASM_OPT
+    LOCAL_C_INCLUDES_arm := $(LOCAL_PATH)/src/asm/ARMV5E
+    LOCAL_C_INCLUDES_arm += $(LOCAL_PATH)/src/asm/ARMV7
 endif
 
 # ARMV5E/Filt_6k_7k_opt.s does not compile with Clang.
@@ -104,17 +103,6 @@ LOCAL_C_INCLUDES := \
 	$(LOCAL_PATH)/src \
 	$(LOCAL_PATH)/inc
 
-ifeq ($(VOTT), v5)
-LOCAL_CFLAGS += -DARM -DASM_OPT
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV5E
-endif
-
-ifeq ($(VOTT), v7)
-LOCAL_CFLAGS += -DARM -DARMV7 -DASM_OPT
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV5E
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV7
-endif
-
 LOCAL_CFLAGS += -Werror
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/codecs/common/Config.mk b/media/libstagefright/codecs/common/Config.mk
deleted file mode 100644
index a843cef..0000000
--- a/media/libstagefright/codecs/common/Config.mk
+++ /dev/null
@@ -1,24 +0,0 @@
-#
-# This configure file is just for Linux projects against Android
-#
-
-VOPRJ :=
-VONJ :=
-
-# WARNING:
-# Using v7 breaks generic build
-ifeq ($(TARGET_ARCH),arm)
-VOTT := v5
-else
-VOTT := pc
-endif
-
-# Do we also need to check on ARCH_ARM_HAVE_ARMV7A? - probably not
-ifeq ($(TARGET_ARCH),arm)
-  ifeq ($(ARCH_ARM_HAVE_NEON),true)
-    VOTT := v7
-  endif
-endif
-
-VOTEST := 0
-
diff --git a/media/libstagefright/codecs/mp3dec/Android.mk b/media/libstagefright/codecs/mp3dec/Android.mk
index 2e2dfdf..d2a537f 100644
--- a/media/libstagefright/codecs/mp3dec/Android.mk
+++ b/media/libstagefright/codecs/mp3dec/Android.mk
@@ -28,19 +28,22 @@ LOCAL_SRC_FILES := \
  	src/pvmp3_stereo_proc.cpp \
  	src/pvmp3_reorder.cpp \
 
-ifeq ($(TARGET_ARCH),arm)
-LOCAL_SRC_FILES += \
+LOCAL_SRC_FILES_arm += \
 	src/asm/pvmp3_polyphase_filter_window_gcc.s \
  	src/asm/pvmp3_mdct_18_gcc.s \
  	src/asm/pvmp3_dct_9_gcc.s \
 	src/asm/pvmp3_dct_16_gcc.s
-else
-LOCAL_SRC_FILES += \
+LOCAL_SRC_FILES_other_archs := \
  	src/pvmp3_polyphase_filter_window.cpp \
  	src/pvmp3_mdct_18.cpp \
  	src/pvmp3_dct_9.cpp \
  	src/pvmp3_dct_16.cpp
-endif
+
+LOCAL_SRC_FILES_arm64  := $(LOCAL_SRC_FILES_other_archs)
+LOCAL_SRC_FILES_mips   := $(LOCAL_SRC_FILES_other_archs)
+LOCAL_SRC_FILES_mips64 := $(LOCAL_SRC_FILES_other_archs)
+LOCAL_SRC_FILES_x86    := $(LOCAL_SRC_FILES_other_archs)
+LOCAL_SRC_FILES_x86_64 := $(LOCAL_SRC_FILES_other_archs)
 
 LOCAL_C_INCLUDES := \
         frameworks/av/media/libstagefright/include \
diff --git a/media/libstagefright/codecs/on2/h264dec/Android.mk b/media/libstagefright/codecs/on2/h264dec/Android.mk
index bf03ad9..a16cbdf 100644
--- a/media/libstagefright/codecs/on2/h264dec/Android.mk
+++ b/media/libstagefright/codecs/on2/h264dec/Android.mk
@@ -84,17 +84,15 @@ MY_OMXDL_ASM_SRC := \
 	./omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_DequantTransformResidualFromPairAndAdd_s.S \
 	./omxdl/arm_neon/vc/m4p10/src_gcc/omxVCM4P10_TransformDequantChromaDCFromPair_s.S \
 
-ifeq ($(TARGET_ARCH),arm)
-  ifeq ($(ARCH_ARM_HAVE_NEON),true)
+
+ifeq ($(ARCH_ARM_HAVE_NEON),true)
     LOCAL_ARM_NEON   := true
-#    LOCAL_CFLAGS     := -std=c99 -D._NEON -D._OMXDL
-    LOCAL_CFLAGS     := -DH264DEC_NEON -DH264DEC_OMXDL
-    LOCAL_SRC_FILES  += $(MY_ASM) $(MY_OMXDL_C_SRC) $(MY_OMXDL_ASM_SRC)
-    LOCAL_C_INCLUDES += $(LOCAL_PATH)/./source/arm_neon_asm_gcc
-    LOCAL_C_INCLUDES += $(LOCAL_PATH)/./omxdl/arm_neon/api \
+    LOCAL_CFLAGS_arm     := -DH264DEC_NEON -DH264DEC_OMXDL
+    LOCAL_SRC_FILES_arm  := $(MY_ASM) $(MY_OMXDL_C_SRC) $(MY_OMXDL_ASM_SRC)
+    LOCAL_C_INCLUDES_arm := $(LOCAL_PATH)/./source/arm_neon_asm_gcc
+    LOCAL_C_INCLUDES_arm += $(LOCAL_PATH)/./omxdl/arm_neon/api \
                         $(LOCAL_PATH)/./omxdl/arm_neon/vc/api \
                         $(LOCAL_PATH)/./omxdl/arm_neon/vc/m4p10/api
-  endif
 endif
 
 LOCAL_SHARED_LIBRARIES := \
-- 
2.7.4


From 0867f8f11e897b0be772e4edfdde93ae42f7644f Mon Sep 17 00:00:00 2001
From: Ethan Chen <intervigil@gmail.com>
Date: Sun, 3 Jan 2016 14:09:23 -0800
Subject: [PATCH 095/119] libstagefright: Support YVU420SemiPlanar camera
 format

Change-Id: I631ba6267b3769d9da498329a39ac89c609be6d8
---
 media/libstagefright/CameraSource.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 88a87bf..2ee0b22 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -147,6 +147,10 @@ static int32_t getColorFormat(const char* colorFormat) {
         return OMX_COLOR_FormatAndroidOpaque;
     }
 
+    if (!strcmp(colorFormat, "YVU420SemiPlanar")) {
+        return OMX_QCOM_COLOR_FormatYVU420SemiPlanar;
+    }
+
     ALOGE("Uknown color format (%s), please add it to "
          "CameraSource::getColorFormat", colorFormat);
 
-- 
2.7.4


From 34b67ed0954dcf970a91b4307e79132b8e25ac29 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Tue, 12 Jan 2016 16:34:27 -0800
Subject: [PATCH 096/119] av: Add support for loading audio_effects_vendor.conf

 * In case a device has a /vendor partition which cannot be
   modified, this allows us to short-circuit the audio_effects.conf
   file which might be placed there with one of our own which
   lives on /system.

Change-Id: Ief87bd4cfba2c3188b0dff122d91f773b7f3d92d
---
 media/libeffects/factory/EffectsFactory.c           | 4 +++-
 services/audiopolicy/service/AudioPolicyEffects.cpp | 4 +++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/media/libeffects/factory/EffectsFactory.c b/media/libeffects/factory/EffectsFactory.c
index db7865a..c0a1c57 100644
--- a/media/libeffects/factory/EffectsFactory.c
+++ b/media/libeffects/factory/EffectsFactory.c
@@ -456,7 +456,9 @@ int init() {
     if (ignoreFxConfFiles) {
         ALOGI("Audio effects in configuration files will be ignored");
     } else {
-        if (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE, R_OK) == 0) {
+        if (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE2, R_OK) == 0) {
+            loadEffectConfigFile(AUDIO_EFFECT_VENDOR_CONFIG_FILE2);
+        } else if (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE, R_OK) == 0) {
             loadEffectConfigFile(AUDIO_EFFECT_VENDOR_CONFIG_FILE);
         } else if (access(AUDIO_EFFECT_DEFAULT_CONFIG_FILE, R_OK) == 0) {
             loadEffectConfigFile(AUDIO_EFFECT_DEFAULT_CONFIG_FILE);
diff --git a/services/audiopolicy/service/AudioPolicyEffects.cpp b/services/audiopolicy/service/AudioPolicyEffects.cpp
index e71d7a5..26857b1 100644
--- a/services/audiopolicy/service/AudioPolicyEffects.cpp
+++ b/services/audiopolicy/service/AudioPolicyEffects.cpp
@@ -40,7 +40,9 @@ namespace android {
 AudioPolicyEffects::AudioPolicyEffects()
 {
     // load automatic audio effect modules
-    if (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE, R_OK) == 0) {
+    if (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE2, R_OK) == 0) {
+        loadAudioEffectConfig(AUDIO_EFFECT_VENDOR_CONFIG_FILE2);
+    } else if (access(AUDIO_EFFECT_VENDOR_CONFIG_FILE, R_OK) == 0) {
         loadAudioEffectConfig(AUDIO_EFFECT_VENDOR_CONFIG_FILE);
     } else if (access(AUDIO_EFFECT_DEFAULT_CONFIG_FILE, R_OK) == 0) {
         loadAudioEffectConfig(AUDIO_EFFECT_DEFAULT_CONFIG_FILE);
-- 
2.7.4


From e2309a6aff344005e0e61b6ff399ec78cd99187c Mon Sep 17 00:00:00 2001
From: "Christopher R. Palmer" <crpalmer@gmail.com>
Date: Wed, 20 Jan 2016 20:31:42 -0500
Subject: [PATCH 097/119] av: "ACodec: update native window crop rectangle"
 depends on QCOM

Change-Id: If0cc81468ab7ee8fa0ec374a9f23e4004e7cb212
---
 media/libstagefright/ACodec.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 5f1761b..fd1bb43 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -979,6 +979,7 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
 #endif
             mRotationDegrees,
             usage);
+#ifdef QCOM_HARDWARE
     if (err == OK) {
         OMX_CONFIG_RECTTYPE rect;
         InitOMXParams(&rect);
@@ -996,6 +997,7 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
             err = native_window_set_crop(nativeWindow, &crop);
         }
     }
+#endif
     return err;
 }
 
-- 
2.7.4


From c7c1b726bd52f9f9224a6a14b9d0b0e05ad721cd Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Thu, 14 Jan 2016 11:36:26 -0800
Subject: [PATCH 098/119] Revert "Stagefright: Allow setting high-framerates in
 CameraSource"

This reverts commit b5ccf81c19a7e9ce9b330abe734f1bae76d50796.

That patch breaks "High Speed 60 FPS"
and it fails in CameraSource::checkFrameRate
which it compares the preview frame rate:
Failed to set preview frame rate to 30 fps. The actual frame rate is 60.

SAMBAR-1261

Change-Id: I6adf1432bf901e8ba37b1b86621e117e77cbf853
---
 media/libstagefright/CameraSource.cpp | 12 ------------
 1 file changed, 12 deletions(-)

diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 2ee0b22..1d90f27 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -327,12 +327,6 @@ status_t CameraSource::isCameraColorFormatSupported(
     return OK;
 }
 
-static int32_t getHighSpeedFrameRate(const CameraParameters& params) {
-    const char* hsr = params.get("video-hsr");
-    int32_t rate = (hsr != NULL && strncmp(hsr, "off", 3)) ? atoi(hsr) : 0;
-    return rate > 240 ? 240 : rate;
-}
-
 /*
  * Configure the camera to use the requested video size
  * (width and height) and/or frame rate. If both width and
@@ -385,10 +379,6 @@ status_t CameraSource::configureCamera(
                 params->get(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES);
         CHECK(supportedFrameRates != NULL);
         ALOGV("Supported frame rates: %s", supportedFrameRates);
-        if (getHighSpeedFrameRate(*params)) {
-            ALOGI("Use default 30fps for HighSpeed %dfps", frameRate);
-            frameRate = 30;
-        }
         char buf[4];
         snprintf(buf, 4, "%d", frameRate);
         if (strstr(supportedFrameRates, buf) == NULL) {
@@ -490,8 +480,6 @@ status_t CameraSource::checkFrameRate(
         ALOGE("Failed to retrieve preview frame rate (%d)", frameRateActual);
         return UNKNOWN_ERROR;
     }
-    int32_t highSpeedRate = getHighSpeedFrameRate(params);
-    frameRateActual = highSpeedRate ? highSpeedRate : frameRateActual;
 
     // Check the actual video frame rate against the target/requested
     // video frame rate.
-- 
2.7.4


From 37d0d76e9a6a90088766409f4bb8c5b17efe3163 Mon Sep 17 00:00:00 2001
From: Diogo Ferreira <defer@cyngn.com>
Date: Fri, 22 Jan 2016 14:42:31 +0000
Subject: [PATCH 099/119] AVUtils: hevc: Return 0 when codec data is malformed

This was returning ERROR_MALFORMED, which is a negative value,
since the function prototype returns size_t, it would be converted
to somewhere near 2**32 and would never fall into the actual error
checking clause in AVUtils::HEVCMuxer::makeHEVCCodecSpecificData.

Fixes android.mediastress.cts.HEVCR1080pAacLongPlayerTest#testPlay00

Ticket: CYNGNOS-1683
Change-Id: I13e6a76cb0ee4a6b730e1eb1023320b74a0539c7
---
 media/libavextensions/stagefright/AVUtils.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index 71a1365..f172130 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -448,7 +448,7 @@ status_t AVUtils::HEVCMuxer::makeHEVCCodecSpecificData(
     List<HEVCParamSet> picParamSets;
 
     if ((*codecSpecificDataSize = parseHEVCCodecSpecificData(data, size,
-                                   vidParamSets, seqParamSets, picParamSets)) <= 0) {
+                                   vidParamSets, seqParamSets, picParamSets)) == 0) {
         ALOGE("cannot parser codec specific data, bailing out");
         return ERROR_MALFORMED;
     }
@@ -885,12 +885,12 @@ size_t AVUtils::HEVCMuxer::parseHEVCCodecSpecificData(
             }
         } else {
             ALOGE("Only VPS, SPS and PPS Nal units are expected");
-            return ERROR_MALFORMED;
+            return 0;
         }
 
         if (nextStartCode == NULL) {
             ALOGE("Next start code is NULL");
-            return ERROR_MALFORMED;
+            return 0;
         }
 
         // Move on to find the next parameter set
-- 
2.7.4


From b9828546bd6f8df20ee7b1bf398f8afedf6a5b5e Mon Sep 17 00:00:00 2001
From: Weiyin Jiang <wjiang@codeaurora.org>
Date: Thu, 13 Nov 2014 12:56:05 +0800
Subject: [PATCH 100/119] audio: omx encoder isn't expected for raw recording

Raw recording doesn't require any encoder, so no OMX encoder will be
created and audio source will be directly used as media source.

UNKNOWN_ERROR error will be threwn if call AudioSource::start()
continuously, so we should avoid omx encoder operations if it's not
created for raw recording.

CYNGNOS-1679

Change-Id: Ib38c4e42b7667e9bf882cddb15422d0dd598b60e
CRs-Fixed: 752419
(cherry picked from commit 587267232a2829936510bbe46591863403782d1a)
---
 .../libmediaplayerservice/StagefrightRecorder.cpp  | 28 +++++++++++++++-------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index d58b500..21925f5 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -2044,10 +2044,16 @@ status_t StagefrightRecorder::setSourcePause(bool pause) {
             }
         }
         if (mAudioEncoderOMX != NULL) {
-            err = mAudioEncoderOMX->pause();
-            if (err != OK) {
-                ALOGE("OMX AudioEncoder pause failed");
-                return err;
+            if (mAudioEncoderOMX != mAudioSourceNode) {
+                err = mAudioEncoderOMX->pause();
+                if (err != OK) {
+                    ALOGE("OMX AudioEncoder pause failed");
+                    return err;
+                }
+            } else {
+                // If AudioSource is the same as MediaSource(as in LPCM),
+                // bypass omx encoder pause() call.
+                ALOGV("OMX AudioEncoder->pause() bypassed");
             }
         }
         if (mVideoSourceNode != NULL) {
@@ -2087,10 +2093,16 @@ status_t StagefrightRecorder::setSourcePause(bool pause) {
             }
         }
         if (mAudioEncoderOMX != NULL) {
-            err = mAudioEncoderOMX->start();
-            if (err != OK) {
-                ALOGE("OMX AudioEncoder start failed");
-                return err;
+            if (mAudioEncoderOMX != mAudioSourceNode) {
+                err = mAudioEncoderOMX->start();
+                if (err != OK) {
+                    ALOGE("OMX AudioEncoder start failed");
+                    return err;
+                }
+            } else {
+                // If AudioSource is the same as MediaSource(as in LPCM),
+                // bypass omx encoder start() call.
+                ALOGV("OMX AudioEncoder->start() bypassed");
             }
         }
     }
-- 
2.7.4


From 0385a88de3dc2be23f40610b3584947720795f23 Mon Sep 17 00:00:00 2001
From: Steve Kondik <shade@chemlab.org>
Date: Mon, 29 Feb 2016 17:32:19 -0800
Subject: [PATCH 101/119] stagefright: Don't crash on invalid / null AVCC atoms
 in MKV

 * Seen in the wild. If a file contains an invalid track, skip it.
 * Also correct AVCC atom size check in Matroska extractor.

REF: CYNGNOS-2168
Change-Id: I589aadbd689c9a00e1dca613e61fcec5b06ed69a
---
 media/libstagefright/MPEG4Extractor.cpp             | 12 +++++++-----
 media/libstagefright/matroska/MatroskaExtractor.cpp | 13 +++++++------
 2 files changed, 14 insertions(+), 11 deletions(-)

diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index caab461..7e19beb 100755
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -3544,11 +3544,13 @@ MPEG4Source::MPEG4Source(
 
         const uint8_t *ptr = (const uint8_t *)data;
 
-        CHECK(size >= 7);
-        CHECK_EQ((unsigned)ptr[0], 1u);  // configurationVersion == 1
-
-        // The number of bytes used to encode the length of a NAL unit.
-        mNALLengthSize = 1 + (ptr[4] & 3);
+        if (size < 7 || ptr[0] != 1) {
+            ALOGE("Invalid AVCC atom, size %zu, configurationVersion: %d",
+                    size, ptr[0]);
+        } else {
+            // The number of bytes used to encode the length of a NAL unit.
+            mNALLengthSize = 1 + (ptr[4] & 3);
+        }
     } else if (mIsHEVC) {
         uint32_t type;
         const void *data;
diff --git a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
index 72112be..412beed 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -228,18 +228,19 @@ MatroskaSource::MatroskaSource(
     mIsAudio = !strncasecmp("audio/", mime, 6);
 
     if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) {
-        mType = AVC;
-
         uint32_t dummy;
         const uint8_t *avcc;
         size_t avccSize;
         CHECK(meta->findData(
                     kKeyAVCC, &dummy, (const void **)&avcc, &avccSize));
 
-        CHECK_GE(avccSize, 5u);
-
-        mNALSizeLen = 1 + (avcc[4] & 3);
-        ALOGV("mNALSizeLen = %zu", mNALSizeLen);
+        if (avccSize < 7) {
+            ALOGW("Invalid AVCC atom in track, size %zu", avccSize);
+        } else {
+            mNALSizeLen = 1 + (avcc[4] & 3);
+            ALOGV("mNALSizeLen = %zu", mNALSizeLen);
+            mType = AVC;
+        }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)) {
         mType = HEVC;
 
-- 
2.7.4


From 41c0c027045d554bec93a1bbc56bc103d7a9b020 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Mon, 7 Mar 2016 15:22:22 -0800
Subject: [PATCH 102/119] stagefright: Support audio in slow motion

We need to query AVUtil for slow motion recording to
support audio in slow motion recording instead of using
mCaptureFps and mCaptureFpsEnable, since qcom camera1 HAL
don't call setCaptureRate for slow motion recording.

CYNGNOS-2196

Change-Id: I7b75ab44499ed13cb1e4e6f527103ec0f09ffcc8
---
 .../libmediaplayerservice/StagefrightRecorder.cpp  | 24 ++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 21925f5..18df1fc 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -963,6 +963,30 @@ sp<MediaSource> StagefrightRecorder::createAudioSource() {
         }
     }
 
+    // If using QCOM extension (Camera 1 HAL) for slow motion recording
+    // mCaptureFpsEnable and mCaptureFps will not be set via setCaptureRate
+    // We need to query from AVUtil, in order to support slow motion audio recording
+    if (mVideoSourceNode != NULL) {
+        int hfrRatio =  AVUtils::get()->HFRUtils().getHFRRatio(mVideoSourceNode->getFormat());
+        if (hfrRatio != 1) {
+            // Upscale the sample rate for slow motion recording.
+            // Fail audio source creation if source sample rate is too high, as it could
+            // cause out-of-memory due to large input buffer size. And audio recording
+            // probably doesn't make sense in the scenario, since the slow-down factor
+            // is probably huge (eg. mSampleRate=48K, hfrRatio=240, mFrameRate=1).
+            const static int32_t SAMPLE_RATE_HZ_MAX = 192000;
+            sourceSampleRate =
+                    (mSampleRate * hfrRatio + mFrameRate / 2) / mFrameRate;
+            if (sourceSampleRate < mSampleRate || sourceSampleRate > SAMPLE_RATE_HZ_MAX) {
+                ALOGE("source sample rate out of range! "
+                        "(mSampleRate %d, hfrRatio %d, mFrameRate %d",
+                        mSampleRate, hfrRatio, mFrameRate);
+                return NULL;
+            }
+        }
+    }
+
+
     sp<AudioSource> audioSource = AVFactory::get()->createAudioSource(
         mAudioSource,
         mOpPackageName,
-- 
2.7.4


From 8268faf99cc8c9672a583cf83c692d093def983f Mon Sep 17 00:00:00 2001
From: Haynes Mathew George <hgeorge@codeaurora.org>
Date: Wed, 6 Jan 2016 17:03:22 -0800
Subject: [PATCH 103/119] SoftVorbis: memory access check

Check for valid input buffer header before
reading from it. This seems to be manifested
only when memory map of an input buffer sent from
a remote process fails in mediaserver context.

CRs-Fixed: 916568

Change-Id: I4ee16e7104c2d8bf579f80201864009e51cd1b25
---
 media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp | 14 +++++++++++++-
 media/libstagefright/codecs/vorbis/dec/SoftVorbis.h   |  2 ++
 2 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
index a715e16..7209796 100644
--- a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
+++ b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
@@ -56,7 +56,8 @@ SoftVorbis::SoftVorbis(
       mNumFramesLeftOnPage(-1),
       mSawInputEos(false),
       mSignalledOutputEos(false),
-      mOutputPortSettingsChange(NONE) {
+      mOutputPortSettingsChange(NONE),
+      mSignalledError(false) {
     initPorts();
     CHECK_EQ(initDecoder(), (status_t)OK);
 }
@@ -267,10 +268,21 @@ void SoftVorbis::onQueueFilled(OMX_U32 portIndex) {
         return;
     }
 
+    if (mSignalledError) {
+        return;
+    }
+
     if (portIndex == 0 && mInputBufferCount < 2) {
         BufferInfo *info = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *header = info->mHeader;
 
+        if (!header || !header->pBuffer) {
+            ALOGE("b/25727575 has happened. report error");
+            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
+            mSignalledError = true;
+            return;
+        }
+
         const uint8_t *data = header->pBuffer + header->nOffset;
         size_t size = header->nFilledLen;
         if (size < 7) {
diff --git a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.h b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.h
index 1d00816..7decc5a 100644
--- a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.h
+++ b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.h
@@ -68,6 +68,8 @@ private:
         AWAITING_ENABLED
     } mOutputPortSettingsChange;
 
+    bool mSignalledError;
+
     void initPorts();
     status_t initDecoder();
     bool isConfigured() const;
-- 
2.7.4


From 5c191c29dcc887389d7547e6f9b43c184fc616dd Mon Sep 17 00:00:00 2001
From: Santhosh Behara <santhoshbehara@codeaurora.org>
Date: Thu, 26 Nov 2015 15:27:50 +0530
Subject: [PATCH 104/119] ACodec: update the right size and crop in smooth
 streaming case

In smooth streaming enabled case, the max width and max height
sizes should be updated in native window. And the crop rectangle
should also be updated.

Change-Id: I4a15aa24a51b495141001dd43adec7005ab0c742
---
 media/libstagefright/ACodec.cpp | 18 ++++++++++++++++--
 1 file changed, 16 insertions(+), 2 deletions(-)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index fd1bb43..dcddf9d 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -968,10 +968,24 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
 #endif
 
     ALOGV("gralloc usage: %#x(OMX) => %#x(ACodec)", omxUsage, usage);
+    int32_t width = 0, height = 0;
+    int32_t isAdaptivePlayback = 0;
+
+    if (mInputFormat->findInt32("adaptive-playback", &isAdaptivePlayback)
+            && isAdaptivePlayback
+            && mInputFormat->findInt32("max-width", &width)
+            && mInputFormat->findInt32("max-height", &height)) {
+        width = max(width, (int32_t)def.format.video.nFrameWidth);
+        height = max(height, (int32_t)def.format.video.nFrameHeight);
+        ALOGV("Adaptive playback width = %d, height = %d", width, height);
+    } else {
+        width = def.format.video.nFrameWidth;
+        height = def.format.video.nFrameHeight;
+    }
     err = setNativeWindowSizeFormatAndUsage(
             nativeWindow,
-            def.format.video.nFrameWidth,
-            def.format.video.nFrameHeight,
+            width,
+            height,
 #ifdef USE_SAMSUNG_COLORFORMAT
             eNativeColorFormat,
 #else
-- 
2.7.4


From 525e3de6c96bf082ba9fd77daeee0ef1e7bf9c4b Mon Sep 17 00:00:00 2001
From: Li Sun <sunli@codeaurora.org>
Date: Wed, 9 Dec 2015 18:28:10 +0530
Subject: [PATCH 105/119] Nuplayer: Flush the decoder if seamless format change
 is supported

In smooth streaming enabled case, flush the decoder
if seamless format change is supported.
Otherwise,ramdomly video frames with old resolution
are queued to the new surface and results in green frames.

Calling flush ensures that all the old video frames
are cleared.

Change-Id: Ia020a01fd0eaa8af8e48b6edb526a3f53875b068
---
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  | 15 ++++++++++++--
 .../nuplayer/NuPlayerDecoder.cpp                   | 23 +++++++++++++++++++---
 .../nuplayer/NuPlayerDecoder.h                     |  1 +
 3 files changed, 34 insertions(+), 5 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index bc12177..da4c4c5 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -957,10 +957,21 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                         audio ? "audio" : "video", formatChange);
 
                 if (formatChange) {
-                    mDeferredActions.push_back(
-                            new FlushDecoderAction(
+                    int32_t seamlessChange = 0;
+                    if (msg->findInt32("video-seamlessChange", &seamlessChange) && seamlessChange) {
+                        ALOGE("video decoder seamlessChange in smooth streaming mode, "
+                             "flush the video decoder");
+                        mDeferredActions.push_back(
+                                new FlushDecoderAction(FLUSH_CMD_NONE, FLUSH_CMD_FLUSH));
+                        mDeferredActions.push_back(new ResumeDecoderAction(false));
+                        processDeferredActions();
+                        break;
+                    } else {
+                        mDeferredActions.push_back(
+                                new FlushDecoderAction(
                                 audio ? FLUSH_CMD_SHUTDOWN : FLUSH_CMD_NONE,
                                 audio ? FLUSH_CMD_NONE : FLUSH_CMD_SHUTDOWN));
+                    }
                 }
 
                 mDeferredActions.push_back(
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index 68d23dd..93b0dc2 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -94,6 +94,7 @@ NuPlayer::Decoder::Decoder(
       mIsSecure(false),
       mFormatChangePending(false),
       mTimeChangePending(false),
+      mVideoFormatChangeDoFlushOnly(false),
       mResumePending(false),
       mComponentName("decoder") {
     mCodecLooper = new ALooper;
@@ -264,6 +265,7 @@ void NuPlayer::Decoder::onConfigure(const sp<AMessage> &format) {
 
     mFormatChangePending = false;
     mTimeChangePending = false;
+    mVideoFormatChangeDoFlushOnly = false;
 
     ++mBufferGeneration;
 
@@ -783,9 +785,20 @@ status_t NuPlayer::Decoder::fetchInputData(sp<AMessage> &reply) {
                     mTimeChangePending = true;
                     err = ERROR_END_OF_STREAM;
                 } else if (seamlessFormatChange) {
-                    // reuse existing decoder and don't flush
-                    rememberCodecSpecificData(newFormat);
-                    continue;
+                    if (!mIsAudio &&
+                            newFormat != NULL &&
+                            newFormat->contains("prefer-adaptive-playback")) {
+                        ALOGV("in smooth streaming mode, "
+                             "do video flush in video seamless format change");
+                        mFormatChangePending = true;
+                        mVideoFormatChangeDoFlushOnly = true;
+                        err = ERROR_END_OF_STREAM;
+                    } else {
+                        // reuse existing decoder and don't flush
+                        rememberCodecSpecificData(newFormat);
+                        continue;
+                    }
+
                 } else {
                     // This stream is unaffected by the discontinuity
                     return -EWOULDBLOCK;
@@ -1013,10 +1026,14 @@ void NuPlayer::Decoder::finishHandleDiscontinuity(bool flushOnTimeChange) {
     sp<AMessage> msg = mNotify->dup();
     msg->setInt32("what", kWhatInputDiscontinuity);
     msg->setInt32("formatChange", mFormatChangePending);
+    if (mVideoFormatChangeDoFlushOnly) {
+        msg->setInt32("video-seamlessChange", mVideoFormatChangeDoFlushOnly);
+    }
     msg->post();
 
     mFormatChangePending = false;
     mTimeChangePending = false;
+    mVideoFormatChangeDoFlushOnly = false;
 }
 
 bool NuPlayer::Decoder::supportsSeamlessAudioFormatChange(
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
index 67cc310..af54979 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
@@ -114,6 +114,7 @@ protected:
     bool mIsSecure;
     bool mFormatChangePending;
     bool mTimeChangePending;
+    bool mVideoFormatChangeDoFlushOnly;
 
     bool mResumePending;
     AString mComponentName;
-- 
2.7.4


From b757f1edaf2d0a89650076004f2ee5222c3594b1 Mon Sep 17 00:00:00 2001
From: Surajit Podder <spodder@codeaurora.org>
Date: Wed, 13 Jan 2016 12:42:43 +0530
Subject: [PATCH 106/119] video: Add support to push blank buffers on surface
 switch

Add support to push blank buffers only on surface switch.
Setting "push-blank-buffers-on-switch" key with value 1
will enable this feature.

Change-Id: I4a0fc48fe24c09a6b8d0e2e0fc4dc2e96d3178bf
---
 include/media/stagefright/ACodec.h | 1 +
 media/libstagefright/ACodec.cpp    | 9 ++++++++-
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index d27202f..8aa23d5 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -167,6 +167,7 @@ protected:
         kFlagIsSecure                                 = 1,
         kFlagPushBlankBuffersToNativeWindowOnShutdown = 2,
         kFlagIsGrallocUsageProtected                  = 4,
+        kFlagPushBlankBuffersToNativeWindowOnSwitch = 1 << 7,
     };
 
     enum {
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index dcddf9d..1ed6dbb 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -810,7 +810,8 @@ status_t ACodec::handleSetSurface(const sp<Surface> &surface) {
     }
 
     // push blank buffers to previous window if requested
-    if (mFlags & kFlagPushBlankBuffersToNativeWindowOnShutdown) {
+    if (mFlags & kFlagPushBlankBuffersToNativeWindowOnShutdown ||
+        mFlags & kFlagPushBlankBuffersToNativeWindowOnSwitch) {
         pushBlankBuffersToNativeWindow(mNativeWindow.get());
     }
 
@@ -2034,6 +2035,12 @@ status_t ACodec::configureCodec(
                     && push != 0) {
                 mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;
             }
+
+            int32_t val;
+            if (msg->findInt32("push-blank-buffers-on-switch", &val)
+                    && val != 0) {
+                mFlags |= kFlagPushBlankBuffersToNativeWindowOnSwitch;
+            }
         }
 
         int32_t rotationDegrees;
-- 
2.7.4


From 837911647252bd82db17ca14ec8b2bb7eba0b6c9 Mon Sep 17 00:00:00 2001
From: Surajit Podder <spodder@codeaurora.org>
Date: Mon, 1 Feb 2016 13:51:18 +0530
Subject: [PATCH 107/119] video: Add metadata support for DataSource

Add meta() API to query and update DataSource
metadata.

Change-Id: Ibc99fbb6b9bdd6ca6a9d0b25883ba5907946a81d
---
 include/media/stagefright/DataSource.h | 8 ++++++--
 media/libstagefright/DataSource.cpp    | 1 -
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index c0401cf..c8ad05e 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -27,10 +27,10 @@
 #include <utils/RefBase.h>
 #include <utils/threads.h>
 #include <drm/DrmManagerClient.h>
+#include <media/stagefright/foundation/AMessage.h>
 
 namespace android {
 
-struct AMessage;
 struct AString;
 class  IDataSource;
 struct IMediaHTTPService;
@@ -57,7 +57,7 @@ public:
     static sp<DataSource> CreateMediaHTTP(const sp<IMediaHTTPService> &httpService);
     static sp<DataSource> CreateFromIDataSource(const sp<IDataSource> &source);
 
-    DataSource() {}
+    DataSource() : mMeta(new AMessage) {}
 
     virtual status_t initCheck() const = 0;
 
@@ -122,10 +122,14 @@ public:
 
     virtual String8 getMIMEType() const;
 
+    virtual sp<AMessage> meta() { return mMeta; }
+
 protected:
     virtual ~DataSource() {}
 
 private:
+    sp<AMessage> mMeta;
+
     static Mutex gSnifferMutex;
     static List<SnifferFunc> gSniffers;
     static List<SnifferFunc> gExtraSniffers;
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index b833f9e..34f0649 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -38,7 +38,6 @@
 #include <media/IMediaHTTPConnection.h>
 #include <media/IMediaHTTPService.h>
 #include <media/stagefright/foundation/ADebug.h>
-#include <media/stagefright/foundation/AMessage.h>
 #include <media/stagefright/DataSource.h>
 #include <media/stagefright/DataURISource.h>
 #include <media/stagefright/FileSource.h>
-- 
2.7.4


From fdb63c3762491fa117240f22a24d17d417f8ec6a Mon Sep 17 00:00:00 2001
From: Shalaj Jain <shalajj@codeaurora.org>
Date: Mon, 25 Jan 2016 13:20:10 -0800
Subject: [PATCH 108/119] stagefright: Clear RenderQueue on port settings
 changed

Clear the RenderTracker RenderQueue before allocating new set of
buffers during port settings change. The graphicBuffers inside
the RenderQueue hold the actual buffer references which prevents
them from being freed until this queue is cleared.
Do not wait till executing state to clear the queue as then
overall memory consumption goes up for the brief period.

CRs-Fixed: 972394
Change-Id: If50ffc2d517f793a59c88d3fb213bf4c23b8c9f7
---
 media/libstagefright/ACodec.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 1ed6dbb..ccac6ef 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -6882,6 +6882,11 @@ bool ACodec::OutputPortSettingsChangedState::onOMXEvent(
                             mCodec->mNode, OMX_CommandPortEnable, kPortIndexOutput);
                 }
 
+                /* Clear the RenderQueue in which queued GraphicBuffers hold the
+                 * actual buffer references in order to free them early.
+                 */
+                mCodec->mRenderTracker.clear(systemTime(CLOCK_MONOTONIC));
+
                 if (err == OK) {
                     err = mCodec->allocateBuffersOnPort(kPortIndexOutput);
                     ALOGE_IF(err != OK, "Failed to allocate output port buffers after port "
-- 
2.7.4


From 62f9514b238e0b5a77ff2cb3045d4ada654e65c3 Mon Sep 17 00:00:00 2001
From: c457 <android.c357@gmail.com>
Date: Tue, 5 Jan 2016 21:06:56 -0600
Subject: [PATCH 109/119] audiopolicy: squashed support for pre-kitkat audio
 blobs

Squash of the following:

commit 40c41a743a4345ad26b6eab41755c5b474f75853
Author: chrmhoffmann <chrmhoffmann@gmail.com>
Date:   Sat Nov 29 19:32:27 2014 +0100

    pre kitkat audio legacy policy fix for hotword (ok google)

    Change-Id: I5bb90fb90f373461a98609226a5cea50ac5266e9

commit d47b306954b96142323c79b976edeb3eaa3b46dd
Author: chrmhoffmann <chrmhoffmann@gmail.com>
Date:   Sun Nov 23 18:22:35 2014 +0100
commit d47b306954b96142323c79b976edeb3eaa3b46dd
Author: chrmhoffmann <chrmhoffmann@gmail.com>
Date:   Sun Nov 23 18:22:35 2014 +0100

    pre-kitkat audio policy blobs re-activated.

    Change-Id: Idfcb03d0a4aa0a099bf5a17b7bf592ab402e3255

Change-Id: Iae65c6ccb6dcb120a6fc20978b8a69e6af39a51a
---
 services/audiopolicy/Android.mk                                 | 4 ++++
 services/audiopolicy/service/AudioPolicyClientImplLegacy.cpp    | 5 +++++
 services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp | 9 +++++++++
 3 files changed, 18 insertions(+)

diff --git a/services/audiopolicy/Android.mk b/services/audiopolicy/Android.mk
index 7dc5a1f..0a1658a 100644
--- a/services/audiopolicy/Android.mk
+++ b/services/audiopolicy/Android.mk
@@ -41,6 +41,10 @@ LOCAL_SHARED_LIBRARIES += \
     libaudiopolicymanager
 endif
 
+ifeq ($(BOARD_HAVE_PRE_KITKAT_AUDIO_POLICY_BLOB),true)
+    LOCAL_CFLAGS += -DHAVE_PRE_KITKAT_AUDIO_POLICY_BLOB
+endif
+
 LOCAL_STATIC_LIBRARIES := \
     libmedia_helper \
     libaudiopolicycomponents
diff --git a/services/audiopolicy/service/AudioPolicyClientImplLegacy.cpp b/services/audiopolicy/service/AudioPolicyClientImplLegacy.cpp
index a79f8ae..36c85f1 100644
--- a/services/audiopolicy/service/AudioPolicyClientImplLegacy.cpp
+++ b/services/audiopolicy/service/AudioPolicyClientImplLegacy.cpp
@@ -125,8 +125,13 @@ audio_io_handle_t aps_open_output_on_module(void *service __unused,
                                                    audio_output_flags_t flags,
                                                    const audio_offload_info_t *offloadInfo)
 {
+#ifdef HAVE_PRE_KITKAT_AUDIO_POLICY_BLOB
+    return open_output(module, pDevices, pSamplingRate, pFormat, pChannelMask,
+                          pLatencyMs, flags, NULL);
+#else
     return open_output(module, pDevices, pSamplingRate, pFormat, pChannelMask,
                           pLatencyMs, flags, offloadInfo);
+#endif
 }
 
 audio_io_handle_t aps_open_dup_output(void *service __unused,
diff --git a/services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp b/services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp
index 13af3ef..146e69a 100644
--- a/services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp
+++ b/services/audiopolicy/service/AudioPolicyInterfaceImplLegacy.cpp
@@ -261,6 +261,11 @@ status_t AudioPolicyService::getInputForAttr(const audio_attributes_t *attr,
         return BAD_VALUE;
     }
 
+#ifdef HAVE_PRE_KITKAT_AUDIO_POLICY_BLOB
+    if (inputSource == AUDIO_SOURCE_HOTWORD)
+        inputSource = AUDIO_SOURCE_VOICE_RECOGNITION;
+#endif
+
     sp<AudioPolicyEffects>audioPolicyEffects;
     {
         Mutex::Autolock _l(mLock);
@@ -510,6 +515,9 @@ status_t AudioPolicyService::queryDefaultPreProcessing(int audioSession,
 
 bool AudioPolicyService::isOffloadSupported(const audio_offload_info_t& info)
 {
+#ifdef HAVE_PRE_KITKAT_AUDIO_POLICY_BLOB
+    return false;
+#else
     if (mpAudioPolicy == NULL) {
         ALOGV("mpAudioPolicy == NULL");
         return false;
@@ -521,6 +529,7 @@ bool AudioPolicyService::isOffloadSupported(const audio_offload_info_t& info)
     }
 
     return mpAudioPolicy->is_offload_supported(mpAudioPolicy, &info);
+#endif
 }
 
 status_t AudioPolicyService::listAudioPorts(audio_port_role_t role __unused,
-- 
2.7.4


From b057839a7c9139f8ea9adc1085f74382d61cbfa7 Mon Sep 17 00:00:00 2001
From: "Joshua J. Drake" <android-open-source@qoop.org>
Date: Thu, 9 Apr 2015 00:46:42 -0500
Subject: [PATCH 110/119] MPEG4Extractor: still more NULL dereference fixes

When processing various FourCC values within MP4 media, mLastTrack is accessed
without first ensuring that a track has been encoutered. Check for NULL and
bail out instead of crashing.

Bug: 20139950
Change-Id: Ie16687024d17348f576a0e13bd60bd4d6898de91
---
 media/libstagefright/MPEG4Extractor.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 7e19beb..9b7c2b7 100755
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -2189,6 +2189,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 return ERROR_IO;
             }
 
+            if (mLastTrack == NULL)
+                return ERROR_MALFORMED;
+
             uint32_t type = ntohl(buffer);
             // For the 3GPP file format, the handler-type within the 'hdlr' box
             // shall be 'text'. We also want to support 'sbtl' handler type
-- 
2.7.4


From e837001d58fe2f68b901ed7a9de13ffcebba3fdb Mon Sep 17 00:00:00 2001
From: Ashok Bhat <ashok.bhat@arm.com>
Date: Tue, 3 Jun 2014 12:48:51 +0100
Subject: [PATCH 111/119] h264dec: Use intptr_t when a pointer is treated as an
 integer

Change-Id: I83057565a842da31ee137fac674af496c1fc18af
Signed-off-by: Ashok Bhat <ashok.bhat@arm.com>
---
 .../libstagefright/codecs/on2/h264dec/omxdl/arm_neon/api/armCOMM.h  | 6 +++---
 .../libstagefright/codecs/on2/h264dec/omxdl/reference/api/armCOMM.h | 6 +++---
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/api/armCOMM.h b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/api/armCOMM.h
index 91e38b8..1992885 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/api/armCOMM.h
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/arm_neon/api/armCOMM.h
@@ -86,7 +86,7 @@ typedef OMX_S16 ARM_BLOCK8x8[64];
 
 /* Alignment operation */
 
-#define armAlignToBytes(Ptr,N)      (Ptr + ( ((N-(int)Ptr)&(N-1)) / sizeof(*Ptr) ))
+#define armAlignToBytes(Ptr,N)      (Ptr + ( ((N-(intptr_t)Ptr)&(N-1)) / sizeof(*Ptr) ))
 #define armAlignTo2Bytes(Ptr)       armAlignToBytes(Ptr,2)
 #define armAlignTo4Bytes(Ptr)       armAlignToBytes(Ptr,4)
 #define armAlignTo8Bytes(Ptr)       armAlignToBytes(Ptr,8)
@@ -98,8 +98,8 @@ typedef OMX_S16 ARM_BLOCK8x8[64];
 #define armRetDataErrIf(condition, code) if(condition) { return (code); }
 
 #ifndef ALIGNMENT_DOESNT_MATTER
-#define armIsByteAligned(Ptr,N)     ((((int)(Ptr)) % N)==0)
-#define armNotByteAligned(Ptr,N)    ((((int)(Ptr)) % N)!=0)
+#define armIsByteAligned(Ptr,N)     ((((intptr_t)(Ptr)) % N)==0)
+#define armNotByteAligned(Ptr,N)    ((((intptr_t)(Ptr)) % N)!=0)
 #else
 #define armIsByteAligned(Ptr,N)     (1)
 #define armNotByteAligned(Ptr,N)    (0)
diff --git a/media/libstagefright/codecs/on2/h264dec/omxdl/reference/api/armCOMM.h b/media/libstagefright/codecs/on2/h264dec/omxdl/reference/api/armCOMM.h
index fbb97e2..7304863 100644
--- a/media/libstagefright/codecs/on2/h264dec/omxdl/reference/api/armCOMM.h
+++ b/media/libstagefright/codecs/on2/h264dec/omxdl/reference/api/armCOMM.h
@@ -86,7 +86,7 @@ typedef OMX_S16 ARM_BLOCK8x8[64];
 
 /* Alignment operation */
 
-#define armAlignToBytes(Ptr,N)      (Ptr + ( ((N-(int)Ptr)&(N-1)) / sizeof(*Ptr) ))
+#define armAlignToBytes(Ptr,N)      (Ptr + ( ((N-(intptr_t)Ptr)&(N-1)) / sizeof(*Ptr) ))
 #define armAlignTo2Bytes(Ptr)       armAlignToBytes(Ptr,2)
 #define armAlignTo4Bytes(Ptr)       armAlignToBytes(Ptr,4)
 #define armAlignTo8Bytes(Ptr)       armAlignToBytes(Ptr,8)
@@ -98,8 +98,8 @@ typedef OMX_S16 ARM_BLOCK8x8[64];
 #define armRetDataErrIf(condition, code) if(condition) { return (code); }
 
 #ifndef ALIGNMENT_DOESNT_MATTER
-#define armIsByteAligned(Ptr,N)     ((((int)(Ptr)) % N)==0)
-#define armNotByteAligned(Ptr,N)    ((((int)(Ptr)) % N)!=0)
+#define armIsByteAligned(Ptr,N)     ((((intptr_t)(Ptr)) % N)==0)
+#define armNotByteAligned(Ptr,N)    ((((intptr_t)(Ptr)) % N)!=0)
 #else
 #define armIsByteAligned(Ptr,N)     (1)
 #define armNotByteAligned(Ptr,N)    (0)
-- 
2.7.4


From 19086b69135f7bc0856e3ba537cf5e5c9e867dfa Mon Sep 17 00:00:00 2001
From: Andreas Gampe <agampe@google.com>
Date: Wed, 29 Jul 2015 16:46:25 -0700
Subject: [PATCH 112/119] Stagefright: Remove unused variables and files

For build-system CFLAGS clean-up.

Bug: 18632512

(cherry picked from commit 765b4172f1ffb2c4e2de89163bb888fa352de664)

Change-Id: I765dc394f39f60801843851760fdf9838958d7a4
---
 .../libstagefright/codecs/amrnb/common/Android.mk  |   2 -
 .../codecs/amrnb/common/include/bytesused.h        | 109 -----------
 .../codecs/amrnb/common/src/bytesused.cpp          | 208 ---------------------
 .../codecs/amrnb/common/src/overflow_tbl.cpp       | 174 -----------------
 .../codecs/avc/enc/src/findhalfpel.cpp             |  13 --
 media/libstagefright/codecs/on2/dec/SoftVPX.cpp    |   4 -
 6 files changed, 510 deletions(-)
 delete mode 100644 media/libstagefright/codecs/amrnb/common/include/bytesused.h
 delete mode 100644 media/libstagefright/codecs/amrnb/common/src/bytesused.cpp
 delete mode 100644 media/libstagefright/codecs/amrnb/common/src/overflow_tbl.cpp

diff --git a/media/libstagefright/codecs/amrnb/common/Android.mk b/media/libstagefright/codecs/amrnb/common/Android.mk
index 5e632a6..80b67bb 100644
--- a/media/libstagefright/codecs/amrnb/common/Android.mk
+++ b/media/libstagefright/codecs/amrnb/common/Android.mk
@@ -7,7 +7,6 @@ LOCAL_SRC_FILES := \
  	src/bitno_tab.cpp \
  	src/bitreorder_tab.cpp \
  	src/bits2prm.cpp \
- 	src/bytesused.cpp \
  	src/c2_9pf_tab.cpp \
  	src/copy.cpp \
  	src/div_32.cpp \
@@ -38,7 +37,6 @@ LOCAL_SRC_FILES := \
  	src/mult_r.cpp \
  	src/norm_l.cpp \
  	src/norm_s.cpp \
- 	src/overflow_tbl.cpp \
  	src/ph_disp_tab.cpp \
  	src/pow2.cpp \
  	src/pow2_tbl.cpp \
diff --git a/media/libstagefright/codecs/amrnb/common/include/bytesused.h b/media/libstagefright/codecs/amrnb/common/include/bytesused.h
deleted file mode 100644
index 934efbe..0000000
--- a/media/libstagefright/codecs/amrnb/common/include/bytesused.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-/****************************************************************************************
-Portions of this file are derived from the following 3GPP standard:
-
-    3GPP TS 26.073
-    ANSI-C code for the Adaptive Multi-Rate (AMR) speech codec
-    Available from http://www.3gpp.org
-
-(C) 2004, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TTA, TTC)
-Permission to distribute, modify and use this file under the standard license
-terms listed above has been obtained from the copyright holder.
-****************************************************************************************/
-/*
-
- Pathname: .audio/gsm-amr/c/include/BytesUsed.h
-
-------------------------------------------------------------------------------
- REVISION HISTORY
-
- Description: Added #ifdef __cplusplus after Include section.
-
- Who:                       Date:
- Description:
-
-------------------------------------------------------------------------------
- INCLUDE DESCRIPTION
-
- This file declares a table BytesUsed.
-
-------------------------------------------------------------------------------
-*/
-
-/*----------------------------------------------------------------------------
-; CONTINUE ONLY IF NOT ALREADY DEFINED
-----------------------------------------------------------------------------*/
-#ifndef BYTESUSED_H
-#define BYTESUSED_H
-
-/*----------------------------------------------------------------------------
-; INCLUDES
-----------------------------------------------------------------------------*/
-
-/*--------------------------------------------------------------------------*/
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-    /*----------------------------------------------------------------------------
-    ; MACROS
-    ; Define module specific macros here
-    ----------------------------------------------------------------------------*/
-
-    /*----------------------------------------------------------------------------
-    ; DEFINES
-    ; Include all pre-processor statements here.
-    ----------------------------------------------------------------------------*/
-
-    /*----------------------------------------------------------------------------
-    ; EXTERNAL VARIABLES REFERENCES
-    ; Declare variables used in this module but defined elsewhere
-    ----------------------------------------------------------------------------*/
-    extern const short BytesUsed[];
-
-    /*----------------------------------------------------------------------------
-    ; SIMPLE TYPEDEF'S
-    ----------------------------------------------------------------------------*/
-
-    /*----------------------------------------------------------------------------
-    ; ENUMERATED TYPEDEF'S
-    ----------------------------------------------------------------------------*/
-
-    /*----------------------------------------------------------------------------
-    ; STRUCTURES TYPEDEF'S
-    ----------------------------------------------------------------------------*/
-
-
-    /*----------------------------------------------------------------------------
-    ; GLOBAL FUNCTION DEFINITIONS
-    ; Function Prototype declaration
-    ----------------------------------------------------------------------------*/
-
-
-    /*----------------------------------------------------------------------------
-    ; END
-    ----------------------------------------------------------------------------*/
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-
diff --git a/media/libstagefright/codecs/amrnb/common/src/bytesused.cpp b/media/libstagefright/codecs/amrnb/common/src/bytesused.cpp
deleted file mode 100644
index b61bac4..0000000
--- a/media/libstagefright/codecs/amrnb/common/src/bytesused.cpp
+++ /dev/null
@@ -1,208 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-/****************************************************************************************
-Portions of this file are derived from the following 3GPP standard:
-
-    3GPP TS 26.073
-    ANSI-C code for the Adaptive Multi-Rate (AMR) speech codec
-    Available from http://www.3gpp.org
-
-(C) 2004, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TTA, TTC)
-Permission to distribute, modify and use this file under the standard license
-terms listed above has been obtained from the copyright holder.
-****************************************************************************************/
-/*
-
- Pathname: ./audio/gsm-amr/c/src/BytesUsed.c
-
-------------------------------------------------------------------------------
- REVISION HISTORY
-
- Description: Corrected entries for all SID frames and updated function
-              description. Updated copyright year.
-
- Description: Added #ifdef __cplusplus and removed "extern" from table
-              definition. Removed corresponding header file from Include
-              section.
-
- Description: Put "extern" back.
-
- Who:                       Date:
- Description:
-
-------------------------------------------------------------------------------
- INPUT AND OUTPUT DEFINITIONS
-
- Inputs:
-    None
-
- Local Stores/Buffers/Pointers Needed:
-    None
-
- Global Stores/Buffers/Pointers Needed:
-    None
-
- Outputs:
-    None
-
- Pointers and Buffers Modified:
-    None
-
- Local Stores Modified:
-    None
-
- Global Stores Modified:
-    None
-
-------------------------------------------------------------------------------
- FUNCTION DESCRIPTION
-
- This function creates a table called BytesUsed that holds the value that
- describes the number of bytes required to hold one frame worth of data in
- the WMF (non-IF2) frame format. Each table entry is the sum of the frame
- type byte and the number of bytes used up by the core speech data for each
- 3GPP frame type.
-
-------------------------------------------------------------------------------
- REQUIREMENTS
-
- None
-
-------------------------------------------------------------------------------
- REFERENCES
-
- [1] "AMR Speech Codec Frame Structure", 3GPP TS 26.101 version 4.1.0
-     Release 4, June 2001, page 13.
-
-------------------------------------------------------------------------------
- PSEUDO-CODE
-
-
-------------------------------------------------------------------------------
- RESOURCES USED
-   When the code is written for a specific target processor the
-     the resources used should be documented below.
-
- STACK USAGE: [stack count for this module] + [variable to represent
-          stack usage for each subroutine called]
-
-     where: [stack usage variable] = stack usage for [subroutine
-         name] (see [filename].ext)
-
- DATA MEMORY USED: x words
-
- PROGRAM MEMORY USED: x words
-
- CLOCK CYCLES: [cycle count equation for this module] + [variable
-           used to represent cycle count for each subroutine
-           called]
-
-     where: [cycle count variable] = cycle count for [subroutine
-        name] (see [filename].ext)
-
-------------------------------------------------------------------------------
-*/
-
-
-/*----------------------------------------------------------------------------
-; INCLUDES
-----------------------------------------------------------------------------*/
-#include "typedef.h"
-
-/*--------------------------------------------------------------------------*/
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-    /*----------------------------------------------------------------------------
-    ; MACROS
-    ; Define module specific macros here
-    ----------------------------------------------------------------------------*/
-
-
-    /*----------------------------------------------------------------------------
-    ; DEFINES
-    ; Include all pre-processor statements here. Include conditional
-    ; compile variables also.
-    ----------------------------------------------------------------------------*/
-
-    /*----------------------------------------------------------------------------
-    ; LOCAL FUNCTION DEFINITIONS
-    ; Function Prototype declaration
-    ----------------------------------------------------------------------------*/
-
-
-    /*----------------------------------------------------------------------------
-    ; LOCAL STORE/BUFFER/POINTER DEFINITIONS
-    ; Variable declaration - defined here and used outside this module
-    ----------------------------------------------------------------------------*/
-    const short BytesUsed[16] =
-    {
-        13, /* 4.75 */
-        14, /* 5.15 */
-        16, /* 5.90 */
-        18, /* 6.70 */
-        20, /* 7.40 */
-        21, /* 7.95 */
-        27, /* 10.2 */
-        32, /* 12.2 */
-        6, /* GsmAmr comfort noise */
-        7, /* Gsm-Efr comfort noise */
-        6, /* IS-641 comfort noise */
-        6, /* Pdc-Efr comfort noise */
-        0, /* future use */
-        0, /* future use */
-        0, /* future use */
-        1 /* No transmission */
-    };
-    /*----------------------------------------------------------------------------
-    ; EXTERNAL FUNCTION REFERENCES
-    ; Declare functions defined elsewhere and referenced in this module
-    ----------------------------------------------------------------------------*/
-
-
-    /*----------------------------------------------------------------------------
-    ; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
-    ; Declare variables used in this module but defined elsewhere
-    ----------------------------------------------------------------------------*/
-
-
-    /*--------------------------------------------------------------------------*/
-#ifdef __cplusplus
-}
-#endif
-
-/*----------------------------------------------------------------------------
-; FUNCTION CODE
-----------------------------------------------------------------------------*/
-
-/*----------------------------------------------------------------------------
-; Define all local variables
-----------------------------------------------------------------------------*/
-
-
-/*----------------------------------------------------------------------------
-; Function body here
-----------------------------------------------------------------------------*/
-
-
-/*----------------------------------------------------------------------------
-; Return nothing or data or data pointer
-----------------------------------------------------------------------------*/
-
diff --git a/media/libstagefright/codecs/amrnb/common/src/overflow_tbl.cpp b/media/libstagefright/codecs/amrnb/common/src/overflow_tbl.cpp
deleted file mode 100644
index c4a016d..0000000
--- a/media/libstagefright/codecs/amrnb/common/src/overflow_tbl.cpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-/****************************************************************************************
-Portions of this file are derived from the following 3GPP standard:
-
-    3GPP TS 26.073
-    ANSI-C code for the Adaptive Multi-Rate (AMR) speech codec
-    Available from http://www.3gpp.org
-
-(C) 2004, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TTA, TTC)
-Permission to distribute, modify and use this file under the standard license
-terms listed above has been obtained from the copyright holder.
-****************************************************************************************/
-/*
-
- Filename: /audio/gsm_amr/c/src/overflow_tbl.c
-
-------------------------------------------------------------------------------
- REVISION HISTORY
-
- Description: Added #ifdef __cplusplus and removed "extern" from table
-              definition.
-
- Description: Put "extern" back.
-
- Who:                       Date:
- Description:
-
-------------------------------------------------------------------------------
- MODULE DESCRIPTION
-
- This file contains the declaration for overflow_tbl[] used by the l_shl()
- and l_shr() functions.
-
-------------------------------------------------------------------------------
-*/
-
-/*----------------------------------------------------------------------------
-; INCLUDES
-----------------------------------------------------------------------------*/
-#include "typedef.h"
-
-/*--------------------------------------------------------------------------*/
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-    /*----------------------------------------------------------------------------
-    ; MACROS
-    ; [Define module specific macros here]
-    ----------------------------------------------------------------------------*/
-
-    /*----------------------------------------------------------------------------
-    ; DEFINES
-    ; [Include all pre-processor statements here. Include conditional
-    ; compile variables also.]
-    ----------------------------------------------------------------------------*/
-
-    /*----------------------------------------------------------------------------
-    ; LOCAL FUNCTION DEFINITIONS
-    ; [List function prototypes here]
-    ----------------------------------------------------------------------------*/
-
-    /*----------------------------------------------------------------------------
-    ; LOCAL VARIABLE DEFINITIONS
-    ; [Variable declaration - defined here and used outside this module]
-    ----------------------------------------------------------------------------*/
-    const Word32 overflow_tbl [32]   = {0x7fffffffL, 0x3fffffffL,
-        0x1fffffffL, 0x0fffffffL,
-        0x07ffffffL, 0x03ffffffL,
-        0x01ffffffL, 0x00ffffffL,
-        0x007fffffL, 0x003fffffL,
-        0x001fffffL, 0x000fffffL,
-        0x0007ffffL, 0x0003ffffL,
-        0x0001ffffL, 0x0000ffffL,
-        0x00007fffL, 0x00003fffL,
-        0x00001fffL, 0x00000fffL,
-        0x000007ffL, 0x000003ffL,
-        0x000001ffL, 0x000000ffL,
-        0x0000007fL, 0x0000003fL,
-        0x0000001fL, 0x0000000fL,
-        0x00000007L, 0x00000003L,
-        0x00000001L, 0x00000000L
-    };
-
-    /*--------------------------------------------------------------------------*/
-#ifdef __cplusplus
-}
-#endif
-
-/*
-------------------------------------------------------------------------------
- FUNCTION NAME:
-------------------------------------------------------------------------------
- INPUT AND OUTPUT DEFINITIONS
-
- Inputs:
-    None
-
- Outputs:
-    None
-
- Returns:
-    None
-
- Global Variables Used:
-    None
-
- Local Variables Needed:
-    None
-
-------------------------------------------------------------------------------
- FUNCTION DESCRIPTION
-
- None
-
-------------------------------------------------------------------------------
- REQUIREMENTS
-
- None
-
-------------------------------------------------------------------------------
- REFERENCES
-
- [1] l_shl() function in basic_op2.c,  UMTS GSM AMR speech codec, R99 -
- Version 3.2.0, March 2, 2001
-
-------------------------------------------------------------------------------
- PSEUDO-CODE
-
-
-------------------------------------------------------------------------------
- RESOURCES USED [optional]
-
- When the code is written for a specific target processor the
- the resources used should be documented below.
-
- HEAP MEMORY USED: x bytes
-
- STACK MEMORY USED: x bytes
-
- CLOCK CYCLES: (cycle count equation for this function) + (variable
-                used to represent cycle count for each subroutine
-                called)
-     where: (cycle count variable) = cycle count for [subroutine
-                                     name]
-
-------------------------------------------------------------------------------
- CAUTION [optional]
- [State any special notes, constraints or cautions for users of this function]
-
-------------------------------------------------------------------------------
-*/
-
-/*----------------------------------------------------------------------------
-; FUNCTION CODE
-----------------------------------------------------------------------------*/
-
diff --git a/media/libstagefright/codecs/avc/enc/src/findhalfpel.cpp b/media/libstagefright/codecs/avc/enc/src/findhalfpel.cpp
index 0b8d9e2..d0bbee2 100644
--- a/media/libstagefright/codecs/avc/enc/src/findhalfpel.cpp
+++ b/media/libstagefright/codecs/avc/enc/src/findhalfpel.cpp
@@ -23,19 +23,6 @@
 
 #define PREF_16_VEC 129     /* 1MV bias versus 4MVs*/
 
-const static int distance_tab[9][9] =   /* [hp_guess][k] */
-{
-    {0, 1, 1, 1, 1, 1, 1, 1, 1},
-    {1, 0, 1, 2, 3, 4, 3, 2, 1},
-    {1, 0, 0, 0, 1, 2, 3, 2, 1},
-    {1, 2, 1, 0, 1, 2, 3, 4, 3},
-    {1, 2, 1, 0, 0, 0, 1, 2, 3},
-    {1, 4, 3, 2, 1, 0, 1, 2, 3},
-    {1, 2, 3, 2, 1, 0, 0, 0, 1},
-    {1, 2, 3, 4, 3, 2, 1, 0, 1},
-    {1, 0, 1, 2, 3, 2, 1, 0, 0}
-};
-
 #define CLIP_RESULT(x)      if((uint)x > 0xFF){ \
                  x = 0xFF & (~(x>>31));}
 
diff --git a/media/libstagefright/codecs/on2/dec/SoftVPX.cpp b/media/libstagefright/codecs/on2/dec/SoftVPX.cpp
index 912fac2..444a7fc 100644
--- a/media/libstagefright/codecs/on2/dec/SoftVPX.cpp
+++ b/media/libstagefright/codecs/on2/dec/SoftVPX.cpp
@@ -102,7 +102,6 @@ status_t SoftVPX::destroyDecoder() {
 }
 
 bool SoftVPX::outputBuffers(bool flushDecoder, bool display, bool eos, bool *portWillReset) {
-    List<BufferInfo *> &inQueue = getPortQueue(0);
     List<BufferInfo *> &outQueue = getPortQueue(1);
     BufferInfo *outInfo = NULL;
     OMX_BUFFERHEADERTYPE *outHeader = NULL;
@@ -215,7 +214,6 @@ void SoftVPX::onQueueFilled(OMX_U32 /* portIndex */) {
     List<BufferInfo *> &inQueue = getPortQueue(0);
     List<BufferInfo *> &outQueue = getPortQueue(1);
     bool EOSseen = false;
-    vpx_codec_err_t err;
     bool portWillReset = false;
 
     while ((mEOSStatus == INPUT_EOS_SEEN || !inQueue.empty())
@@ -239,8 +237,6 @@ void SoftVPX::onQueueFilled(OMX_U32 /* portIndex */) {
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
         mTimeStamps[mTimeStampIdx] = inHeader->nTimeStamp;
 
-        BufferInfo *outInfo = *outQueue.begin();
-        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
         if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
             mEOSStatus = INPUT_EOS_SEEN;
             EOSseen = true;
-- 
2.7.4


From d5f44114cb8b17e21b26457a715acc0a3296b16f Mon Sep 17 00:00:00 2001
From: Wei Jia <wjia@google.com>
Date: Wed, 3 Feb 2016 14:28:00 -0800
Subject: [PATCH 113/119] MPEG4Extractor: cast media time to int64_t in order
 to avoid check on unsigned integer overflow.

Change-Id: Iad5ae41f0bbfc5e837b4b78e8acaa3f9462329e6
---
 media/libstagefright/MPEG4Extractor.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 9b7c2b7..47d9162 100755
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -1118,7 +1118,7 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                     int64_t delay = (media_time  * samplerate + 500000) / 1000000;
                     mLastTrack->meta->setInt32(kKeyEncoderDelay, delay);
 
-                    int64_t paddingus = duration - (segment_duration + media_time);
+                    int64_t paddingus = duration - (int64_t)(segment_duration + media_time);
                     if (paddingus < 0) {
                         // track duration from media header (which is what kKeyDuration is) might
                         // be slightly shorter than the segment duration, which would make the
-- 
2.7.4


From cf43275da14c55b2e11a65636bd6439757ab62f9 Mon Sep 17 00:00:00 2001
From: Patrik2 Carlsson <patrik2.carlsson@sonymobile.com>
Date: Mon, 25 May 2015 15:12:49 +0200
Subject: [PATCH 114/119] Avoid parsing CC SEI payload beyond buffer end

Break CC SEI parsing when payload size exceeds buffer size
to avoid a CHECK that have been seen in MTBF statistics.

Change-Id: Ifd97648678a935ac815dd616301d46f9bf583838
---
 media/libmediaplayerservice/nuplayer/NuPlayerCCDecoder.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerCCDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerCCDecoder.cpp
index ac3c6b6..2c07f28 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerCCDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerCCDecoder.cpp
@@ -235,6 +235,12 @@ bool NuPlayer::CCDecoder::parseSEINalUnit(
             payload_size += last_byte;
         } while (last_byte == 0xFF);
 
+        if (payload_size > SIZE_MAX / 8
+                || !br.atLeastNumBitsLeft(payload_size * 8)) {
+            ALOGV("Malformed SEI payload");
+            break;
+        }
+
         // sei_payload()
         if (payload_type == 4) {
             bool isCC = false;
-- 
2.7.4


From ccd0023f1ba4ad92b0bb76af8339fae90d3397d3 Mon Sep 17 00:00:00 2001
From: Mohan Kumar <mkumard@nvidia.com>
Date: Fri, 12 Dec 2014 15:16:46 +0530
Subject: [PATCH 115/119] audioflinger: clear mMixerBuffer if frame is not
 ready

Clear the mMixerBuffer if frame is not ready before the FastMixer
starts processing. Otherwise it might result in large glitches on
output device due to junk data present in the mixbuffer.

Change-Id: I9f025234d4ac100f85d2ec67c06a8df4195bea98
---
 services/audioflinger/FastMixer.cpp | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/services/audioflinger/FastMixer.cpp b/services/audioflinger/FastMixer.cpp
index 45c68b5..2bc8066 100644
--- a/services/audioflinger/FastMixer.cpp
+++ b/services/audioflinger/FastMixer.cpp
@@ -334,6 +334,11 @@ void FastMixer::onWork()
 
     if ((command & FastMixerState::MIX) && (mMixer != NULL) && mIsWarm) {
         ALOG_ASSERT(mMixerBuffer != NULL);
+
+        // AudioMixer::mState.enabledTracks is undefined if mState.hook == process__validate,
+        // so we keep a side copy of enabledTracks
+        bool anyEnabledTracks = false;
+
         // for each track, update volume and check for underrun
         unsigned currentTrackMask = current->mTrackMask;
         while (currentTrackMask != 0) {
@@ -392,11 +397,13 @@ void FastMixer::onWork()
                     underruns.mBitFields.mPartial++;
                     underruns.mBitFields.mMostRecent = UNDERRUN_PARTIAL;
                     mMixer->enable(name);
+                    anyEnabledTracks = true;
                 }
             } else {
                 underruns.mBitFields.mFull++;
                 underruns.mBitFields.mMostRecent = UNDERRUN_FULL;
                 mMixer->enable(name);
+                anyEnabledTracks = true;
             }
             ftDump->mUnderruns = underruns;
             ftDump->mFramesReady = framesReady;
@@ -407,9 +414,14 @@ void FastMixer::onWork()
             pts = AudioBufferProvider::kInvalidPTS;
         }
 
-        // process() is CPU-bound
-        mMixer->process(pts);
-        mMixerBufferState = MIXED;
+        if (anyEnabledTracks) {
+            // process() is CPU-bound
+            mMixer->process(pts);
+            mMixerBufferState = MIXED;
+        } else if (mMixerBufferState != ZEROED) {
+            mMixerBufferState = UNDEFINED;
+        }
+
     } else if (mMixerBufferState == MIXED) {
         mMixerBufferState = UNDEFINED;
     }
-- 
2.7.4


From cab337207e95778640ffe21bb10dbce2a2f7d9f6 Mon Sep 17 00:00:00 2001
From: Ricardo Cerqueira <ricardo@cyngn.com>
Date: Wed, 11 May 2016 16:26:44 +0100
Subject: [PATCH 116/119] FFMPEGSoftCodec: Initialize the OMX param struct
 before using it

Make sure all the items in the port param config are filled out, not
just those we expect to use.

Ref: CYNGNOS-2797
Change-Id: I9271a83fc6496cfe5ad14e45841cd8a05ffece30
---
 media/libstagefright/FFMPEGSoftCodec.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index 26afd89..f981c71 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -325,6 +325,7 @@ status_t FFMPEGSoftCodec::setVideoFormat(
 
         int32_t mode = 0;
         OMX_QCOM_PARAM_PORTDEFINITIONTYPE portFmt;
+        InitOMXParams(&portFmt);
         portFmt.nPortIndex = kPortIndexInput;
 
         if (msg->findInt32("use-arbitrary-mode", &mode) && mode) {
-- 
2.7.4


From 9700d096bac993d2ba13d84cb862c17b48377c7b Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Thu, 12 May 2016 10:19:57 -0700
Subject: [PATCH 117/119] Revert "nuplayer: Fix audio EOS notifiy on AudioSink
 not ready"

This patch is buggy, and causing notifyConsume not called
when the buffer is erased, causing audio discontinous cannot
resume properly. This patch is not in 8994 CAF also.

FEIJ-276

This reverts commit dc5f0eb0bb08885f63a97a111b02e234efc5c413.

Change-Id: Idcb5ec9a419a979afe170d3a518ee7696a6fac6c
---
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp | 12 ------------
 1 file changed, 12 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index ccb292d..9af336f 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -852,18 +852,6 @@ bool NuPlayer::Renderer::onDrainAudioQueue() {
     // immediately after start. Investigate error message
     // "vorbis_dsp_synthesis returned -135", along with RTSP.
     uint32_t numFramesPlayed;
-    if(!mAudioSink->ready() && !mAudioQueue.empty()) {
-        while (!mAudioQueue.empty()) {
-            QueueEntry *entry = &*mAudioQueue.begin();
-            if (entry->mBuffer == NULL) {
-                notifyEOS(true /* audio */, entry->mFinalResult);
-            }
-            mAudioQueue.erase(mAudioQueue.begin());
-            entry = NULL;
-        }
-        return false;
-    }
-
     if (mAudioSink->getPosition(&numFramesPlayed) != OK) {
         // When getPosition fails, renderer will not reschedule the draining
         // unless new samples are queued.
-- 
2.7.4


From 32aaad4343b522ccb74124746b35345d63fb4516 Mon Sep 17 00:00:00 2001
From: Keith Mok <kmok@cyngn.com>
Date: Wed, 18 May 2016 14:26:49 -0700
Subject: [PATCH 118/119] stagefright: Fix cts issue with divx test

8909 is using soft-ip divx decoder using component
name starts with "OMX.ittiam." instead of "OMX.qcom."
leading to FFMPEGSoftCodec override with wrong compression
format using OMX_VIDEO_CodingDIVX (0x7F000003) defined in
OMX_FFMPEG_Extn.h. But qcom omx component actually use
QOMX_VIDEO_CodingDivx (0x7FA30C02) which defined in OMX_QCOMExtns.h.

Add checking for OMX.ittiam in additional to OMX.qcom solved the
problem.

FEIJ-700

Change-Id: I4071eb3978974d1072373f0c88ea83653c0c53a9
---
 media/libstagefright/FFMPEGSoftCodec.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
index f981c71..7233162 100644
--- a/media/libstagefright/FFMPEGSoftCodec.cpp
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -319,7 +319,8 @@ status_t FFMPEGSoftCodec::setVideoFormat(
     // from the CAF L release. It was unfortunately moved to a proprietary
     // blob and an architecture which is hellish for OEMs who wish to
     // customize the platform.
-    if (err == OK && (!strncmp(componentName, "OMX.qcom.", 9))) {
+    if (err == OK && (!strncmp(componentName, "OMX.qcom.", 9)
+        || !strncmp(componentName, "OMX.ittiam.", 11))) {
         status_t xerr = OK;
 
 
-- 
2.7.4


From 989d018c43017cbf26f97f20a665d3997f1ad527 Mon Sep 17 00:00:00 2001
From: Caio Schnepper <caioschnepper@gmail.com>
Date: Wed, 5 Aug 2015 16:17:14 -0300
Subject: [PATCH 119/119] stagefright: Correct Exynos4 stride alignment

For the OMX_COLOR_FormatYUV420Planar color format case, Google's VP9
codec is used, in that case the colors were shifting 16 bytes per
horizontal line, causing green lines to appear on video playback.

Change-Id: I4cf0fd40b79e53882d99f1c3f263c8a98fff1f30
---
 media/libstagefright/colorconversion/SoftwareRenderer.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
index 3fa29a2..59af12a 100644
--- a/media/libstagefright/colorconversion/SoftwareRenderer.cpp
+++ b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
@@ -261,8 +261,14 @@ std::list<FrameRenderTracker::Info> SoftwareRenderer::render(
 
         uint8_t *dst_y = (uint8_t *)dst;
         size_t dst_y_size = buf->stride * buf->height;
+
+#ifdef EXYNOS4_ENHANCEMENTS
+        size_t dst_c_stride = buf->stride / 2;
+        size_t dst_c_size = ALIGN(dst_c_stride, 16) * buf->height / 2;
+#else
         size_t dst_c_stride = ALIGN(buf->stride / 2, 16);
         size_t dst_c_size = dst_c_stride * buf->height / 2;
+#endif
         uint8_t *dst_v = dst_y + dst_y_size;
         uint8_t *dst_u = dst_v + dst_c_size;
 
-- 
2.7.4

